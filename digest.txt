Directory structure:
â””â”€â”€ pokeclone/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ ToDo.md
    â”œâ”€â”€ battle_simulator.py
    â”œâ”€â”€ pixle_art_editor.py
    â”œâ”€â”€ requirements-dev.txt
    â”œâ”€â”€ requirements.txt
    â”œâ”€â”€ backgrounds/
    â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ monsters.json
    â”‚   â”œâ”€â”€ moves.json
    â”‚   â””â”€â”€ type_chart.json
    â”œâ”€â”€ scripts/
    â”‚   â”œâ”€â”€ convert_sprites.py
    â”‚   â”œâ”€â”€ create_empty_sprites.py
    â”‚   â””â”€â”€ create_test_ref_image.py
    â”œâ”€â”€ songs/
    â”œâ”€â”€ sounds/
    â”‚   â”œâ”€â”€ .DS_Store
    â”‚   â”œâ”€â”€ monsters/
    â”‚   â””â”€â”€ moves/
    â”œâ”€â”€ sprites/
    â”‚   â””â”€â”€ .DS_Store
    â”œâ”€â”€ sprites_backup/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ backgrounds/
    â”‚   â”œâ”€â”€ battle/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ battle_simulator.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ core/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ config.py
    â”‚   â”‚   â”œâ”€â”€ event_handler.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ editor/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ dialog_manager.py
    â”‚   â”‚   â”œâ”€â”€ editor_ui.py
    â”‚   â”‚   â”œâ”€â”€ pixle_art_editor.py
    â”‚   â”‚   â”œâ”€â”€ selection_manager.py
    â”‚   â”‚   â”œâ”€â”€ sprite_editor.py
    â”‚   â”‚   â”œâ”€â”€ tool_manager.py
    â”‚   â”‚   â”œâ”€â”€ undo_redo_manager.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ songs/
    â”‚   â”œâ”€â”€ sounds/
    â”‚   â”œâ”€â”€ sprites/
    â”‚   â””â”€â”€ ui/
    â”‚       â”œâ”€â”€ __init__.py
    â”‚       â””â”€â”€ ui_manager.py
    â””â”€â”€ tests/
        â”œâ”€â”€ __init__.py
        â”œâ”€â”€ _test_pixle_art_editor.py
        â”œâ”€â”€ test_battle_simulator.py
        â”œâ”€â”€ test_editor_ui.py
        â”œâ”€â”€ test_event_handler.py
        â”œâ”€â”€ test_sprite_editor.py
        â”œâ”€â”€ test_tool_manager.py
        â”œâ”€â”€ .DS_Store
        â”œâ”€â”€ __pycache__/
        â””â”€â”€ assets/

================================================
File: README.md
================================================
# PokeClone

A Pygame-based monster battling game featuring unique creatures with elemental types and special moves, along with an advanced pixel art editor for creating and editing sprites.

![Game Screenshot](docs/images/screenshot.png) <!-- TODO: Add actual screenshot -->

## ðŸŽ® Features

### Core Gameplay
- **Turn-based Combat System**: Engage in strategic battles where type advantages play a crucial role.
- **28 Unique Monsters**: Each monster comes with distinct stats and movesets.
- **80+ Different Moves**: A wide array of attacks and effects to enhance battles.
- **15 Elemental Types**: Diverse types with complex interactions to add depth to combat.
- **Stat Modification**: Utilize strategic buff and debuff mechanics to gain the upper hand.

### Pixel Art Editor
- **Advanced Editing Tools**: Selection, copy-paste, mirroring, and rotating tools for precise sprite editing.
- **Customizable Brush Sizes**: Adjust brush sizes to suit different editing needs.
- **Scrollable Color Palette**: Access a comprehensive range of colors for detailed sprite creation.
- **Sprite Management**: Easily switch between front and back sprites for each monster.
- **Undo/Redo Functionality**: Revert or reapply changes with ease.
- **Integration with Game**: Seamlessly create and edit sprites that integrate directly into the game.

### Elemental Types
- ðŸ”¥ Fire
- ðŸ’§ Water
- ðŸŒ Earth
- ðŸ’¨ Wind
- âš¡ Electric
- â„ï¸ Ice
- ðŸŒ¿ Nature
- ðŸ§  Mind
- ðŸ‘» Shadow
- âœ¨ Light
- ðŸ”§ Metal
- â˜ ï¸ Toxic
- ðŸ”Š Sound
- ðŸ’Ž Crystal
- ðŸŒŒ Cosmic

## ðŸš€ Getting Started

### Prerequisites
- **Python 3.6+**
- **Pygame library**
- **Tkinter** (usually included with Python)
- **Graphics card with OpenGL support** (recommended for optimal performance)

### Installation

1. **Clone the repository:**
    ```bash
    git clone https://github.com/yourusername/pokeclone.git
    cd pokeclone
    ```

2. **Create and activate a virtual environment (recommended):**
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```

3. **Install required dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

### Running the Game
```bash
python battle_simulator.py
```

### Using the Pixel Art Editor
1. **Run the Pixel Art Editor:**
    ```bash
    python pixel_art_editor.py
    ```

2. **Create or Edit Sprites:**
    - **Select Editing Mode:** Choose between editing monster sprites or background images.
    - **Use Tools:** Utilize selection, brush, eraser, fill, and other tools to create detailed pixel art.
    - **Save Your Work:** Save your edited sprites, which will be used in the main game.

## ðŸŽ¯ Game Mechanics

### Battle System
- **Turn-based Combat**: Players and opponents take turns selecting moves to attack or apply effects.
- **Type Effectiveness Multipliers**: Deals more or less damage based on the interaction between elemental types.
- **Switching Turns**: After a player uses a move, the opponent selects a move to respond.

### Stats System
- **HP (Health Points)**: Determines how much damage a creature can take before being defeated.
- **Attack**: Influences the damage dealt by physical moves.
- **Defense**: Reduces incoming physical damage.
- **Type Advantages/Disadvantages**: Certain types are stronger or weaker against others, affecting damage calculations.

### Move Categories
- **Damage Moves**: Deals direct damage with type advantages.
- **Buff Moves**: Enhances the user's stats.
- **Debuff Moves**: Reduces the opponent's stats.

## ðŸ—‚ï¸ Project Structure

```
pokeclone/
â”œâ”€â”€ battle_simulator.py     # Entry point script for the battle simulator
â”œâ”€â”€ pixle_art_editor.py     # Entry point script for the pixel art editor
â”œâ”€â”€ requirements.txt        # Project dependencies
â”œâ”€â”€ README.md               # This file
â”œâ”€â”€ LICENSE                 # MIT License (Assumed, add if exists)
â”œâ”€â”€ ToDo.md                 # KANBAN/ToDo list
â”œâ”€â”€ scripts/                # Utility and conversion scripts
â”‚   â”œâ”€â”€ convert_sprites.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ src/                    # Main source code directory
â”‚   â”œâ”€â”€ __init__.py         # Makes src a package
â”‚   â”œâ”€â”€ core/               # Core components (config, event handling)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â””â”€â”€ event_handler.py
â”‚   â”œâ”€â”€ battle/             # Battle simulator logic
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ battle_simulator.py
â”‚   â”œâ”€â”€ editor/             # Pixel art editor logic and UI
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ pixle_art_editor.py
â”‚   â”‚   â”œâ”€â”€ editor_ui.py
â”‚   â”‚   â”œâ”€â”€ sprite_editor.py
â”‚   â”‚   â””â”€â”€ ... (tool_manager, selection_manager, etc.)
â”‚   â””â”€â”€ ui/                 # General UI components (if any)
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ ui_manager.py
â”œâ”€â”€ data/                   # Game data files
â”‚   â”œâ”€â”€ monsters.json       # Monster definitions
â”‚   â”œâ”€â”€ moves.json          # Move definitions
â”‚   â””â”€â”€ type_chart.json     # Type effectiveness data
â”œâ”€â”€ sprites/                # Monster sprite images (native resolution)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ sprites_backup/         # Backups of original sprites (if conversion script used)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ backgrounds/            # Battle background images
â”‚   â””â”€â”€ ...
â”œâ”€â”€ sounds/                 # Game sound effects
â”‚   â””â”€â”€ ...
â”œâ”€â”€ songs/                  # Background music tracks
â”‚   â””â”€â”€ ...
â””â”€â”€ tests/                  # Unit and integration tests
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ test_battle_simulator.py
    â””â”€â”€ ...
```

## ðŸŽ® Controls

### In-Game Controls
- **Mouse Controls**
  - **Left Click**: Select options and moves.

### Pixel Art Editor Controls
- **Mouse Controls**
  - **Left Click**: Select pixels or interact with UI elements.
  - **Right Click**: Activate eraser mode.
  - **Scroll Wheel**: Zoom in and out.
- **Keyboard Shortcuts**
  - **Ctrl + Z**: Undo.
  - **Ctrl + Y**: Redo.
  - **Ctrl + S**: Save current work.
  - **Ctrl + O**: Open a background file.
  - **Ctrl + C**: Copy selected area.
  - **Ctrl + V**: Paste copied area.
  - **Ctrl + M**: Mirror selected area.
  - **Ctrl + R**: Rotate selected area.
  - **+/-**: Increase or decrease brush size.
  - **ESC**: Exit selection mode.

## ðŸ› ï¸ Development

### Building from Source
```bash
git clone https://github.com/yourusername/pokeclone.git
cd pokeclone
pip install -r requirements.txt
python battle_simulator.py
```

### Contributing
1. **Fork the repository**
2. **Create a feature branch**
    ```bash
    git checkout -b feature/AmazingFeature
    ```
3. **Commit your changes**
    ```bash
    git commit -m 'Add AmazingFeature'
    ```
4. **Push to the branch**
    ```bash
    git push origin feature/AmazingFeature
    ```
5. **Open a Pull Request**

## ðŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ðŸ¤ Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

## ðŸ› Bug Reports

Please use the GitHub Issues tab to report bugs. Include:
- Expected behavior
- Actual behavior
- Steps to reproduce
- Python/Pygame versions
- Operating system

## âœ¨ Acknowledgments

- All monster and move names are original creations.
- Inspired by classic monster-battling games.
- Thanks to Anthropic and OpenAI for their excellent assistants.

## ðŸ“š Documentation

Coming Soon 

---

Made with â¤ï¸ by Thomas Kolarik, Claude, ChatGPTo1-mini


================================================
File: ToDo.md
================================================
# PokeClone Project KANBAN Board (Detailed - 2025-04-06 v6)

---

## To Do

### Highest Priority

### High Priority

### Medium Priority

* **[POKE-11] Improve Pixel Editor UI/UX Feedback**
    * **Type:** Improvement
    * **Priority:** Medium
    * **Description:** The pixel art editor currently lacks some key visual feedback... (previous description remains) ...Review and correct the panning logic to use standard mouse wheel events (`event.y` for vertical) and potentially implement panning via middle-mouse drag or keyboard modifiers + mouse drag for more control.
    * **Acceptance Criteria:**
        * The currently selected drawing/editing tool is clearly indicated visually.
        * Zooming feels intuitive, potentially centering on the cursor.
        * Panning works predictably using standard controls.
        * **Testing:** Manual testing confirms that the visual indicator for the active tool is present and updates correctly.
        * **Testing:** Manual testing confirms that zoom behavior is intuitive and centers correctly (either on view or cursor, as implemented).
        * **Testing:** Manual testing confirms that panning controls work as expected and feel natural.
    * **Labels:** `ui`, `ux`, `editor`, `improvement`, `input`

* **[POKE-12] Enhance Opponent Battle AI**
    * **Type:** Improvement
    * **Priority:** Medium
    * **Description:** The current AI for the opponent in `battle_simulator.py` (`opponent_choose_move` function) is extremely basic... (previous description remains) ...Start by implementing basic type effectiveness considerations and perhaps HP awareness.
    * **Acceptance Criteria:**
        * The `opponent_choose_move` function uses game state information (e.g., types, HP) to make move decisions.
        * The opponent's behavior is noticeably more strategic than pure random selection.
        * The complexity can be increased incrementally.
        * **Testing:** Manual playtesting across several battles confirms the AI makes decisions that are more strategic than random.
        * **Testing:** Unit/integration tests (if applicable to the AI logic modules) are *written and pass*, verifying correct processing of game state.
    * **Labels:** `battle-system`, `ai`, `improvement`, `gameplay`

* **[POKE-13] Implement Battle Sound Effects**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** While the game has background music functionality (`battle_simulator.py` `play_random_song`), it lacks sound effects... (previous description remains) ...Ensure multiple sounds can play without cutting each other off abruptly (Pygame's mixer handles channels automatically to some extent).
    * **Acceptance Criteria:**
        * Sound effect files are present in the `sounds/` directory.
        * Sounds are loaded using `pygame.mixer.Sound`.
        * Key battle events (attacks, damage, faints, stat changes, win/loss) trigger corresponding sound effects.
        * Sound effects enhance the battle experience.
        * **Testing:** Manual testing confirms that appropriate sounds play at the correct times during battle sequences and that sounds do not excessively overlap or cut each other off.
    * **Labels:** `audio`, `battle-system`, `feature`, `immersion`, `ux`

* **[POKE-14] Refine Editor Tool State Management (Select/Paste/Mirror/Rotate)**
    * **Type:** Improvement / Bug
    * **Priority:** Medium
    * **Description:** Managing the editor's current mode (e.g., 'draw', 'select', 'paste') and how tools interact with these modes seems complex... (previous description remains) ...Refactor the `handle_event` and related functions to adhere to this explicit state management logic. This might be done as part of POKE-10.
    * **Acceptance Criteria:**
        * Editor modes (Draw, Select, Fill, Paste) and tool activations follow clear, predictable rules.
        * State transition logic is centralized or clearly managed.
        * Interactions like selecting colors or clicking buttons have consistent effects on the current mode.
        * Paste mode allows multiple placements until explicitly cancelled.
        * Using Copy, Mirror, Rotate behaves logically with respect to the active selection and mode.
        * **Testing:** Manual testing confirms that switching between tools and modes behaves predictably according to the defined rules.
        * **Testing:** Unit tests for the state machine/manager logic are *written and pass*.
    * **Labels:** `editor`, `state-management`, `refactoring`, `ux`, `bug`, `architecture`
    * **Depends On:** POKE-10 (potentially)

* **[TEST-1] Set up Unit Testing Framework**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** The project currently lacks automated tests... (previous description remains) ...Ensure basic setup allows tests to be written and executed easily.
    * **Acceptance Criteria:**
        * A testing framework (`unittest` or `pytest`) is added as a development dependency.
        * Project structure includes a dedicated `tests/` directory.
        * A sample test runs successfully using the framework's runner (e.g., `python -m unittest discover` or `pytest`).
        * Instructions for running tests are added (e.g., to README or a CONTRIBUTING guide).
        * **Testing:** Running the test runner executes the sample test and reports success. (AC inherently covers testing).
    * **Labels:** `testing`, `infrastructure`, `code-quality`

* **[TEST-2] Write Unit Tests for Damage Calculation Logic**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** The `calculate_damage` function in `battle_simulator.py` contains critical game logic... (previous description remains) ...(Optional) Mocking `random.uniform` to test the damage range calculation deterministically.
    * **Acceptance Criteria:**
        * A test suite exists for `calculate_damage`.
        * Tests cover various type effectiveness scenarios.
        * Tests cover stat-changing moves (0 power).
        * Tests pass reliably.
        * **Testing:** Running the test suite executes all *written* damage calculation tests and reports success. (AC inherently covers testing).
    * **Labels:** `testing`, `battle-system`, `code-quality`
    * **Depends On:** TEST-1, POKE-5 (for effectiveness values)

* **[TEST-3] Write Unit Tests for Stat Modification Logic**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** The `apply_stat_change` function (and potentially the underlying formula if POKE-7 is done) in `battle_simulator.py` modifies creature stats... (previous description remains) ...Potential edge cases (e.g., hitting max/min stat stages if implemented).
    * **Acceptance Criteria:**
        * A test suite exists for stat modification logic.
        * Tests cover buffs and debuffs for relevant stats.
        * Tests validate the calculated stat values against expected outcomes based on the implemented formula/stage system.
        * Tests pass reliably.
        * **Testing:** Running the test suite executes all *written* stat modification tests and reports success. (AC inherently covers testing).
    * **Labels:** `testing`, `battle-system`, `code-quality`
    * **Depends On:** TEST-1

* **[TEST-4] Add Integration Test for Editor Startup**
    * **Type:** Task / Testing
    * **Priority:** Medium
    * **Description:** The current unit tests mock dependencies heavily and didn't catch an `AttributeError` related to `config.monsters` not being set during application startup via the root entry point script (`pixle_art_editor.py`). Create an integration test that attempts to launch the editor application (e.g., by running the entry script or using `python -m src.editor.pixle_art_editor`) and verifies that it initializes completely without crashing, including loading necessary data like monsters.
    * **Acceptance Criteria:**
        * An integration test exists that simulates application startup for the pixel art editor.
        * The test verifies that the editor initializes without critical errors (like the `AttributeError` for `config.monsters`).
        * The test uses minimal mocking, focusing on the integration of components during startup.
        * The test passes reliably.
    * **Labels:** `testing`, `integration-test`, `code-quality`, `editor`, `startup`

* **[REFACTOR-1] Inject Dependencies into Editor Class**
    * **Type:** Refactoring / Improvement
    * **Priority:** Medium
    * **Description:** The `Editor` class in `src/editor/pixle_art_editor.py` currently relies on globally loaded monster data (`config.monsters`) set by the entry point script. This makes the class harder to test in isolation and couples it to the startup sequence. Refactor the `Editor` class to accept dependencies like the loaded monster data via its constructor (`__init__`) instead of relying on global state. Update the entry point script (`pixle_art_editor.py`) to load the data and pass it to the `Editor` instance.
    * **Acceptance Criteria:**
        * `Editor.__init__` accepts necessary data (like loaded monster list) as arguments.
        * The `Editor` class uses the passed-in data instead of relying on `config.monsters`.
        * The root entry point script (`pixle_art_editor.py`) loads the data and passes it correctly during `Editor` instantiation.
        * Existing functionality remains unchanged.
        * Unit tests for `Editor` are potentially easier to write/maintain.
    * **Labels:** `refactoring`, `architecture`, `code-quality`, `maintainability`, `editor`, `dependency-injection`, `testing`

### Low Priority

* **[POKE-15] Remove Magic Numbers from Codebase**
    * **Type:** Task / Improvement
    * **Priority:** Low
    * **Description:** Throughout the codebase (especially in UI layout calculations...) ... (previous description remains) ...The goal is to improve code readability and make future adjustments easier.
    * **Acceptance Criteria:**
        * Hardcoded numerical literals with unclear meaning are replaced by named constants.
        * Code readability is improved.
        * **Testing:** Code review confirms removal of magic numbers.
        * **Testing:** Manual regression testing confirms the changes haven't introduced functional bugs.
    * **Labels:** `code-quality`, `refactoring`, `maintainability`

* **[POKE-16] Add Robust Error Handling**
    * **Type:** Task / Improvement
    * **Priority:** Low
    * **Description:** While some basic error handling exists... (previous description remains) ...Ensure user actions like cancelling dialogs don't cause errors.
    * **Acceptance Criteria:**
        * Common file I/O errors are caught and handled gracefully.
        * Potential Pygame errors in critical sections are handled.
        * The application provides user feedback on errors where appropriate, rather than just crashing.
        * **Testing:** Manual testing involves attempting to trigger expected errors (e.g., deleting a required file, read-only permissions, cancelling save dialogs) and verifying the application handles them gracefully without crashing.
        * **Testing:** Code review confirms appropriate `try...except` blocks are added.
    * **Labels:** `code-quality`, `robustness`, `error-handling`, `ux`

* **[POKE-17] Add Missing README Screenshot and Documentation**
    * **Type:** Task
    * **Priority:** Low
    * **Description:** The project's `README.md` file currently has placeholders... (previous description remains) ...Either add relevant developer/user documentation under the "Documentation" section or remove the section if no additional documentation is planned beyond the README itself.
    * **Acceptance Criteria:**
        * The screenshot path in `README.md` points to an actual, relevant image file committed to the repository.
        * The "Documentation" section is either populated or removed.
        * The README accurately reflects the project's current state.
        * **Testing:** Manual visual inspection of the rendered `README.md` confirms the screenshot displays correctly and the documentation section is appropriately handled.
    * **Labels:** `documentation`, `readme`, `assets`

* **[POKE-18] Optimize Editor Undo/Redo Memory Usage**
    * **Type:** Improvement
    * **Priority:** Low
    * **Description:** The pixel editor's undo/redo system (`pixle_art_editor.py` `save_state`, `undo`, `redo` methods) currently works by saving complete copies... (previous description remains) ...This is likely a significant refactoring effort and should only be undertaken if memory usage proves problematic.
    * **Acceptance Criteria:**
        * (If implemented) The undo/redo system consumes measurably less memory per step, especially for large canvases.
        * Undo/Redo functionality remains correct and reliable for all editing operations.
        * **Testing:** Performance testing compares memory usage before and after optimization under heavy editing scenarios.
        * **Testing:** Manual regression testing confirms undo/redo still works correctly for all tools and actions after optimization. Relevant unit tests (if applicable to the optimization logic) are *written/updated and pass*.
    * **Labels:** `editor`, `performance`, `memory`, `optimization`, `improvement`, `refactoring`

* **[POKE-19] Adjust Creature Sprite Positioning in Battle View**
    * **Type:** Improvement
    * **Priority:** Low
    * **Description:** In the battle screen (`battle_simulator.py` `draw_battle` function), the creature sprites are drawn using coordinates calculated relative to the bottom of the screen... (previous description remains) ...Experiment with different positioning strategies or offsets for the creature sprites...
    * **Acceptance Criteria:**
        * Creature sprite positions in the battle view are visually appealing and well-integrated with other UI elements.
        * Positioning logic is clear and potentially uses constants from POKE-1 (Done).
        * **Testing:** Manual visual inspection confirms the new layout looks good across different potential sprite sizes (if applicable) and screen resolutions (if relevant).
    * **Labels:** `ui`, `ux`, `battle-system`, `visuals`, `improvement`

* **[POKE-20] Perform Balance Pass on Stat Changes and Damage**
    * **Type:** Task / Improvement
    * **Priority:** Low
    * **Description:** After implementing changes to the stat modification formula (POKE-7 - Done) and completing the type chart (POKE-5), the overall balance of combat needs review... (previous description remains) ...Adjust base stats (`monsters.json`), move powers (`moves.json`), stat change magnitudes (POKE-7 logic - Done), or type effectiveness multipliers (POKE-5 data) as needed...
    * **Acceptance Criteria:**
        * Combat feels relatively balanced â€“ no single type or strategy is overwhelmingly dominant without counterplay.
        * Stat changes have a noticeable but not game-breaking impact.
        * Battles last a reasonable number of turns on average.
        * Adjustments to data files (`monsters.json`, `moves.json`, `type_chart.json`) or formulas are documented.
        * **Testing:** Extensive playtesting by one or more individuals confirms the subjective feel of balance and identifies any remaining dominant strategies or frustrating mechanics. Playtest results are summarized.
    * **Labels:** `balancing`, `gameplay`, `battle-system`, `improvement`, `testing`
    * **Depends On:** POKE-5

---

## In Progress

* **[POKE-10] Refactor Pixel Art Editor for Modularity**
    * **Type:** Task / Improvement
    * **Priority:** Medium
    * **Description:** The main file for the pixel art editor, `pixle_art_editor.py`, has grown very large... (previous description remains) ...Refactor the `Editor` class and `handle_event` method to delegate responsibilities to these new components.
    * **Acceptance Criteria:**
        * The codebase for the pixel editor is organized into multiple smaller, well-defined modules/classes.
        * The main editor file (`pixle_art_editor.py` or its replacement) is significantly shorter and less complex.
        * Responsibilities are clearly separated (e.g., tool logic is separate from UI drawing).
        * The editor's functionality remains intact or is improved.
        * Code is more readable and maintainable.
        * **Testing:** Integration tests are *written and pass*, confirming that the refactored modules work together correctly within the main application loop.
        * **Testing:** Manual regression testing confirms all previous editor functionalities work as expected after refactoring.
    * **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`

***
##### POKE-10 Sub-Tasks:

*   **[POKE-10.4] Refactor UI Drawing (`draw_ui`)**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium
    *   **Description:** Simplify the `Editor.draw_ui` method by extracting UI drawing responsibilities. Move drawing logic for specific components (sprite editors view, background canvas view, palette, sliders, info text) into separate functions or methods, potentially within an `UIManager` or `EditorUI` class (using `ui_manager.py` or `editor_ui.py`). `Editor.draw_ui` should become primarily an orchestrator.
    *   **Acceptance Criteria:**
        *   The `Editor.draw_ui` method is significantly shorter and delegates drawing tasks.
        *   Drawing logic for distinct UI areas is encapsulated in separate functions/methods/classes.
        *   The overall UI appearance and layout remain unchanged.
        *   Relevant integration tests are **written and pass** to verify that `draw_ui` invokes sub-drawing routines correctly (may require surface mocking).
        *   Manual regression testing confirms the UI renders correctly in all modes.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `ui`, `drawing`, `testing`

*   **[POKE-10.5] Refactor State Management**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium
    *   **Description:** Centralize or better encapsulate the editor's state management. Aspects like `current_color`, `mode`, `edit_mode`, `brush_size`, `editor_zoom`, `view_offset`, undo/redo stacks, etc., could be grouped into a dedicated state object/class. Access to and modification of state should be managed through clearer interfaces.
    *   **Acceptance Criteria:**
        *   Editor state variables are grouped logically (e.g., in a dedicated state class).
        *   Access and modification of state are handled through well-defined methods or properties.
        *   The `Editor` class and other components access state through the new mechanism.
        *   All editor functionality relying on this state continues to work correctly.
        *   Relevant unit tests are **written and pass** for the state management logic, verifying state transitions and access.
        *   Manual regression testing confirms no state-related regressions.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `state-management`, `testing`

*   **[POKE-10.6] Refactor File I/O and Dialogs**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium-Low
    *   **Description:** Extract file loading/saving logic (monsters, sprites, backgrounds, reference images) and dialog interactions (including the Pygame-based dialog system and any remaining Tkinter calls) from the `Editor` class. This logic could reside in dedicated file I/O modules and a `DialogManager` (using `dialog_manager.py`).
    *   **Acceptance Criteria:**
        *   File loading/saving logic is moved out of the `Editor` class.
        *   Dialog presentation and handling logic are managed by a dedicated system (e.g., `DialogManager`).
        *   The `Editor` class calls the appropriate I/O or dialog functions.
        *   All file operations and dialog interactions work correctly.
        *   Relevant unit/integration tests are **written and pass** for file I/O functions (mocking FS access) and dialog management logic (testing state transitions/callbacks).
        *   Manual regression testing confirms all file and dialog operations work correctly.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `file-io`, `dialogs`, `ui`, `testing`
    *   **Depends On:** Potentially `POKE-9`

---

## On Hold

* **[POKE-9] Fix Tkinter Initialization Conflicts**
    * **Type:** Bug / Task
    * **Priority:** Medium
    * **Description:** The pixel art editor (`pixle_art_editor.py`) relies on Python's built-in Tkinter library for the color picker and file dialogs (e.g., loading reference images), and removing it is currently blocked ([See ToDo](#on-hold)). However, initializing Tkinter (`tk.Tk()`) *after* Pygame (`pygame.init()`) can cause crashes on some systems (especially macOS) due to conflicts between SDL and Tkinter interacting with the windowing system (e.g., `-[SDLApplication macOSVersion]: unrecognized selector`). The goal is to fix this crash by ensuring Tkinter is initialized safely before Pygame, allowing its dialogs to function correctly.
    * **Acceptance Criteria:**
        * Tkinter initialization (`tk.Tk()`) does not crash the application when called.
        * Tkinter-dependent features (Color Picker, Load Ref Img) open their respective dialogs without crashing the main application.
        * The Tkinter root window remains hidden.
        * Pygame functionality is unaffected.
        * **Testing:** Unit tests confirm `_ensure_tkinter_root` (or equivalent logic) executes without error after Pygame init. Manual testing confirms Color Picker and Load Ref Img buttons successfully open dialogs without crashes.
    * **Labels:** `ui`, `ux`, `editor`, `dependencies`, `bug`, `blocked`, `macos`

---

## Done

* **[FEAT-REFIMG-PANZOOM] Implement Reference Image Panning and Scaling**
    * **Type:** Feature
    * **Priority:** Medium
    * **Description:** Currently, the reference image loaded in the monster editor (`[FEAT-REFIMG]`) is displayed at a fixed position and scale (aspect-fit). This can make it difficult to precisely align with the pixel grid, especially if the desired tracing area is small or off-center in the original image. Implement controls to allow the user to pan (move horizontally/vertically) and scale (zoom in/out) the reference image layer independently of the main pixel grid zoom/pan. This could involve dedicated UI buttons/sliders or keyboard modifiers + mouse interactions.
    * **Acceptance Criteria:**
        * Controls (UI elements or keyboard/mouse shortcuts) are available to pan the reference image horizontally and vertically.
        * Controls are available to scale the reference image up and down.
        * Panning and scaling operations affect only the reference image layer, not the pixel grid or other UI elements.
        * The transparency setting (`[FEAT-REFIMG]`) still functions correctly with the panned/scaled image.
        * The "Clear Ref Img" function resets any panning and scaling applied.
        * The editor remains performant even with panning/scaling applied.
        * **Testing:** Manual testing confirms panning and scaling controls work intuitively and independently of the main canvas controls.
        * **Testing:** Manual testing confirms transparency and clearing functions work correctly with the transformed image.
        * **Testing:** Unit/integration tests are *written and pass* for the panning/scaling logic, verifying correct transformation calculations and state updates (potentially mocking user input/GUI elements).
    * **Labels:** `feature`, `editor`, `ui`, `ux`, `reference-image`, `input`, `enhancement`, `testing`

*   **[POKE-10.3] Refactor Core Drawing/Tool Logic**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium-High
    *   **Description:** Extract the logic for different editing tools (Draw, Erase, Fill, Paste) currently residing within the `Editor` class (e.g., in `_handle_canvas_click`, `flood_fill`, `apply_paste`) into separate classes or functions, potentially managed by a `ToolManager` using `tool_manager.py`. The `EventHandler` and `Editor` should delegate actions to the appropriate tool handler based on the current mode/tool.
    *   **Acceptance Criteria:**
        *   Logic for Draw, Erase, Fill, and Paste tools is encapsulated outside the main `Editor` class (e.g., in `tool_manager.py` or individual tool modules).
        *   The `Editor` class delegates canvas interactions (clicks/drags) to the active tool handler.
        *   The `EventHandler` correctly facilitates this delegation.
        *   All tools function correctly in both monster and background edit modes.
        *   Relevant unit/integration tests are **written and pass** for each extracted tool's logic, verifying correct pixel manipulation on a mock canvas or `SpriteEditor` frame.
        *   Manual regression testing confirms all tools work as expected.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `tools`, `event-handling`, `testing`

*   **[POKE-10.1] Extract `SpriteEditor` Class**
    *   **Type:** Refactoring Task
    *   **Priority:** High
    *   **Description:** Move the `SpriteEditor` class definition from `pixle_art_editor.py` into its own dedicated module (e.g., `sprite_editor.py`). Update `pixle_art_editor.py` to import and use the class from the new module. Ensure all functionality related to sprite data handling (loading, saving, drawing pixels, getting grid positions) remains intact.
    *   **Acceptance Criteria:**
        *   The `SpriteEditor` class is defined in a separate file (e.g., `sprite_editor.py`).
        *   `pixle_art_editor.py` imports and instantiates `SpriteEditor` from the new module.
        *   All existing sprite editing functionality works as before.
        *   Relevant unit/integration tests are **written and pass** for the `SpriteEditor` class, verifying its core methods (e.g., `load_sprite`, `save_sprite`, `draw_pixel`, `get_grid_position`) in isolation or minimal integration.
        *   Manual regression testing confirms sprite editing remains fully functional.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `sprite-editor`, `testing`

*   **[POKE-10.2] Extract `Palette` Class**
    *   **Type:** Refactoring Task
    *   **Priority:** High
    *   **Description:** Move the `Palette` class definition from `pixle_art_editor.py` into the `editor_ui.py` module. Update `pixle_art_editor.py` to import and use the class from its new location. Ensure color selection and palette scrolling functionality remain intact.
    *   **Acceptance Criteria:**
        *   The `Palette` class is defined in `editor_ui.py`.
        *   `pixle_art_editor.py` imports and instantiates `Palette` from `editor_ui.py`.
        *   Color selection using the palette works correctly.
        *   Palette scrolling functions as expected.
        *   Relevant unit/integration tests are **written and pass** for the `Palette` class, verifying its drawing and click handling logic (potentially mocking `editor.select_color`).
        *   Manual regression testing confirms palette interaction remains fully functional.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `ui`, `palette`, `testing`

* **[FEAT-REFIMG] Add Reference Image Layer to Pixel Editor**
    * **Type:** Feature
    * **Priority:** Medium (Adjust as needed)
    * **Description:** Implement functionality to load, display (with aspect-fit scaling), adjust transparency (alpha slider), and clear a background reference/tracing image within the pixel art editor's monster editing mode. The image should appear behind the interactive pixel grid.
    * **Acceptance Criteria:**
        * A "Load Ref Img" button/option allows selecting PNG/JPG/etc. files.
        * The loaded image displays behind the *active* sprite editor grid, scaled to fit while maintaining aspect ratio.
        * An alpha slider controls the reference image's transparency (0-100% or 0-255).
        * A "Clear Ref Img" button/option removes the reference image.
        * Loading, clearing, and alpha adjustment work correctly without breaking other editor functions.
        * Drawing/erasing on the main grid is unaffected by the reference image.
        * **Testing:** Manual testing confirms loading various image types, correct display/scaling, functional alpha slider, and clearing functionality.
        * **Testing:** Manual testing confirms drawing on the main canvas is not blocked.
        * **Testing:** Unit tests pass (mocking GUI interactions).
    * **Labels:** `feature`, `editor`, `ui`, `ux`, `reference-image`

* **[POKE-1] Define and Centralize Core Configuration Constants** (Type: Task, Priority: Highest)
* **[POKE-2] Refactor Sprite Creation to Use Native Resolution** (Type: Bug / Improvement, Priority: Highest)
* **[POKE-3] Refactor Editor Sprite Loading/Saving to Native Resolution** (Type: Bug / Improvement, Priority: Highest)
* **[POKE-4] Refactor Battle Sim Sprite Loading/Scaling** (Type: Bug / Improvement, Priority: Highest)
* **[POKE-5] Complete `type_chart.json` Data** (Type: Bug / Data, Priority: High)
* **[POKE-6] Implement Stat Reset Between Battles** (Type: Bug, Priority: High)
* **[POKE-7] Review and Simplify Stat Change Formula** (Type: Improvement / Bug, Priority: High)
* **[POKE-8] Fix Creature Selection Keyboard Navigation** (Type: Bug, Priority: High)
* **[POKE-21] Editor: Eraser/Fill modes deactivate immediately upon button click** (Type: Bug, Priority: High)
* **[UI-BATTLESIM-NAVHINT] Add Page Navigation Key Hints in Battle Sim Character Select**
    * **Type:** Improvement / UI
    * **Priority:** Medium
    * **Description:** In the battle simulator's character selection screen, when the user attempts to navigate left off the first item on a page or right off the last item on a page using arrow keys, display a temporary visual hint (e.g., "Press [ for Prev Page" or "Press ] for Next Page") to guide them on how to change pages.
    * **Acceptance Criteria:**
        * Pressing Left Arrow on the first selectable item displays the previous page hint (if applicable).
        * Pressing Right Arrow on the last selectable item displays the next page hint (if applicable).
        * The hint is displayed clearly on the screen (e.g., near page number or center).
        * The hint disappears after a short duration (e.g., 1-2 seconds) or on the next user input.
        * The core navigation logic remains unchanged.
        * **Testing:** Manual testing confirms hints appear correctly at page edges and disappear appropriately.
    * **Labels:** `ui`, `ux`, `battle-system`, `improvement`, `input`

* **[POKE-22] Reorganize Project Folder Structure**
    * **Type:** Task / Improvement
    * **Priority:** Medium
    * **Description:** The current project structure has most Python modules (`pixle_art_editor.py`, `tool_manager.py`, `battle_simulator.py`, etc.) directly in the root directory. This can become hard to manage as the project grows. Reorganize the codebase into a more standard structure, likely involving a main `src/` directory with subdirectories for different components (e.g., `src/editor`, `src/battle`, `src/core`, `src/ui`, `src/utils`). Update all necessary imports and ensure the application and tests still run correctly after the reorganization.
    * **Acceptance Criteria:**
        * Python source files are moved into a logical directory structure (e.g., under `src/`).
        * All internal imports within the codebase are updated to reflect the new structure.
        * The main application entry points (e.g., `pixle_art_editor.py`, `battle_simulator.py`, potentially moved/adjusted) still launch the application correctly.
        * All unit tests pass after the reorganization (adjusting imports in tests as needed).
        * Directory structure is cleaner and easier to navigate.
    * **Labels:** `refactoring`, `architecture`, `code-quality`, `maintainability`

---



================================================
File: battle_simulator.py
================================================
#!/usr/bin/env python3
import sys
import os

# Ensure the project root directory is in the Python path
project_root = os.path.dirname(os.path.abspath(__file__))
# src_path = os.path.join(project_root, 'src') # Old
if project_root not in sys.path:
    sys.path.insert(0, project_root) # Insert project root

# Import and run the main function using the full path from src
# from battle.battle_simulator import main # Old
from src.battle.battle_simulator import main # Import using src package

if __name__ == "__main__":
    main() 


================================================
File: pixle_art_editor.py
================================================
#!/usr/bin/env python3
import sys
import os

# Ensure the project root directory is in the Python path
project_root = os.path.dirname(os.path.abspath(__file__))
# src_path = os.path.join(project_root, 'src') # Old
if project_root not in sys.path:
    sys.path.insert(0, project_root) # Insert project root

# Import the Editor class and necessary setup items using full path from src
# from editor.pixle_art_editor import Editor, load_monsters, config, tk_root, monsters # Old
from src.editor.pixle_art_editor import Editor, load_monsters, config, tk_root, monsters # Import using src package

if __name__ == "__main__":
    # Replicate the necessary setup from the original __main__ block
    if not os.path.exists(config.SPRITE_DIR):
        os.makedirs(config.SPRITE_DIR)
        print(f"Created missing directory: {config.SPRITE_DIR}")
    if not os.path.exists(config.BACKGROUND_DIR):
        os.makedirs(config.BACKGROUND_DIR)
        print(f"Created missing directory: {config.BACKGROUND_DIR}")
    if not os.path.exists(config.DATA_DIR):
         os.makedirs(config.DATA_DIR)
         print(f"Created missing directory: {config.DATA_DIR}")

    # Ensure monster data is loaded appropriately (Original loads globally)
    # Check if the global `monsters` imported is already populated
    if 'monsters' not in globals() or not monsters:
        print("Reloading monster data for entry point...")
        try:
            # Re-assign to the global imported `monsters` variable is tricky.
            # Instead, load and set config.monsters as the original did.
            loaded_monsters = load_monsters()
            if not loaded_monsters:
                 print("Fatal: Could not load monster data. Exiting.")
                 sys.exit(1)
            config.monsters = loaded_monsters # Set the config attribute
        except Exception as e:
             print(f"Fatal: Could not load monster data. {e}. Exiting.")
             sys.exit(1)
    else:
        # If the imported `monsters` global *was* populated, still need to set config.monsters
        print("Using pre-loaded monster data for entry point...")
        config.monsters = monsters # Ensure config.monsters is set even if module loaded it

    # Ensure Tkinter root is initialized (original does this globally via import)
    if tk_root is None:
        print("Warning: Tkinter root failed to initialize during import.")
        # Editor might handle this internally, or we could exit:
        # sys.exit(1)

    # Instantiate and run the editor
    editor = Editor()
    editor.run() 


================================================
File: requirements-dev.txt
================================================
pytest 


================================================
File: requirements.txt
================================================
pygame>=2.0.0




================================================
File: data/monsters.json
================================================
[
    {
      "name": "Embercub",
      "type": "Fire",
      "max_hp": 100,
      "attack": 70,
      "defense": 60,
      "moves": ["Flame Burst", "Ember Strike", "Gale Force", "Power Up"]
    },
    {
      "name": "Aquafin",
      "type": "Water",
      "max_hp": 110,
      "attack": 65,
      "defense": 65,
      "moves": ["Tsunami Blast", "Water Rush", "Frost Spike", "Defend Up"]
    },
    {
      "name": "Terrapod",
      "type": "Earth",
      "max_hp": 130,
      "attack": 75,
      "defense": 80,
      "moves": ["Seismic Slam", "Stone Slide", "Steel Tail", "Break Guard"]
    },
    {
      "name": "Zephyrix",
      "type": "Wind",
      "max_hp": 90,
      "attack": 80,
      "defense": 55,
      "moves": ["Cyclone Slash", "Wind Ace", "Lightning Bolt", "Weaken"]
    },
    {
      "name": "Sparkitty",
      "type": "Electric",
      "max_hp": 95,
      "attack": 75,
      "defense": 60,
      "moves": ["Volt Charge", "Static Shock", "Chrome Claw", "Wind Cutter"]
    },
    {
      "name": "Frostbite",
      "type": "Ice",
      "max_hp": 105,
      "attack": 65,
      "defense": 70,
      "moves": ["Glacial Beam", "Frost Bite", "Water Rush", "Crystal Shard"]
    },
    {
      "name": "Leafeonix",
      "type": "Nature",
      "max_hp": 110,
      "attack": 70,
      "defense": 65,
      "moves": ["Solar Ray", "Nature Storm", "Venom Fang", "Quake Fist"]
    },
    {
      "name": "Psycat",
      "type": "Mind",
      "max_hp": 100,
      "attack": 75,
      "defense": 65,
      "moves": ["Psi Blast", "Mind Crush", "Spirit Claw", "Prism Strike"]
    },
    {
      "name": "Shadowpaw",
      "type": "Shadow",
      "max_hp": 95,
      "attack": 80,
      "defense": 55,
      "moves": ["Nightmare Strike", "Shadow Pulse", "Psychic Wave", "Venom Strike"]
    },
    {
      "name": "Lumina",
      "type": "Light",
      "max_hp": 100,
      "attack": 70,
      "defense": 70,
      "moves": ["Radiant Beam", "Aurora Blast", "Spark Blast", "Crystal Shard"]
    },
    {
      "name": "Steelex",
      "type": "Metal",
      "max_hp": 120,
      "attack": 65,
      "defense": 85,
      "moves": ["Chrome Crusher", "Metal Wing", "Stone Slide", "Lightning Bolt"]
    },
    {
      "name": "Toxifrog",
      "type": "Toxic",
      "max_hp": 95,
      "attack": 75,
      "defense": 60,
      "moves": ["Toxic Bomb", "Toxic Spray", "Water Rush", "Spirit Claw"]
    },
    {
      "name": "Decibelle",
      "type": "Sound",
      "max_hp": 90,
      "attack": 80,
      "defense": 50,
      "moves": ["Resonance Wave", "Echo Pulse", "Psychic Wave", "Wind Ace"]
    },
    {
      "name": "Crystaline",
      "type": "Crystal",
      "max_hp": 110,
      "attack": 65,
      "defense": 75,
      "moves": ["Diamond Storm", "Gem Blast", "Frost Spike", "Radiant Beam"]
    },
    {
      "name": "Novastar",
      "type": "Cosmic",
      "max_hp": 100,
      "attack": 75,
      "defense": 65,
      "moves": ["Meteor Strike", "Galactic Pulse", "Psi Blast", "Solar Flare"]
    },
    {
      "name": "Infernog",
      "type": "Fire",
      "max_hp": 115,
      "attack": 80,
      "defense": 65,
      "moves": ["Inferno Rush", "Magma Surge", "Terra Force", "Chrome Claw"]
    },
    {
      "name": "Tsunamidon",
      "type": "Water",
      "max_hp": 125,
      "attack": 70,
      "defense": 75,
      "moves": ["Tidal Crash", "Tsunami Blast", "Frost Spike", "Spirit Blast"]
    },
    {
      "name": "Boulderax",
      "type": "Earth",
      "max_hp": 140,
      "attack": 75,
      "defense": 85,
      "moves": ["Terra Force", "Quake Fist", "Steel Tail", "Venom Strike"]
    },
    {
      "name": "Tornadron",
      "type": "Wind",
      "max_hp": 95,
      "attack": 85,
      "defense": 55,
      "moves": ["Tornado Spin", "Gale Force", "Lightning Bolt", "Sound Wave"]
    },
    {
      "name": "Volteon",
      "type": "Electric",
      "max_hp": 100,
      "attack": 80,
      "defense": 60,
      "moves": ["Lightning Strike", "Spark Blast", "Metal Wing", "Wind Cutter"]
    },
    {
      "name": "Glacierox",
      "type": "Ice",
      "max_hp": 110,
      "attack": 70,
      "defense": 75,
      "moves": ["Cryo Blast", "Hail Storm", "Water Rush", "Crystal Shard"]
    },
    {
      "name": "Floravine",
      "type": "Nature",
      "max_hp": 105,
      "attack": 75,
      "defense": 70,
      "moves": ["Thorn Barrage", "Nature Dance", "Venom Fang", "Stone Slide"]
    },
    {
      "name": "Cerebron",
      "type": "Mind",
      "max_hp": 95,
      "attack": 85,
      "defense": 60,
      "moves": ["Telekinetic Throw", "Brain Shock", "Spirit Claw", "Gem Blast"]
    },
    {
      "name": "Umbragon",
      "type": "Shadow",
      "max_hp": 105,
      "attack": 85,
      "defense": 60,
      "moves": ["Void Blast", "Umbra Slash", "Psychic Wave", "Toxic Surge"]
    },
    {
      "name": "Solarix",
      "type": "Light",
      "max_hp": 100,
      "attack": 75,
      "defense": 75,
      "moves": ["Solar Flare", "Luminous Burst", "Spark Blast", "Psychic Wave"]
    },
    {
      "name": "Ironheart",
      "type": "Metal",
      "max_hp": 130,
      "attack": 70,
      "defense": 90,
      "moves": ["Steel Burst", "Chrome Claw", "Rock Pierce", "Volt Charge"]
    },
    {
      "name": "Venomusk",
      "type": "Toxic",
      "max_hp": 90,
      "attack": 80,
      "defense": 55,
      "moves": ["Toxic Surge", "Venom Fang", "Wind Cutter", "Spirit Claw"]
    },
    {
      "name": "Boombox",
      "type": "Sound",
      "max_hp": 95,
      "attack": 85,
      "defense": 55,
      "moves": ["Howl Cannon", "Screech Blast", "Spark Blast", "Psychic Wave"]
    },
    {
      "name": "Gemodite",
      "type": "Crystal",
      "max_hp": 115,
      "attack": 70,
      "defense": 80,
      "moves": ["Prism Beam", "Quartz Rush", "Frost Spike", "Radiant Beam"]
    },
    {
      "name": "Nebulox",
      "type": "Cosmic",
      "max_hp": 105,
      "attack": 80,
      "defense": 70,
      "moves": ["Nebula Burst", "Star Shower", "Psi Blast", "Intimidate"]
    }
]



================================================
File: data/moves.json
================================================
[
    {"name": "Flame Burst", "type": "Fire", "power": 95},
    {"name": "Inferno Rush", "type": "Fire", "power": 110},
    {"name": "Ember Strike", "type": "Fire", "power": 70},
    {"name": "Magma Surge", "type": "Fire", "power": 105},
    {"name": "Fire Strike", "type": "Fire", "power": 100},
    {"name": "Water Rush", "type": "Water", "power": 80},
    {"name": "Tsunami Blast", "type": "Water", "power": 120},
    {"name": "Tidal Crash", "type": "Water", "power": 105},
    {"name": "Water Stream", "type": "Water", "power": 85},
    {"name": "Whirlpool Spin", "type": "Water", "power": 90},
    {"name": "Rock Pierce", "type": "Earth", "power": 110},
    {"name": "Terra Force", "type": "Earth", "power": 100},
    {"name": "Stone Slide", "type": "Earth", "power": 95},
    {"name": "Seismic Slam", "type": "Earth", "power": 105},
    {"name": "Quake Fist", "type": "Earth", "power": 90},
    {"name": "Gale Force", "type": "Wind", "power": 95},
    {"name": "Cyclone Slash", "type": "Wind", "power": 105},
    {"name": "Wind Ace", "type": "Wind", "power": 85},
    {"name": "Tornado Spin", "type": "Wind", "power": 100},
    {"name": "Wind Cutter", "type": "Wind", "power": 90},
    {"name": "Lightning Bolt", "type": "Electric", "power": 105},
    {"name": "Volt Charge", "type": "Electric", "power": 115},
    {"name": "Spark Blast", "type": "Electric", "power": 90},
    {"name": "Lightning Strike", "type": "Electric", "power": 110},
    {"name": "Static Shock", "type": "Electric", "power": 80},
    {"name": "Frost Bite", "type": "Ice", "power": 95},
    {"name": "Glacial Beam", "type": "Ice", "power": 110},
    {"name": "Hail Storm", "type": "Ice", "power": 105},
    {"name": "Frost Spike", "type": "Ice", "power": 80},
    {"name": "Cryo Blast", "type": "Ice", "power": 100},
    {"name": "Vine Lash", "type": "Nature", "power": 85},
    {"name": "Nature Storm", "type": "Nature", "power": 100},
    {"name": "Solar Ray", "type": "Nature", "power": 120},
    {"name": "Thorn Barrage", "type": "Nature", "power": 90},
    {"name": "Nature Dance", "type": "Nature", "power": 105},
    {"name": "Psi Blast", "type": "Mind", "power": 105},
    {"name": "Telekinetic Throw", "type": "Mind", "power": 100},
    {"name": "Mind Crush", "type": "Mind", "power": 110},
    {"name": "Psychic Wave", "type": "Mind", "power": 95},
    {"name": "Brain Shock", "type": "Mind", "power": 90},
    {"name": "Spirit Claw", "type": "Shadow", "power": 100},
    {"name": "Shadow Pulse", "type": "Shadow", "power": 105},
    {"name": "Nightmare Strike", "type": "Shadow", "power": 110},
    {"name": "Void Blast", "type": "Shadow", "power": 95},
    {"name": "Umbra Slash", "type": "Shadow", "power": 90},
    {"name": "Radiant Beam", "type": "Light", "power": 105},
    {"name": "Solar Flare", "type": "Light", "power": 110},
    {"name": "Prism Strike", "type": "Light", "power": 100},
    {"name": "Luminous Burst", "type": "Light", "power": 95},
    {"name": "Aurora Blast", "type": "Light", "power": 115},
    {"name": "Steel Tail", "type": "Metal", "power": 100},
    {"name": "Metal Wing", "type": "Metal", "power": 95},
    {"name": "Chrome Claw", "type": "Metal", "power": 90},
    {"name": "Chrome Crusher", "type": "Metal", "power": 110},
    {"name": "Steel Burst", "type": "Metal", "power": 105},
    {"name": "Venom Strike", "type": "Toxic", "power": 95},
    {"name": "Toxic Spray", "type": "Toxic", "power": 85},
    {"name": "Venom Fang", "type": "Toxic", "power": 100},
    {"name": "Toxic Surge", "type": "Toxic", "power": 105},
    {"name": "Toxic Bomb", "type": "Toxic", "power": 110},
    {"name": "Sound Wave", "type": "Sound", "power": 100},
    {"name": "Screech Blast", "type": "Sound", "power": 105},
    {"name": "Echo Pulse", "type": "Sound", "power": 95},
    {"name": "Resonance Wave", "type": "Sound", "power": 110},
    {"name": "Howl Cannon", "type": "Sound", "power": 115},
    {"name": "Crystal Shard", "type": "Crystal", "power": 90},
    {"name": "Gem Blast", "type": "Crystal", "power": 105},
    {"name": "Diamond Storm", "type": "Crystal", "power": 115},
    {"name": "Prism Beam", "type": "Crystal", "power": 100},
    {"name": "Quartz Rush", "type": "Crystal", "power": 95},
    {"name": "Meteor Strike", "type": "Cosmic", "power": 115},
    {"name": "Galactic Pulse", "type": "Cosmic", "power": 110},
    {"name": "Nebula Burst", "type": "Cosmic", "power": 105},
    {"name": "Star Shower", "type": "Cosmic", "power": 100},
    {"name": "Cosmic Ray", "type": "Cosmic", "power": 95},
    {"name": "Spirit Blast", "type": "Cosmic","power": 115},
    {"name": "Power Up", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "attack", "change": 1}},
    {"name": "Defend Up", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "defense", "change": 1}},
    {"name": "Weaken", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "attack", "change": 1}},
    {"name": "Break Guard", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "defense", "change": 1}},
    {"name": "Battle Cry", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "attack", "change": 2}},
    {"name": "Steel Defense", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "defense", "change": 2}},
    {"name": "Intimidate", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "attack", "change": 2}},
    {"name": "Corrode", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "defense", "change": 2}}
]



================================================
File: data/type_chart.json
================================================
{
    "Fire": {
        "Fire": 0.5, "Water": 0.5, "Earth": 2.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 2.0, "Nature": 2.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Water": {
        "Fire": 2.0, "Water": 0.5, "Earth": 1.0, "Wind": 1.0, "Electric": 0.5, 
        "Ice": 0.5, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 1.0, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Earth": {
        "Fire": 0.5, "Water": 2.0, "Earth": 1.0, "Wind": 0.0, "Electric": 2.0, 
        "Ice": 1.0, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 2.0, "Toxic": 2.0, "Sound": 1.0, "Crystal": 0.5, "Cosmic": 1.0
    },
    "Wind": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 0.5, "Electric": 0.5, 
        "Ice": 1.0, "Nature": 2.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 0.5, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Electric": {
        "Fire": 1.0, "Water": 2.0, "Earth": 0.0, "Wind": 2.0, "Electric": 0.5, 
        "Ice": 1.0, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 1.0, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Ice": {
        "Fire": 0.5, "Water": 0.5, "Earth": 2.0, "Wind": 2.0, "Electric": 1.0, 
        "Ice": 0.5, "Nature": 2.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Nature": {
        "Fire": 0.5, "Water": 2.0, "Earth": 2.0, "Wind": 0.5, "Electric": 1.0, 
        "Ice": 0.5, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 0.5, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Mind": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 0.5, "Shadow": 0.0, "Light": 1.0, 
        "Metal": 1.0, "Toxic": 2.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Shadow": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 2.0, "Shadow": 2.0, "Light": 0.5, 
        "Metal": 1.0, "Toxic": 0.5, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Light": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 2.0, "Shadow": 2.0, "Light": 0.5, 
        "Metal": 0.5, "Toxic": 0.5, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 2.0
    },
    "Metal": {
        "Fire": 0.5, "Water": 0.5, "Earth": 1.0, "Wind": 0.5, "Electric": 0.5, 
        "Ice": 2.0, "Nature": 1.0, "Mind": 1.0, "Shadow": 1.0, "Light": 2.0, 
        "Metal": 0.5, "Toxic": 0.0, "Sound": 0.5, "Crystal": 2.0, "Cosmic": 1.0
    },
    "Toxic": {
        "Fire": 1.0, "Water": 1.0, "Earth": 0.5, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 2.0, "Mind": 1.0, "Shadow": 0.5, "Light": 2.0, 
        "Metal": 0.0, "Toxic": 0.5, "Sound": 1.0, "Crystal": 0.5, "Cosmic": 1.0
    },
    "Sound": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 0.5, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 2.0, "Toxic": 1.0, "Sound": 0.5, "Crystal": 2.0, "Cosmic": 1.0
    },
    "Crystal": {
        "Fire": 1.0, "Water": 1.0, "Earth": 2.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 0.5, "Nature": 1.0, "Mind": 0.5, "Shadow": 0.5, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 2.0, "Sound": 0.5, "Crystal": 0.5, "Cosmic": 1.0
    },
    "Cosmic": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 2.0, "Shadow": 2.0, "Light": 0.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 0.5
    }
}


================================================
File: scripts/convert_sprites.py
================================================
#!/usr/bin/env python
import pygame
import os
import shutil

# --- Configuration ---
SPRITES_DIR = "sprites"
BACKUP_DIR = "sprites_backup"
NATIVE_SPRITE_RESOLUTION = (32, 32)
# --- End Configuration ---

def convert_sprites():
    """ 
    Converts sprites in SPRITES_DIR to NATIVE_SPRITE_RESOLUTION,
    backing up originals to BACKUP_DIR first.
    """
    pygame.init() # Need Pygame for loading and scaling
    print("Starting sprite conversion...")
    
    if not os.path.isdir(SPRITES_DIR):
        print(f"Error: Sprites directory '{SPRITES_DIR}' not found. Aborting.")
        return
        
    # Create backup directory if it doesn't exist
    if not os.path.exists(BACKUP_DIR):
        try:
            os.makedirs(BACKUP_DIR)
            print(f"Created backup directory: {BACKUP_DIR}")
        except OSError as e:
            print(f"Error creating backup directory '{BACKUP_DIR}': {e}. Aborting.")
            return
    else:
         print(f"Backup directory '{BACKUP_DIR}' already exists.")

    converted_count = 0
    skipped_count = 0
    backup_count = 0
    error_count = 0

    # Iterate through files in the sprites directory
    print(f"Scanning directory: {SPRITES_DIR}")
    for filename in os.listdir(SPRITES_DIR):
        if filename.lower().endswith('.png'):
            original_path = os.path.join(SPRITES_DIR, filename)
            backup_path = os.path.join(BACKUP_DIR, filename)
            
            # 1. Backup the original file
            try:
                if not os.path.exists(backup_path):
                     shutil.copy2(original_path, backup_path) # copy2 preserves metadata
                     print(f"  Backed up: {filename} -> {BACKUP_DIR}/")
                     backup_count += 1
                # else: Skip backup if already exists in backup folder
                     
            except Exception as e:
                print(f"  Error backing up {filename}: {e}")
                error_count += 1
                continue # Skip processing this file if backup failed

            # 2. Load, Check Size, Scale if needed, and Overwrite
            try:
                img = pygame.image.load(original_path).convert_alpha()
                
                if img.get_size() != NATIVE_SPRITE_RESOLUTION:
                    print(f"  Converting: {filename} from {img.get_size()} to {NATIVE_SPRITE_RESOLUTION}")
                    scaled_img = pygame.transform.scale(img, NATIVE_SPRITE_RESOLUTION)
                    
                    # Create a new surface and blit the scaled image onto it
                    final_surface = pygame.Surface(NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
                    final_surface.fill((0,0,0,0)) # Ensure transparent background
                    final_surface.blit(scaled_img, (0,0))
                    
                    # Overwrite the original file with the new surface
                    pygame.image.save(final_surface, original_path)
                    converted_count += 1
                else:
                    # If already correct size, no need to re-save
                    skipped_count += 1
                    
            except pygame.error as e:
                print(f"  Error processing {filename}: {e}")
                error_count += 1
            except Exception as e:
                 print(f"  Unexpected error processing {filename}: {e}")
                 error_count += 1
                 
    print("\nConversion Summary:")
    print(f"  Files backed up: {backup_count}")
    print(f"  Files converted (resized): {converted_count}")
    print(f"  Files skipped (already correct size): {skipped_count}")
    print(f"  Errors encountered: {error_count}")
    print("Sprite conversion process complete.")
    pygame.quit()

if __name__ == "__main__":
    convert_sprites() 


================================================
File: scripts/create_empty_sprites.py
================================================
import pygame
import json
import os
import sys # Added sys import

# Add project root to path to allow importing from src
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import the centralized config
# import config # Original
from src.core import config # Updated import

# Initialize Pygame (required for surface creation)
pygame.init()

# Constants from config
# NATIVE_SPRITE_RESOLUTION = (32, 32) # Reverted to 32x32
# BACKGROUND_WIDTH, BACKGROUND_HEIGHT = 1200, 600

# Load monster data using config path
monsters_file = os.path.join(config.DATA_DIR, "monsters.json")
try:
    with open(monsters_file, "r") as f:
        monsters = json.load(f)
except (FileNotFoundError, json.JSONDecodeError) as e:
     print(f"Error loading {monsters_file}: {e}. Cannot proceed.")
     pygame.quit()
     exit() # Use exit() instead of sys.exit() if sys not imported

# Get the names of all monsters in the JSON file
monster_names = {monster['name'] for monster in monsters}

# Directory existence checks are now handled in config.py upon import
# # Ensure the sprites directory exists
# if not os.path.exists(config.SPRITE_DIR):
#     os.makedirs(config.SPRITE_DIR)
# 
# # Ensure the backgrounds directory exists
# if not os.path.exists(config.BACKGROUND_DIR):
#     os.makedirs(config.BACKGROUND_DIR)

# Remove sprites that don't match any monsters in monsters.json
# Use config path
print(f"Checking sprites in: {config.SPRITE_DIR}")
try:
    for filename in os.listdir(config.SPRITE_DIR):
        if filename.endswith(".png"):
            parts = filename.split('_')
            if len(parts) >= 2:
                sprite_name = parts[0]
                if sprite_name not in monster_names:
                    try:
                        file_path = os.path.join(config.SPRITE_DIR, filename)
                        os.remove(file_path)
                        print(f"Removed orphaned sprite: {filename}")
                    except OSError as e:
                        print(f"Error removing sprite {filename}: {e}")
            else:
                print(f"Skipping unusually named file in sprites folder: {filename}")
except FileNotFoundError:
     print(f"Warning: Sprite directory {config.SPRITE_DIR} not found during cleanup check.")

# Create empty transparent sprites for all monsters if they don't exist
print("Ensuring sprites exist for all monsters...")
for monster in monsters:
    for sprite_type in ['front', 'back']:
        # Use config path
        filename = os.path.join(config.SPRITE_DIR, f"{monster['name']}_{sprite_type}.png")
        if not os.path.exists(filename):
            # Create surface at native resolution from config
            surface = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
            surface.fill((*config.BLACK[:3], 0)) # Ensure it's transparent using config color
            try:
                 pygame.image.save(surface, filename)
                 print(f"Created empty sprite: {filename} at {config.NATIVE_SPRITE_RESOLUTION}")
            except pygame.error as e:
                 print(f"Error saving empty sprite {filename}: {e}")
        # else: # Don't print anything if it exists, reduces noise
        #     print(f"Sprite already exists: {filename}")

# Create an empty background if none exists
# Use config path
print(f"Checking backgrounds in: {config.BACKGROUND_DIR}")
try:
    background_files = [f for f in os.listdir(config.BACKGROUND_DIR) if f.endswith('.png')]
    if not background_files:
        print("No backgrounds found, creating a default one.")
        # Use default dimensions from config
        empty_background = pygame.Surface((config.DEFAULT_BACKGROUND_WIDTH, config.DEFAULT_BACKGROUND_HEIGHT))
        empty_background.fill(config.WHITE)  # Use config color
        
        background_filename = os.path.join(config.BACKGROUND_DIR, "default_background.png")
        try:
            pygame.image.save(empty_background, background_filename)
            print(f"Created empty background: {background_filename}")
        except pygame.error as e:
             print(f"Error saving empty background {background_filename}: {e}")
    else:
        print("Background(s) already exist.")
except FileNotFoundError:
     print(f"Warning: Background directory {config.BACKGROUND_DIR} not found.")

print("Sprite check and creation process complete.")

# Quit Pygame
pygame.quit()



================================================
File: scripts/create_test_ref_image.py
================================================
import pygame
import os

# Initialize Pygame (required for surface creation)
pygame.init()

# Define image properties
width, height = 16, 16
filename = "test_ref_image.png"
assets_dir = os.path.join("tests", "assets")
filepath = os.path.join(assets_dir, filename)

# Create the surface
surface = pygame.Surface((width, height), pygame.SRCALPHA)

# Fill with distinct colors (e.g., quadrants)
red = (255, 0, 0, 255)
green = (0, 255, 0, 255)
blue = (0, 0, 255, 255)
yellow = (255, 255, 0, 255)
half_w, half_h = width // 2, height // 2

surface.fill(red, (0, 0, half_w, half_h))
surface.fill(green, (half_w, 0, width - half_w, half_h))
surface.fill(blue, (0, half_h, half_w, height - half_h))
surface.fill(yellow, (half_w, half_h, width - half_w, height - half_h))

# Save the image
try:
    pygame.image.save(surface, filepath)
    print(f"Successfully created test image: {filepath}")
except pygame.error as e:
    print(f"Error saving test image {filepath}: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
finally:
    # Quit Pygame
    pygame.quit() 



================================================
File: sounds/.DS_Store
================================================
[Non-text file]




================================================
File: sprites/.DS_Store
================================================
[Non-text file]



================================================
File: src/__init__.py
================================================
 




================================================
File: src/battle/__init__.py
================================================
 


================================================
File: src/battle/battle_simulator.py
================================================
import pygame
import sys
import random
import os
import json
import copy

# Import the centralized config
# from ..core import config # Relative import
from src.core import config # Absolute import from src

# Initialize Pygame
pygame.init()
pygame.mixer.init()

# Screen dimensions from config
# WIDTH, HEIGHT = 1200, 600
SCREEN = pygame.display.set_mode((config.BATTLE_WIDTH, config.BATTLE_HEIGHT))
pygame.display.set_caption("Battle Simulator")

# Font from config
FONT = pygame.font.Font(config.DEFAULT_FONT, config.BATTLE_FONT_SIZE)

# Constants from config
# STAT_CHANGE_MULTIPLIER = 0.66 # Defined constant for stat changes
# NATIVE_SPRITE_RESOLUTION = (32, 32)

class Move:
    def __init__(self, name, type_, power, effect=None):
        self.name = name
        self.type = type_
        self.power = power
        self.effect = effect

class Creature:
    def __init__(self, name, type_, max_hp, attack, defense, moves, sprite):
        self.name = name
        self.type = type_
        self.max_hp = max_hp
        self.current_hp = max_hp
        self.attack = attack
        self.defense = defense
        self.moves = moves
        # Sprite is expected to be native resolution here
        # Scaling happens in draw_battle
        self.sprite = sprite

    def is_alive(self):
        return self.current_hp > 0

# Load type effectiveness chart
# Use path from config
with open(os.path.join(config.DATA_DIR, 'type_chart.json'), 'r') as f:
    type_chart = json.load(f)

def apply_stat_change(creature, stat, change):
    """Applies a stat change multiplier to a creature's specified stat."""
    if hasattr(creature, stat):
        current_stat_value = getattr(creature, stat)
        if change > 0:
            # Formula for increasing stat stage
            multiplier = 1 + config.STAT_CHANGE_MULTIPLIER / (2 ** (change - 1))
            new_stat_value = int(current_stat_value * multiplier)
        elif change < 0: # Check for negative change explicitly
            # Formula for decreasing stat stage
            # Use abs(change) for the exponent
            divider = 1 + config.STAT_CHANGE_MULTIPLIER / (2 ** (abs(change) - 1))
            # Avoid division by zero if divider somehow becomes 0 (unlikely with current formula)
            if divider == 0:
                print(f"Warning: Stat change divider became zero for stat {stat}, change {change}. Stat unchanged.")
                new_stat_value = current_stat_value
            else:
                 new_stat_value = int(current_stat_value / divider)
        else: # change == 0
            # No change if change is zero
            new_stat_value = current_stat_value

        setattr(creature, stat, new_stat_value)
        # print(f"Debug: Applied change {change} to {stat}. Old: {current_stat_value}, New: {new_stat_value}") # Optional debug print
    else:
        print(f"Warning: Stat '{stat}' not found on creature {creature.name}.")

def calculate_damage(attacker, defender, move):
    if move.power == 0:  # Stat-changing move
        if move.effect['target'] == 'self':
            apply_stat_change(attacker, move.effect['stat'], move.effect['change'])
        else:  # 'opponent'
            apply_stat_change(defender, move.effect['stat'], -move.effect['change'])
        return 0, 1  # No damage, normal effectiveness

    effectiveness = type_chart.get(move.type, {}).get(defender.type, 1)
    base_damage = (10 * attacker.attack * move.power) / (30 * defender.defense)
    damage = int((base_damage + 2) * effectiveness * random.uniform(0.85, 1.0))
    
    
    return damage, effectiveness

def create_default_sprite():
    """Creates a default sprite at native resolution."""
    sprite = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
    # Simple placeholder: gray square with border
    sprite.fill(config.GRAY_LIGHT)
    pygame.draw.rect(sprite, config.GRAY_DARK, sprite.get_rect(), 2)
    # Draw a simple question mark or symbol if desired
    # font = pygame.font.Font(config.DEFAULT_FONT, config.NATIVE_SPRITE_RESOLUTION[1] // 2)
    # text = font.render("?", True, config.BLACK)
    # text_rect = text.get_rect(center=sprite.get_rect().center)
    # sprite.blit(text, text_rect)
    return sprite

def create_sprite_from_file(filename):
    """Loads sprite at native resolution, scales down if necessary."""
    try:
        sprite = pygame.image.load(filename).convert_alpha()
        # Check if loaded image matches native resolution
        if sprite.get_size() != config.NATIVE_SPRITE_RESOLUTION:
            print(f"Warning: Loaded sprite {filename} size {sprite.get_size()} does not match native {config.NATIVE_SPRITE_RESOLUTION}. Scaling down.")
            sprite = pygame.transform.smoothscale(sprite, config.NATIVE_SPRITE_RESOLUTION)
        return sprite
    except pygame.error:
        print(f"Sprite file not found: {filename}")
        # Return a default native size sprite if file not found
        return create_default_sprite() 
    
def load_creatures():
    creatures = []
    # Use paths from config
    monsters_file = os.path.join(config.DATA_DIR, 'monsters.json')
    moves_file = os.path.join(config.DATA_DIR, 'moves.json')
    
    try:
        with open(monsters_file, 'r') as f:
            monsters_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"Error loading {monsters_file}: {e}")
        return [] # Return empty list if core data fails

    try:
        with open(moves_file, 'r') as f:
            moves_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
         print(f"Error loading {moves_file}: {e}")
         return []
    
    moves_dict = {move['name']: Move(move['name'], move['type'], move['power'], move.get('effect')) for move in moves_data}
    
    for monster in monsters_data:
        # Use path from config
        sprite_path = os.path.join(config.SPRITE_DIR, f"{monster['name']}_front.png")
        sprite = create_sprite_from_file(sprite_path)
        moves = [moves_dict.get(move_name, Move(move_name, 'Normal', 50)) for move_name in monster['moves']]
        creature = Creature(monster['name'], monster['type'], monster['max_hp'], 
                            monster['attack'], monster['defense'], moves, sprite)
        creatures.append(creature)
    
    return creatures

class Button:
    def __init__(self, rect, text, action=None):
        self.rect = pygame.Rect(rect)
        self.text = text
        self.action = action
        self.color = config.BUTTON_COLOR
        self.hover_color = config.BUTTON_HOVER_COLOR
        self.font = pygame.font.Font(config.DEFAULT_FONT, config.BUTTON_FONT_SIZE)

    def draw(self, surface):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, config.BLACK, self.rect, 2)
        text_surf = self.font.render(self.text, True, config.BLACK)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

    def is_clicked(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                return True
        return False

def draw_battle(creature1, creature2, buttons, background):
    SCREEN.blit(background, (0, 0))

    # Sprites are stored at native resolution in creature.sprite
    # Scale them ONCE here for display
    display_size = config.BATTLE_SPRITE_DISPLAY_SIZE
    
    # Use nearest-neighbor scaling (scale) for pixel art feel
    creature1_display_sprite = pygame.transform.scale(creature1.sprite, display_size)
    creature2_display_sprite = pygame.transform.scale(creature2.sprite, display_size)

    # Draw creatures higher up, adjusting position based on new display size
    SCREEN.blit(creature1_display_sprite, (100, config.BATTLE_HEIGHT - display_size[1] - 200))
    SCREEN.blit(creature2_display_sprite, (config.BATTLE_WIDTH - display_size[0] - 100, config.BATTLE_HEIGHT - display_size[1] - 200))

    # Draw HP bars
    hp_bar_width = 200
    hp_bar_height = 20
    pygame.draw.rect(SCREEN, config.BLACK, (100, 100, hp_bar_width, hp_bar_height))
    pygame.draw.rect(SCREEN, config.HP_BAR_COLOR, (100, 100, hp_bar_width * (creature1.current_hp / creature1.max_hp), hp_bar_height))
    pygame.draw.rect(SCREEN, config.BLACK, (config.BATTLE_WIDTH - 100 - hp_bar_width, 100, hp_bar_width, hp_bar_height))
    pygame.draw.rect(SCREEN, config.HP_BAR_COLOR, (config.BATTLE_WIDTH - 100 - hp_bar_width, 100, hp_bar_width * (creature2.current_hp / creature2.max_hp), hp_bar_height))

    # Draw names and HP
    name1 = FONT.render(f"{creature1.name} HP: {creature1.current_hp}/{creature1.max_hp}", True, config.BLACK)
    name2 = FONT.render(f"{creature2.name} HP: {creature2.current_hp}/{creature2.max_hp}", True, config.BLACK)
    SCREEN.blit(name1, (100, 80))
    SCREEN.blit(name2, (config.BATTLE_WIDTH - 100 - hp_bar_width, 80))

    # Draw attack and defense stats
    attack1 = FONT.render(f"ATK: {creature1.attack}", True, config.BLACK)
    defense1 = FONT.render(f"DEF: {creature1.defense}", True, config.BLACK)
    attack2 = FONT.render(f"ATK: {creature2.attack}", True, config.BLACK)
    defense2 = FONT.render(f"DEF: {creature2.defense}", True, config.BLACK)
    
    SCREEN.blit(attack1, (100, 130))
    SCREEN.blit(defense1, (100, 160))
    SCREEN.blit(attack2, (config.BATTLE_WIDTH - 100 - hp_bar_width, 130))
    SCREEN.blit(defense2, (config.BATTLE_WIDTH - 100 - hp_bar_width, 160))

    # Draw move buttons (smaller and at the bottom)
    button_width = 150
    button_height = 40
    button_spacing = 10
    total_width = len(buttons) * (button_width + button_spacing) - button_spacing
    start_x = (config.BATTLE_WIDTH - total_width) // 2
    start_y = config.BATTLE_HEIGHT - button_height - 20

    for i, button in enumerate(buttons):
        button.rect.x = start_x + i * (button_width + button_spacing)
        button.rect.y = start_y
        button.rect.width = button_width
        button.rect.height = button_height
        button.draw(SCREEN)

    pygame.display.flip()

def opponent_choose_move(creature):
    return random.choice(creature.moves)

def play_random_song():
    # Use path from config
    songs_dir = config.SONGS_DIR
    try:
        songs = [f for f in os.listdir(songs_dir) if f.endswith('.mp3') or f.endswith('.wav')]
        if songs:
            random_song = random.choice(songs)
            pygame.mixer.music.load(os.path.join(songs_dir, random_song))
            pygame.mixer.music.play(-1)  # -1 means loop indefinitely
        else:
             print(f"No songs found in {songs_dir}")
    except FileNotFoundError:
         print(f"Songs directory not found: {songs_dir}")
    except pygame.error as e:
         print(f"Error loading or playing song: {e}")

def stop_music():
    pygame.mixer.music.stop()

def load_random_background():
    # Use path from config
    backgrounds_dir = config.BACKGROUND_DIR
    try:
        backgrounds = [f for f in os.listdir(backgrounds_dir) if f.endswith('.png')]
        if backgrounds:
            background_path = os.path.join(backgrounds_dir, random.choice(backgrounds))
            background = pygame.image.load(background_path).convert_alpha()
            # Scale background to fit battle screen size
            return pygame.transform.scale(background, (config.BATTLE_WIDTH, config.BATTLE_HEIGHT))
        else:
             print(f"No backgrounds found in {backgrounds_dir}. Using default.")
    except FileNotFoundError:
         print(f"Backgrounds directory not found: {backgrounds_dir}. Using default.")
    except pygame.error as e:
         print(f"Error loading background: {e}. Using default.")
         
    # Default fallback background
    default_bg = pygame.Surface((config.BATTLE_WIDTH, config.BATTLE_HEIGHT), pygame.SRCALPHA)
    default_bg.fill((*config.BATTLE_BG_COLOR, 255))  # Ensure full opacity
    return default_bg

def battle(creature1, creature2):
    clock = pygame.time.Clock()
    running = True
    turn = 0  # 0 for player's turn, 1 for opponent's turn

    play_random_song()

    # Create buttons for player's moves
    buttons = []
    button_width = 150
    button_height = 40
    button_spacing = 10
    total_width = len(creature1.moves) * (button_width + button_spacing) - button_spacing
    start_x = (config.BATTLE_WIDTH - total_width) // 2
    start_y = config.BATTLE_HEIGHT - button_height - 20
    for i, move in enumerate(creature1.moves):
        rect = (start_x + i * (button_width + button_spacing), start_y, button_width, button_height)
        button = Button(rect, move.name, action=move)
        buttons.append(button)

    background = load_random_background()

    while running:
        # Clear the screen using config color
        SCREEN.fill(config.BATTLE_BG_COLOR)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                stop_music()
                pygame.quit()
                sys.exit()

            if turn == 0 and creature1.is_alive() and creature2.is_alive():
                for button in buttons:
                    if button.is_clicked(event):
                        move = button.action
                        damage, effectiveness = calculate_damage(creature1, creature2, move)
                        creature2.current_hp -= damage
                        if creature2.current_hp < 0:
                            creature2.current_hp = 0
                        if move.power == 0:
                            print(f"{creature1.name} used {move.name}!")
                            if move.effect['target'] == 'self':
                                print(f"{creature1.name}'s {move.effect['stat']} {'increased' if move.effect['change'] > 0 else 'decreased'}!")
                            else:
                                print(f"{creature2.name}'s {move.effect['stat']} {'decreased' if move.effect['change'] > 0 else 'increased'}!")
                        else:
                            print(f"{creature1.name} used {move.name}! It dealt {damage} damage.")
                        turn = 1  # Switch turn

        if turn == 1 and creature2.is_alive() and creature1.is_alive():
            pygame.time.delay(1000)  # Pause before opponent's move
            move = opponent_choose_move(creature2)
            damage, effectiveness = calculate_damage(creature2, creature1, move)
            creature1.current_hp -= damage
            if creature1.current_hp < 0:
                creature1.current_hp = 0
            if move.power == 0:
                print(f"{creature2.name} used {move.name}!")
                if move.effect['target'] == 'self':
                    print(f"{creature2.name}'s {move.effect['stat']} {'increased' if move.effect['change'] > 0 else 'decreased'}!")
                else:
                    print(f"{creature1.name}'s {move.effect['stat']} {'decreased' if move.effect['change'] > 0 else 'increased'}!")
            else:
                print(f"{creature2.name} used {move.name}! It dealt {damage} damage.")
            turn = 0  # Switch turn

        draw_battle(creature1, creature2, buttons, background)

        # Check for win condition
        if not creature1.is_alive() or not creature2.is_alive():
            winner = creature1.name if creature1.is_alive() else creature2.name
            message = FONT.render(f"{winner} wins!", True, config.BLACK)
            SCREEN.blit(message, (config.BATTLE_WIDTH // 2 - message.get_width() // 2, config.BATTLE_HEIGHT // 2 - message.get_height() // 2))
            pygame.display.flip()
            pygame.time.delay(3000)
            stop_music()
            return show_end_options()

        clock.tick(config.FPS) # Use FPS from config

def show_end_options():
    # Center buttons on battle screen dimensions
    new_battle_button = Button((config.BATTLE_WIDTH // 2 - 150, config.BATTLE_HEIGHT // 2 - 60, 300, 50), "New Battle")
    quit_button = Button((config.BATTLE_WIDTH // 2 - 150, config.BATTLE_HEIGHT // 2 + 10, 300, 50), "Quit")

    while True:
        SCREEN.fill(config.BATTLE_BG_COLOR)
        new_battle_button.draw(SCREEN)
        quit_button.draw(SCREEN)
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if new_battle_button.is_clicked(event):
                    return True
                if quit_button.is_clicked(event):
                    return False

def main():
    creatures = load_creatures()
    if len(creatures) < 2:
        print("Not enough creatures to battle. Please add more creature data.")
        return

    # Font for hints (can reuse FONT or create a specific one)
    hint_font = pygame.font.Font(config.DEFAULT_FONT, config.BATTLE_FONT_SIZE - 2) # Slightly smaller

    while True:
        # Constants for grid layout
        GRID_COLS = 3
        GRID_ROWS = 2
        CREATURES_PER_PAGE = GRID_COLS * GRID_ROWS
        BUTTON_WIDTH = 350
        BUTTON_HEIGHT = 80
        BUTTON_SPACING = 20
        
        # Calculate grid positions based on battle screen size
        start_x = (config.BATTLE_WIDTH - (BUTTON_WIDTH * GRID_COLS + BUTTON_SPACING * (GRID_COLS - 1))) // 2
        start_y = (config.BATTLE_HEIGHT - (BUTTON_HEIGHT * GRID_ROWS + BUTTON_SPACING * (GRID_ROWS - 1))) // 2

        # Pagination variables
        current_page = 0
        total_pages = (len(creatures) + CREATURES_PER_PAGE - 1) // CREATURES_PER_PAGE

        player_creature = None
        selected_index = 0
        selected_player_creature = None

        # Hint variables
        nav_hint_text = ""
        hint_display_start_time = 0
        HINT_DURATION_MS = 1500 # Display hint for 1.5 seconds

        while selected_player_creature is None:
            current_time = pygame.time.get_ticks() # Get current time for hint timer
            SCREEN.fill(config.BATTLE_BG_COLOR)
            title = FONT.render("Choose your monster:", True, config.BLACK)
            SCREEN.blit(title, (config.BATTLE_WIDTH // 2 - title.get_width() // 2, 20))

            # Display page number
            page_info = FONT.render(f"Page {current_page + 1}/{total_pages}", True, config.BLACK)
            SCREEN.blit(page_info, (config.BATTLE_WIDTH // 2 - page_info.get_width() // 2, config.BATTLE_HEIGHT - 30))

            # Create and draw buttons for the current page
            buttons = []
            start_creature_index = current_page * CREATURES_PER_PAGE
            end_creature_index = min(start_creature_index + CREATURES_PER_PAGE, len(creatures))
            num_buttons_on_page = end_creature_index - start_creature_index

            for i in range(num_buttons_on_page):
                creature_index = start_creature_index + i
                creature = creatures[creature_index]
                row = i // GRID_COLS
                col = i % GRID_COLS
                x = start_x + col * (BUTTON_WIDTH + BUTTON_SPACING)
                y = start_y + row * (BUTTON_HEIGHT + BUTTON_SPACING)

                button = Button((x, y, BUTTON_WIDTH, BUTTON_HEIGHT), creature.name, action=creature)
                buttons.append(button)
                button.draw(SCREEN)

                # Highlight the selected button
                if i == selected_index:
                    pygame.draw.rect(SCREEN, config.GREEN, button.rect, 3)  # Green border

                # Display the creature's sprite next to the button
                creature_sprite = pygame.transform.scale(creature.sprite, (64, 64))
                SCREEN.blit(creature_sprite, (x + 5 , y + (BUTTON_HEIGHT - 64) // 2))

            # --- Display Navigation Hint ---
            if nav_hint_text and (current_time - hint_display_start_time < HINT_DURATION_MS):
                hint_surf = hint_font.render(nav_hint_text, True, config.RED) # Use a noticeable color
                # Position hint near the bottom page number
                hint_rect = hint_surf.get_rect(center=(config.BATTLE_WIDTH // 2, config.BATTLE_HEIGHT - 60))
                SCREEN.blit(hint_surf, hint_rect)
            else:
                nav_hint_text = "" # Clear hint if time expired
            # -------------------------------

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                # Check KEYDOWN first
                elif event.type == pygame.KEYDOWN:
                    # Clear previous hint on NEW key press
                    nav_hint_text = ""
                    # num_buttons_on_page calculated above
                    if num_buttons_on_page == 0: continue

                    # --- Intra-page Navigation --- 
                    if event.key == pygame.K_DOWN:
                        # Move down, wrapping around columns
                        if selected_index + GRID_COLS < num_buttons_on_page:
                            selected_index += GRID_COLS
                        else:
                            # Wrap to top row if possible, otherwise stay in last row
                            new_index = selected_index % GRID_COLS
                            if new_index < num_buttons_on_page:
                                selected_index = new_index
                            # else: stay at current index if wrapping leads nowhere valid
                    elif event.key == pygame.K_UP:
                        # Move up, wrapping around columns
                        if selected_index - GRID_COLS >= 0:
                            selected_index -= GRID_COLS
                        else:
                            # Wrap to bottom-most item in the same column
                            col = selected_index % GRID_COLS
                            last_row_items = num_buttons_on_page % GRID_COLS
                            last_full_row_index = num_buttons_on_page - last_row_items if last_row_items != 0 else num_buttons_on_page - GRID_COLS
                            target_index = last_full_row_index + col
                            if target_index >= num_buttons_on_page:
                                # If the target in the last row doesn't exist, go to the row above it
                                target_index -= GRID_COLS 
                            if target_index >= 0:
                                selected_index = target_index
                            # else: stay at current index if wrapping leads nowhere valid
                    elif event.key == pygame.K_RIGHT:
                        # Check if already at the last item on the page
                        if selected_index == num_buttons_on_page - 1:
                            if current_page < total_pages - 1:
                                nav_hint_text = "Press ] for Next Page"
                                hint_display_start_time = current_time
                            # Don't wrap around selection index if at edge and hint shown
                        elif selected_index + 1 < num_buttons_on_page:
                            selected_index += 1
                        # else: # Original wrap logic removed, hint handles the edge case
                        #     selected_index = 0 
                    elif event.key == pygame.K_LEFT:
                        # Check if already at the first item on the page
                        if selected_index == 0:
                            if current_page > 0:
                                nav_hint_text = "Press [ for Prev Page"
                                hint_display_start_time = current_time
                            # Don't wrap around selection index if at edge and hint shown
                        elif selected_index - 1 >= 0:
                            selected_index -= 1
                        # else: # Original wrap logic removed, hint handles the edge case
                        #      selected_index = num_buttons_on_page - 1
                    
                    # --- Page Navigation (Existing) --- 
                    elif event.key == pygame.K_RIGHTBRACKET: # Use ] for next page
                        if current_page < total_pages - 1:
                            current_page += 1
                            selected_index = 0 # Reset index on page change
                    elif event.key == pygame.K_LEFTBRACKET: # Use [ for previous page
                        if current_page > 0:
                            current_page -= 1
                            selected_index = 0 # Reset index on page change

                    # --- Selection (Existing) --- 
                    elif event.key == pygame.K_RETURN or event.key == pygame.K_SPACE:
                        if 0 <= selected_index < num_buttons_on_page:
                            # Check if buttons list is valid for the index
                            if selected_index < len(buttons):
                                selected_player_creature = buttons[selected_index].action
                            else:
                                print(f"Error: selected_index {selected_index} out of range for buttons list (len {len(buttons)}).")

                # Check MOUSEBUTTONDOWN next
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    # Clear previous hint on mouse click
                    nav_hint_text = ""
                    if event.button == 1:  # Left mouse button
                        for i, button in enumerate(buttons):
                            if button.rect.collidepoint(event.pos):
                                selected_player_creature = button.action
                                break
                
                # Can add other elif event checks here if needed

            pygame.display.flip()

        # Create NEW instances for the battle to avoid deepcopy issues with Surface
        # and ensure stats/HP are reset.
        player_sprite_path = os.path.join(config.SPRITE_DIR, f"{selected_player_creature.name}_front.png")
        player_sprite = create_sprite_from_file(player_sprite_path)
        player_for_battle = Creature(
            name=selected_player_creature.name,
            type_=selected_player_creature.type,
            max_hp=selected_player_creature.max_hp,
            attack=selected_player_creature.attack,
            defense=selected_player_creature.defense,
            moves=selected_player_creature.moves, # Moves are simple objects, ok to reuse reference
            sprite=player_sprite
        )

        # Choose a random opponent that isn't the player's creature
        selected_opponent_creature = random.choice([c for c in creatures if c.name != selected_player_creature.name])
        opponent_sprite_path = os.path.join(config.SPRITE_DIR, f"{selected_opponent_creature.name}_front.png")
        opponent_sprite = create_sprite_from_file(opponent_sprite_path)
        opponent_for_battle = Creature(
            name=selected_opponent_creature.name,
            type_=selected_opponent_creature.type,
            max_hp=selected_opponent_creature.max_hp,
            attack=selected_opponent_creature.attack,
            defense=selected_opponent_creature.defense,
            moves=selected_opponent_creature.moves,
            sprite=opponent_sprite
        )
        
        # Pass the new instances to the battle function
        continue_game = battle(player_for_battle, opponent_for_battle)
        
        if not continue_game:
            break

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()



================================================
File: src/core/__init__.py
================================================
 


================================================
File: src/core/config.py
================================================
# config.py
import os

# General
FPS = 60

# Screen Dimensions
EDITOR_WIDTH = 1300
EDITOR_HEIGHT = 800
BATTLE_WIDTH = 1200
BATTLE_HEIGHT = 600

# Sprite Configuration
NATIVE_SPRITE_RESOLUTION = (32, 32)
# Factor to scale native sprites for battle display
BATTLE_SPRITE_SCALE_FACTOR = 6
BATTLE_SPRITE_DISPLAY_SIZE = (
    NATIVE_SPRITE_RESOLUTION[0] * BATTLE_SPRITE_SCALE_FACTOR,
    NATIVE_SPRITE_RESOLUTION[1] * BATTLE_SPRITE_SCALE_FACTOR
)

# Editor Specific Configuration
# Visual grid matches native width
EDITOR_GRID_SIZE = NATIVE_SPRITE_RESOLUTION[0]
# Magnification factor for display in editor
EDITOR_PIXEL_SIZE = 15
MAX_BRUSH_SIZE = 20
PALETTE_COLS = 20
PALETTE_ROWS = 8

# Background Configuration
# Default size used by editor if creating new or no background exists
DEFAULT_BACKGROUND_WIDTH = 1600
DEFAULT_BACKGROUND_HEIGHT = 800
# Note: Battle sim scales loaded backgrounds to BATTLE_WIDTH, BATTLE_HEIGHT

# Directory Paths (relative to project root)
# Use absolute paths based on this file's location for robustness
# Go up two levels: src/core -> src -> project_root
# PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Previous attempt

# Calculate paths based on this file's location
CONFIG_DIR = os.path.dirname(os.path.abspath(__file__)) # .../pokeclone/src/core
SRC_DIR = os.path.dirname(CONFIG_DIR) # .../pokeclone/src
PROJECT_ROOT = os.path.dirname(SRC_DIR) # .../pokeclone

DATA_DIR = os.path.join(PROJECT_ROOT, "data")
SPRITE_DIR = os.path.join(PROJECT_ROOT, "sprites")
BACKGROUND_DIR = os.path.join(PROJECT_ROOT, "backgrounds")
SOUNDS_DIR = os.path.join(PROJECT_ROOT, "sounds") # For POKE-13
SONGS_DIR = os.path.join(PROJECT_ROOT, "songs")

# Battle Mechanics
STAT_CHANGE_MULTIPLIER = 0.66

# UI Elements Fonts (Using None uses default pygame font)
DEFAULT_FONT = None # Pygame default
BATTLE_FONT_SIZE = 30
EDITOR_INFO_FONT_SIZE = 16
PALETTE_FONT_SIZE = 14
BUTTON_FONT_SIZE = 14

# Colors (Define common colors here)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
GRAY_LIGHT = (200, 200, 200)
GRAY_MEDIUM = (170, 170, 170)
GRAY_DARK = (100, 100, 100)

EDITOR_BG_COLOR = GRAY_LIGHT
BATTLE_BG_COLOR = WHITE
HP_BAR_COLOR = GREEN
BUTTON_COLOR = GRAY_LIGHT
BUTTON_HOVER_COLOR = GRAY_MEDIUM
SELECTION_HIGHLIGHT_COLOR = RED
SELECTION_FILL_COLOR = (*BLUE, 50) # Semi-transparent blue
GRID_COLOR_1 = GRAY_LIGHT
GRID_COLOR_2 = WHITE
TRANSPARENT_INDICATOR_COLOR = RED # For palette

# Panning Speed
PAN_SPEED_PIXELS = 20 # Pixels to shift per pan action

# Ensure data directory exists (optional nice-to-have)
if not os.path.exists(DATA_DIR):
    print(f"Warning: Data directory '{DATA_DIR}' not found. Creating it.")
    os.makedirs(DATA_DIR)

# Ensure asset directories exist
for dir_path in [SPRITE_DIR, BACKGROUND_DIR, SOUNDS_DIR, SONGS_DIR]:
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)
        print(f"Created missing directory: {dir_path}")

print("Configuration loaded.") 


================================================
File: src/core/event_handler.py
================================================
#!/usr/bin/env python3
import pygame
from pygame.locals import MOUSEBUTTONDOWN, MOUSEMOTION, MOUSEBUTTONUP, KEYDOWN, QUIT, KMOD_META, KMOD_CTRL, KMOD_ALT, K_z, K_y, K_c, K_v, K_RETURN, K_BACKSPACE, K_ESCAPE, K_UP, K_DOWN, MOUSEWHEEL
from src.core import config
# Import the Button class from editor_ui
# from ..editor.editor_ui import Button, Palette # Relative import
from src.editor.editor_ui import Button, Palette # Absolute import

# <<< Import Editor for type hint if needed, or remove if mock is sufficient
# from ..editor.pixle_art_editor import Editor # Relative import (Commented out)
# from src.editor.pixle_art_editor import Editor # Absolute import (Commented out)

class EventHandler:
    def __init__(self, editor):
        """
        Initializes the event handler.

        Args:
            editor: The main editor instance, used to access state and call methods.
        """
        self.editor = editor
        self.left_mouse_button_down = False # <<< Add flag to track mouse state
        self.ref_img_panning = False # <<< Flag for panning reference image

    def process_event(self, event):
        """
        Process a single Pygame event.
        Delegates event handling to specific methods based on event type and editor state.

        Args:
            event: The Pygame event to process.

        Returns:
            bool: True if the event was handled, False otherwise. 
                  Returning False for QUIT allows the main loop to catch it.
        """
        # Handle dialog events first if a dialog is active
        if self.editor.dialog_mode:
            return self._handle_dialog_event(event)

        # --- Normal Event Handling (No Dialog Active) ---
        if event.type == QUIT:
             return False # Let main loop handle closing

        if event.type == MOUSEBUTTONDOWN:
            # Store the fact that the mouse button is down
            # Needed for handle_drag logic
            self.left_mouse_button_down = (event.button == 1) 
            return self._handle_mouse_button_down(event)
        elif event.type == MOUSEMOTION:
            return self._handle_mouse_motion(event)
        elif event.type == MOUSEBUTTONUP:
            if event.button == 1:
                self.left_mouse_button_down = False # Reset flag
            return self._handle_mouse_button_up(event)
        elif event.type == KEYDOWN:
            return self._handle_key_down(event)
        
        # --- Handle Mouse Wheel for Zoom/Scroll ---
        elif event.type == pygame.MOUSEWHEEL:
             # --- Reference Image Scaling --- 
             mods = pygame.key.get_mods()
             if self.editor.edit_mode == 'monster' and (mods & KMOD_ALT):
                 active_sprite_editor = self.editor.sprites.get(self.editor.current_sprite)
                 if active_sprite_editor:
                     editor_rect = pygame.Rect(active_sprite_editor.position, 
                                                (active_sprite_editor.display_width, active_sprite_editor.display_height))
                     if editor_rect.collidepoint(pygame.mouse.get_pos()): # Check if mouse is over editor
                         scale_factor = 1.1 if event.y > 0 else (1 / 1.1)
                         self.editor.ref_img_scale *= scale_factor
                         # Clamp scale
                         self.editor.ref_img_scale = max(0.1, min(self.editor.ref_img_scale, 10.0))
                         print(f"Reference image scale: {self.editor.ref_img_scale:.2f}")
                         self.editor._scale_reference_image() # Rescale after zoom
                         return True # Consumed event
             # --- End Reference Image Scaling ---
             
             # TODO: Implement background zoom/scroll or palette scroll here if needed
             pass # Pass if not handled by ref img scaling

        return False # Event not handled by this function

    def _handle_dialog_event(self, event):
        """Handles events when a dialog is active."""
        editor = self.editor # Alias for convenience
        # print(f"DEBUG: Handling dialog event: {event.type}, Mode: {editor.dialog_mode}") # REMOVED

        # Handle clicks on dialog buttons
        if event.type == MOUSEBUTTONDOWN and event.button == 1:
             # print(f"DEBUG: Dialog MOUSEBUTTONDOWN at {event.pos}") # REMOVED
             # print(f"DEBUG: Checking editor.dialog_options (len={len(editor.dialog_options)}): {editor.dialog_options}") # REMOVED
             for i, option in enumerate(editor.dialog_options):
                  # Check if it's a button AND it was clicked
                  if isinstance(option, Button): # Use imported Button
                       # print(f"DEBUG: Checking Button {i}: '{option.text}' at {option.rect}") # REMOVED
                       if option.rect.collidepoint(event.pos): # Use imported Button
                           # print(f"DEBUG: Collision DETECTED with Button '{option.text}'!") # REMOVED
                           # Use button's stored value to call the dialog choice handler
                           if hasattr(option, 'value') and option.value is not None:
                                # print(f"DEBUG: Button has value '{option.value}', calling _handle_dialog_choice...") # REMOVED
                                editor._handle_dialog_choice(option.value)
                                return True # Handled by dialog button click
                           # Handle direct action buttons if necessary
                           elif hasattr(option, 'action') and callable(option.action):
                                # print(f"DEBUG: Button has action '{option.action.__name__}', calling action...") # REMOVED
                                option.action()
                                return True
             # TODO: Handle clicks/drags within specific dialog types (color picker, file list scroll)
            # e.g., if editor.dialog_mode == 'color_picker': handle_color_picker_click/drag
            # e.g., if editor.dialog_mode == 'load_bg': handle_file_list_click/scroll

        # Handle KEYDOWN specifically for dialogs that need it
        elif event.type == KEYDOWN:
             if editor.dialog_mode == 'input_text' and editor.dialog_input_active:
                  if event.key == K_RETURN:
                       # Find the 'Save' or confirm button's value/action if possible,
                       # otherwise assume current input text is the value
                       confirm_value = editor.dialog_input_text
                       for btn in editor.dialog_options:
                           if isinstance(btn, Button) and btn.text.lower() == "save": # Use imported Button
                               confirm_value = btn.value if hasattr(btn, 'value') else confirm_value
                               break
                       editor._handle_dialog_choice(confirm_value)
                  elif event.key == K_BACKSPACE:
                       editor.dialog_input_text = editor.dialog_input_text[:-1]
                  elif event.key == K_ESCAPE:
                       # Find the 'Cancel' button's value/action if possible
                       cancel_value = None
                       for btn in editor.dialog_options:
                           if isinstance(btn, Button) and btn.text.lower() == "cancel": # Use imported Button
                               cancel_value = btn.value if hasattr(btn, 'value') else None
                               break
                       editor._handle_dialog_choice(cancel_value)
                  elif len(editor.dialog_input_text) < editor.dialog_input_max_length:
                       # Filter unwanted characters? For now, allow most printable chars
                       if event.unicode.isprintable():
                            editor.dialog_input_text += event.unicode
                  return True # Consume key event for text input

             # Handle key navigation for file list dialog
             elif editor.dialog_mode == 'load_bg':
                  if event.key == K_UP:
                       if editor.dialog_selected_file_index > 0:
                            editor.dialog_selected_file_index -= 1
                       # TODO: Add scroll logic if file list exceeds display area
                       return True
                  elif event.key == K_DOWN:
                       if editor.dialog_selected_file_index < len(editor.dialog_file_list) - 1:
                            editor.dialog_selected_file_index += 1
                       # TODO: Add scroll logic
                       return True
                  elif event.key == K_RETURN:
                       if 0 <= editor.dialog_selected_file_index < len(editor.dialog_file_list):
                           # Find the 'Load' button's value/action if possible,
                           # otherwise assume selected file index implies load action
                           load_value = editor.dialog_file_list[editor.dialog_selected_file_index]
                           for btn in editor.dialog_options:
                               if isinstance(btn, Button) and btn.text.lower() == "load": # Use imported Button
                                    load_value = btn.value if hasattr(btn, 'value') else load_value
                                    break
                           editor._handle_dialog_choice(load_value)
                       return True
                  elif event.key == K_ESCAPE:
                       # Find the 'Cancel' button's value/action
                       cancel_value = None
                       for btn in editor.dialog_options:
                           if isinstance(btn, Button) and btn.text.lower() == "cancel": # Use imported Button
                               cancel_value = btn.value if hasattr(btn, 'value') else None
                               break
                       editor._handle_dialog_choice(cancel_value)
                       return True

             # Generic Escape to cancel other simple choice dialogs
             elif event.key == K_ESCAPE:
                 if editor.dialog_mode in ['choose_edit_mode', 'choose_bg_action']:
                      editor._handle_dialog_choice(None) # Assuming None means cancel
                 return True

        return True # Consume other unhandled events while dialog is open

    def _handle_mouse_button_down(self, event):
        """Handles mouse button down events when no dialog is active."""
        editor = self.editor

        if event.button == 1: # Left click
            # 0a. Check Subject Alpha Slider Click/Drag Start
            if self.editor.edit_mode == 'monster' and self.editor.subj_alpha_slider_rect.collidepoint(event.pos):
                self.editor.adjusting_subject_alpha = True
                self._update_subject_alpha_slider(event.pos) # Update alpha and knob position
                return True # Event handled
                
            # 0b. Check Reference Alpha Slider Click/Drag Start
            if self.editor.ref_alpha_slider_rect.collidepoint(event.pos):
                self.editor.adjusting_alpha = True
                self._update_alpha_slider(event.pos) # Update alpha and knob position
                return True # Event handled

            # 0c. Check Reference Image Pan Start (Alt + Click on active editor)
            mods = pygame.key.get_mods()
            if self.editor.edit_mode == 'monster' and (mods & KMOD_ALT):
                active_sprite_editor = self.editor.sprites.get(self.editor.current_sprite)
                if active_sprite_editor:
                    editor_rect = pygame.Rect(active_sprite_editor.position, 
                                               (active_sprite_editor.display_width, active_sprite_editor.display_height))
                    if editor_rect.collidepoint(event.pos):
                        self.ref_img_panning = True
                        # Maybe change cursor?
                        # pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_SIZEALL)
                        print("Reference image panning started.")
                        return True # Event handled by starting ref image pan

            # 1. Check UI Buttons
            for button in editor.buttons:
                if button.is_clicked(event):
                    if button.action:
                        button.action() # Call the button's assigned method
                    return True # <<< CRITICAL: Ensure button click consumes the event

            # 2. Check Palette Click
            palette_rect = pygame.Rect(editor.palette.position[0], editor.palette.position[1],
                                     config.PALETTE_COLS * (editor.palette.block_size + editor.palette.padding),
                                     config.PALETTE_ROWS * (editor.palette.block_size + editor.palette.padding) + 40) # Include scroll area roughly
            if palette_rect.collidepoint(event.pos):
                editor.palette.handle_click(event.pos, editor) # <<< Pass editor instance
                return True # <<< CRITICAL: Ensure palette click consumes the event

            # 3. Check Canvas Click (Sprite or Background)
            clicked_sprite_editor = editor._get_sprite_editor_at_pos(event.pos)
            is_bg_click = editor.edit_mode == 'background' and editor.canvas_rect.collidepoint(event.pos)

            if clicked_sprite_editor or is_bg_click:
                # Save state BEFORE the action starts (important for undo)
                # Only save state if not already dragging a selection
                if not (editor.mode == 'select' and editor.selection.selecting):
                     editor.save_state()

                if editor.mode == 'select':
                    if clicked_sprite_editor:
                         # If in select mode, a click on a sprite canvas ALWAYS starts the process.
                         # The SelectionTool.start method should handle the state.
                         editor.selection.start(event.pos, clicked_sprite_editor)
                         # Set selecting flag AFTER calling start
                         editor.selection.selecting = True 
                else: # Draw, erase, fill, paste modes
                    editor.tool_manager.handle_click(event.pos) # <<< Use ToolManager
                return True # Event handled by canvas click
            else:
                 # Click outside canvas areas
                 if editor.mode == 'select' and editor.selection.selecting:
                      # If currently selecting, clicking outside cancels it
                      print("Selection cancelled (clicked outside grid).")
                      editor.selection.selecting = False
                      editor.selection.active = False
                 # Reset drawing flag if click was outside canvas
                 # editor.drawing = False # REMOVED
                 return True # Consume click outside relevant areas

        elif event.button == 4: # Mouse wheel up
             # Handle palette scroll if mouse is over it
             palette_rect = pygame.Rect(editor.palette.position[0], editor.palette.position[1],
                                         config.PALETTE_COLS * (editor.palette.block_size + editor.palette.padding) + 30, # Rough width including scroll
                                         config.PALETTE_ROWS * (editor.palette.block_size + editor.palette.padding))
             if palette_rect.collidepoint(event.pos):
                 editor.palette.scroll_offset = max(0, editor.palette.scroll_offset - 1)
                 return True
             # TODO: Add zoom or other scroll behavior here if needed

        elif event.button == 5: # Mouse wheel down
              # Handle palette scroll if mouse is over it
             palette_rect = pygame.Rect(editor.palette.position[0], editor.palette.position[1],
                                         config.PALETTE_COLS * (editor.palette.block_size + editor.palette.padding) + 30, # Rough width
                                         config.PALETTE_ROWS * (editor.palette.block_size + editor.palette.padding))
             if palette_rect.collidepoint(event.pos):
                 editor.palette.scroll_offset = min(editor.palette.total_pages - 1, editor.palette.scroll_offset + 1)
                 return True
             # TODO: Add zoom or other scroll behavior here if needed

        # Handle Middle Mouse Button for Panning Start
        elif event.button == 2: # Middle mouse button
            if self.editor.edit_mode == 'background' and self.editor.canvas_rect and self.editor.canvas_rect.collidepoint(event.pos):
                self.editor.panning = True
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND) # Change cursor to hand
                return True # Panning started
                
        # Handle Right-click, Middle-click, etc. if needed
        # elif event.button == 3: # Right click
        #     # Example: Eyedropper tool?
        #     sprite_at_pos = editor._get_sprite_editor_at_pos(event.pos)
        #     if sprite_at_pos:
        #         grid_pos = sprite_at_pos.get_grid_position(event.pos)
        #         if grid_pos:
        #             color = sprite_at_pos.get_pixel_color(grid_pos)
        #             if color: editor.select_color(color)
        #             return True
        #     pass

        return False # Event not handled

    def _handle_mouse_motion(self, event):
        """Handles mouse motion events when no dialog is active."""
        editor = self.editor

        # Handle Subject Alpha Slider Drag
        if editor.adjusting_subject_alpha and (event.buttons[0] == 1):
            self._update_subject_alpha_slider(event.pos)
            return True

        # Handle Reference Image Panning Drag (Alt + Drag)
        if self.ref_img_panning and (event.buttons[0] == 1):
            mods = pygame.key.get_mods() # Re-check mods in case Alt released mid-drag? Maybe not needed if start requires Alt.
            if mods & KMOD_ALT: # Continue panning only if Alt is still held?
                 dx, dy = event.rel
                 self.editor.ref_img_offset.x += dx
                 self.editor.ref_img_offset.y += dy
                 self.editor._scale_reference_image() # Rescale needed after offset change
                 return True # Consumed event
            else: # If Alt released, stop panning
                 self.ref_img_panning = False
                 # Maybe change cursor back?
                 # pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                 print("Reference image panning stopped (Alt released).")
                 return True

        # Handle Panning Drag
        if editor.panning and (event.buttons[1] == 1): # Check if middle button is held
            dx, dy = event.rel # Get relative motion
            editor.view_offset_x -= dx # Adjust view offset (inverse of mouse motion)
            editor.view_offset_y -= dy
            
            # Clamp view offset (ensure this logic matches draw_ui clamping)
            if editor.current_background:
                scaled_width = int(editor.current_background.get_width() * editor.editor_zoom)
                scaled_height = int(editor.current_background.get_height() * editor.editor_zoom)
                max_offset_x = max(0, scaled_width - editor.canvas_rect.width)
                max_offset_y = max(0, scaled_height - editor.canvas_rect.height)
                editor.view_offset_x = max(0, min(editor.view_offset_x, max_offset_x))
                editor.view_offset_y = max(0, min(editor.view_offset_y, max_offset_y))
            return True # Panning motion handled

        # Handle Reference alpha slider drag
        if editor.adjusting_alpha and (event.buttons[0] == 1): # Check if left button is held
            self._update_alpha_slider(event.pos) # Update alpha and knob position
            return True # Event handled

        # Handle drawing/erase/tool drag via ToolManager
        # Check if left button is down (using our flag) AND not in select mode
        if self.left_mouse_button_down and editor.mode != 'select':
             editor.tool_manager.handle_drag(event.pos) # <<< Use ToolManager
             return True

        # Handle selection drag
        elif editor.mode == 'select' and editor.selection.selecting and (event.buttons[0] == 1):
             clicked_sprite_editor = editor._get_sprite_editor_at_pos(event.pos)
             # Update selection only if dragging over the *same* editor? Or any? For now, any.
             if clicked_sprite_editor:
                  editor.selection.update(event.pos, clicked_sprite_editor) # Pass sprite editor
             # Allow drag outside the initial sprite editor? Yes for now.
             # Might need refinement if dragging over the *other* sprite editor.
             return True
        
        # TODO: Handle panning drag (e.g., middle mouse button held)

        return False # Event not handled

    def _handle_mouse_button_up(self, event):
        """Handles mouse button up events when no dialog is active."""
        editor = self.editor

        if event.button == 1: # Left button release
             # Stop adjusting subject alpha slider
            if editor.adjusting_subject_alpha:
                editor.adjusting_subject_alpha = False
                return True # Event handled
                
             # Stop adjusting reference alpha slider
            if editor.adjusting_alpha:
                editor.adjusting_alpha = False
                return True # Event handled

            # Handle drawing end - NO LONGER NEEDED HERE
            # if editor.drawing:
            #     editor.drawing = False
            #     return True

            # Handle selection end
            elif editor.mode == 'select' and editor.selection.selecting:
                # End selection regardless of where mouse is released? Or only if over canvas?
                # Current logic uses position from event. Let's assume release anywhere ends it.
                clicked_sprite_editor = editor._get_sprite_editor_at_pos(event.pos)
                # Need the sprite editor instance where selection *started* potentially,
                # but for now, just use the current one if available. If released outside,
                # end_selection might use the last known end_pos. This needs selection_manager logic check.
                # For now, assume end_selection handles release position correctly.
                # We might need to store which editor the selection started on if it matters.
                editor.selection.end_selection(event.pos, clicked_sprite_editor if clicked_sprite_editor else editor.sprites[editor.current_sprite]) # Pass editor instance, fallback to current if released outside
                editor.selection.selecting = False # Turn off selecting flag
                # Keep editor.selection.active True
                return True

            # Stop Reference Image Panning
            elif self.ref_img_panning:
                 self.ref_img_panning = False
                 # Maybe change cursor back?
                 # pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                 print("Reference image panning stopped.")
                 return True

        elif event.button == 2: # Middle button release
            if editor.panning:
                editor.panning = False
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW) # Change cursor back
                return True # Panning stopped

        return False # Event not handled

    def _handle_key_down(self, event):
        """Handles key down events when no dialog is active."""
        editor = self.editor

        # Modifier keys (Ctrl/Cmd) for shortcuts
        modifier_pressed = event.mod & KMOD_META or event.mod & KMOD_CTRL

        if modifier_pressed:
            if event.key == K_z:
                editor.undo()
                return True
            if event.key == K_y:
                editor.redo()
                return True
            if event.key == K_c and editor.mode == 'select':
                 editor.copy_selection()
                 return True
            if event.key == K_v:
                 editor.paste_selection()
                 return True
            # Add other Ctrl/Cmd shortcuts (e.g., Save - K_s?)
            # if event.key == K_s:
            #     editor.save_current() # Assuming a generic save method exists
            #     return True

        # Non-modifier key actions
        else:
            # --- Background Panning with Arrow Keys --- 
            if editor.edit_mode == 'background':
                panned = False
                if event.key == pygame.K_LEFT:
                    editor.view_offset_x -= config.PAN_SPEED_PIXELS
                    panned = True
                elif event.key == pygame.K_RIGHT:
                    editor.view_offset_x += config.PAN_SPEED_PIXELS
                    panned = True
                elif event.key == pygame.K_UP:
                    editor.view_offset_y -= config.PAN_SPEED_PIXELS
                    panned = True
                elif event.key == pygame.K_DOWN:
                    editor.view_offset_y += config.PAN_SPEED_PIXELS
                    panned = True
                
                if panned:
                    # Clamp view offset after panning
                    if editor.current_background:
                        scaled_width = int(editor.current_background.get_width() * editor.editor_zoom)
                        scaled_height = int(editor.current_background.get_height() * editor.editor_zoom)
                        max_offset_x = max(0, scaled_width - editor.canvas_rect.width)
                        max_offset_y = max(0, scaled_height - editor.canvas_rect.height)
                        editor.view_offset_x = max(0, min(editor.view_offset_x, max_offset_x))
                        editor.view_offset_y = max(0, min(editor.view_offset_y, max_offset_y))
                    return True # Arrow key handled for panning
            # --- End Background Panning ---
            
            # Add other non-modifier key actions here (e.g., tool switching)
            # if event.key == K_d: editor.set_tool('draw')
            # ...
            pass

        return False # Event not handled

    def _update_alpha_slider(self, mouse_pos):
        """Helper to update REFERENCE alpha value and knob position based on mouse click/drag."""
        editor = self.editor
        # Calculate relative x position within the slider track
        click_x_relative = mouse_pos[0] - editor.ref_alpha_slider_rect.x
        # Clamp relative position to bounds [0, slider_width]
        click_x_relative = max(0, min(editor.ref_alpha_slider_rect.width, click_x_relative))

        # Calculate effective width for ratio (slider width minus knob width for better feel?)
        # Or just use full slider width? Let's try full width first.
        slider_width_effective = editor.ref_alpha_slider_rect.width
        if slider_width_effective <= 0: slider_width_effective = 1 # Avoid division by zero

        # Calculate new alpha value (0-255)
        new_alpha = (click_x_relative / slider_width_effective) * 255
        editor.set_reference_alpha(new_alpha) # This clamps and applies alpha

        # Update knob position visually based on the relative click/drag position
        # Adjust the knob's center based on the relative click pos within the slider track
        # Ensure knob stays within bounds
        knob_center_x = editor.ref_alpha_slider_rect.x + click_x_relative
        editor.ref_alpha_knob_rect.centerx = knob_center_x
        # Clamp knob position fully within slider track bounds
        editor.ref_alpha_knob_rect.left = max(editor.ref_alpha_slider_rect.left, editor.ref_alpha_knob_rect.left)
        editor.ref_alpha_knob_rect.right = min(editor.ref_alpha_slider_rect.right, editor.ref_alpha_knob_rect.right)

    def _update_subject_alpha_slider(self, mouse_pos):
        """Helper to update SUBJECT alpha value and knob position based on mouse click/drag."""
        editor = self.editor
        # Calculate relative x position within the subject slider track
        click_x_relative = mouse_pos[0] - editor.subj_alpha_slider_rect.x
        click_x_relative = max(0, min(editor.subj_alpha_slider_rect.width, click_x_relative))

        slider_width_effective = editor.subj_alpha_slider_rect.width
        if slider_width_effective <= 0: slider_width_effective = 1

        # Calculate new alpha value (0-255)
        new_alpha = (click_x_relative / slider_width_effective) * 255
        editor.set_subject_alpha(new_alpha) # This clamps, updates alpha, and moves knob

# Note: This EventHandler assumes it receives the main Editor instance.
# Dependencies like editor.Button need to be handled (either import Button here or access via editor.Button).
# Methods like editor._handle_canvas_click, editor._get_sprite_editor_at_pos, editor.save_state, etc.,
# are called directly on the editor instance for now. These might be further refactored later.





================================================
File: src/editor/__init__.py
================================================
 


================================================
File: src/editor/dialog_manager.py
================================================



================================================
File: src/editor/editor_ui.py
================================================
import pygame
# from ..core import config # Relative import
from src.core import config # Absolute import
import colorsys # <<< Add import for palette generation

class Button:
    """
    A simple button class for the pixel art editor.

    This class represents a clickable button with a text label. It handles drawing
    the button on a surface, checking for mouse clicks, and executing an associated
    action when clicked.

    Attributes:
        rect (pygame.Rect): The rectangle defining the button's position and size.
        text (str): The text label displayed on the button.
        action (callable): The function to be executed when the button is clicked.
        color (tuple): The background color of the button (R, G, B).
        hover_color (tuple): The background color of the button when the mouse is hovering over it (R, G, B).
        font (pygame.font.Font): The font used for rendering the button text.

    Methods:
        draw(surface: pygame.Surface) -> None
        is_clicked(event: pygame.event.Event) -> bool
    """

    def __init__(self, rect, text, action=None, value=None):
        """
        Initialize a new Button instance.

        Args:
            rect (tuple): A tuple representing the button's rectangle (x, y, width, height).
            text (str): The text label to display on the button.
            action (callable, optional): The function to be executed when the button is clicked.
            value (any, optional): The value to be stored with the button.
        """
        self.rect = pygame.Rect(rect)
        self.text = text
        self.action = action
        self.value = value
        self.color = config.BUTTON_COLOR
        self.hover_color = config.BUTTON_HOVER_COLOR
        self.font = pygame.font.Font(config.DEFAULT_FONT, config.BUTTON_FONT_SIZE)

    def draw(self, surface):
        """
        Draw the button on a given surface.

        Args:
            surface (pygame.Surface): The surface on which to draw the button.
        """
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, config.BLACK, self.rect, 2)
        text_surf = self.font.render(self.text, True, config.BLACK)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

    def is_clicked(self, event):
        """
        Check if the button was clicked based on a mouse event.

        Args:
            event (pygame.event.Event): The mouse event to check for a click.

        Returns:
            bool: True if the button was clicked, False otherwise.
        """
        return event.type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(event.pos)

# Add other UI classes here later (Palette, SpriteEditor visualization part, etc.)

# --- Palette Generation --- 
def generate_palette():
    """
    Generate an enhanced color palette for the pixel art editor.

    This function creates a wide range of colors, including a variety of hues,
    saturations, and values, as well as grayscale colors. The resulting palette
    is used for painting and color selection in the editor.

    Returns:
        list: A list of RGBA color tuples representing the generated palette.
    """
    # Use constants from config if available, otherwise use defaults
    palette_hues_step = getattr(config, 'PALETTE_HUES_STEP', 30)
    palette_saturations = getattr(config, 'PALETTE_SATURATIONS', [50, 100])
    palette_values = getattr(config, 'PALETTE_VALUES', [50, 100])
    palette_grayscale_steps = getattr(config, 'PALETTE_GRAYSCALE_STEPS', 10)

    _PALETTE = [(0, 0, 0, 255)]  # Start with black
    # Generate a wide range of colors
    for h in range(0, 360, palette_hues_step):
        for s in palette_saturations:
            for v in palette_values:
                r, g, b = colorsys.hsv_to_rgb(h/360, s/100, v/100)
                _PALETTE.append((int(r*255), int(g*255), int(b*255), 255))
    # Add grayscale
    # Ensure at least 2 steps for division
    grayscale_denom = max(1, palette_grayscale_steps -1) 
    for i in range(palette_grayscale_steps):
        gray = int(255 * i / grayscale_denom)
        _PALETTE.append((gray, gray, gray, 255))
    return _PALETTE

PALETTE = generate_palette()

# --- Palette Class --- 
class Palette:
    """
    A scrollable color palette for the pixel art editor.

    This class represents a scrollable color palette that allows users to select
    colors for painting and drawing in the editor. It supports scrolling through
    a large number of colors and provides a visual representation of each color.

    Attributes:
        position (tuple): The (x, y) position of the palette on the screen.
        block_size (int): The size of each color block in the palette.
        padding (int): The padding between color blocks.
        gap (int): The gap between the palette and other UI elements.
        font (pygame.font.Font): The font used for rendering the palette label.
        scroll_offset (int): The current scroll offset within the palette.
        colors_per_page (int): The number of colors displayed per page.
        total_pages (int): The total number of pages in the palette.

    Methods:
        draw(surface: pygame.Surface, current_color: tuple) -> None
        handle_click(pos: tuple, editor: Editor) -> None # Need editor reference for select_color
    """

    def __init__(self, position):
        """
        Initialize a new Palette instance.

        Args:
            position (tuple): The (x, y) position of the palette on the screen.
        """
        self.position = position  # (x, y) starting position on screen
        # Use constants from config for layout
        self.block_size = getattr(config, 'PALETTE_BLOCK_SIZE', 15)
        self.padding = getattr(config, 'PALETTE_PADDING', 2)
        self.gap = getattr(config, 'PALETTE_GAP', 5)
        self.font = pygame.font.Font(config.DEFAULT_FONT, config.PALETTE_FONT_SIZE)
        self.scroll_offset = 0
        self.colors_per_page = config.PALETTE_COLS * config.PALETTE_ROWS
        # Reference the PALETTE defined in this module
        self.total_pages = (len(PALETTE) + self.colors_per_page - 1) // self.colors_per_page 

    def draw(self, surface, current_color):
        """
        Draw the palette on a given surface.

        Args:
            surface (pygame.Surface): The surface on which to draw the palette.
            current_color (tuple): The currently selected color in the editor for highlighting.
        """
        x0, y0 = self.position
        current_page = self.scroll_offset
        start_index = current_page * self.colors_per_page
        end_index = start_index + self.colors_per_page
        # Reference the PALETTE defined in this module
        visible_palette = PALETTE[start_index:end_index] 

        for index, color in enumerate(visible_palette):
            col = index % config.PALETTE_COLS
            row = index // config.PALETTE_COLS
            rect = pygame.Rect(
                x0 + col * (self.block_size + self.padding),
                y0 + row * (self.block_size + self.padding),
                self.block_size,
                self.block_size
            )

            if color[3] == 0:  # Transparent color
                # Use constants from config for colors
                gray_light = getattr(config, 'GRAY_LIGHT', (211, 211, 211))
                indicator_color = getattr(config, 'TRANSPARENT_INDICATOR_COLOR', (255, 0, 0))
                pygame.draw.rect(surface, gray_light, rect)
                pygame.draw.line(surface, indicator_color, rect.topleft, rect.bottomright, 2)
                pygame.draw.line(surface, indicator_color, rect.topright, rect.bottomleft, 2)
            else:
                pygame.draw.rect(surface, color[:3], rect)

            # Use the passed current_color for comparison
            if color == current_color:
                 highlight_color = getattr(config, 'SELECTION_HIGHLIGHT_COLOR', (0, 255, 0))
                 pygame.draw.rect(surface, highlight_color, rect.inflate(4, 4), 2)

        # Palette label
        label_color = getattr(config, 'BLACK', (0,0,0))
        label = self.font.render("Palette", True, label_color)
        surface.blit(label, (x0, y0 - 30))

        # Scroll indicators
        if self.total_pages > 1:
            up_arrow = self.font.render("â†‘", True, label_color)
            down_arrow = self.font.render("â†“", True, label_color)
            surface.blit(up_arrow, (x0 + config.PALETTE_COLS * (self.block_size + self.padding) + 10, y0))
            surface.blit(down_arrow, (x0 + config.PALETTE_COLS * (self.block_size + self.padding) + 10, y0 + config.PALETTE_ROWS * (self.block_size + self.padding) - 20))

    def handle_click(self, pos, editor):
        """
        Handle a mouse click event on the palette.

        This method checks if a color block was clicked and selects the corresponding
        color in the editor. It also handles scrolling through the palette using
        the scroll indicators.

        Args:
            pos (tuple): The (x, y) position of the mouse click.
            editor (Editor): The main editor instance to call select_color on.
        """
        x0, y0 = self.position
        x, y = pos
        # Check for scroll buttons
        scroll_area_x = x0 + config.PALETTE_COLS * (self.block_size + self.padding) + 10
        if x >= scroll_area_x and x <= scroll_area_x + 20:
            scroll_area_y_top = self.position[1]
            # Calculate approx height of scroll area - bit imprecise but should work
            scroll_area_height = config.PALETTE_ROWS * (self.block_size + self.padding)
            scroll_area_y_bottom = scroll_area_y_top + scroll_area_height

            if scroll_area_y_top <= y < scroll_area_y_top + scroll_area_height / 2: # Approx top half for UP
                # Up arrow
                if self.scroll_offset > 0:
                    self.scroll_offset -= 1
            elif scroll_area_y_top + scroll_area_height / 2 <= y < scroll_area_y_bottom: # Approx bottom half for DOWN
                # Down arrow
                if self.scroll_offset < self.total_pages - 1:
                    self.scroll_offset += 1
            return

        # Determine which color was clicked
        # Reference the PALETTE defined in this module
        start_index = self.scroll_offset * self.colors_per_page
        end_index = start_index + self.colors_per_page
        visible_palette = PALETTE[start_index:end_index]

        for index, color in enumerate(visible_palette):
            col = index % config.PALETTE_COLS
            row = index // config.PALETTE_COLS
            rect = pygame.Rect(
                x0 + col * (self.block_size + self.padding),
                y0 + row * (self.block_size + self.padding),
                self.block_size,
                self.block_size
            )
            if rect.collidepoint(x, y):
                # Call the select_color method on the passed editor instance
                editor.select_color(color) 
                # --- Manually add this line below ---
                editor.paste_mode = False 
                # --- End of line to add ---
                if editor.mode == 'select':
                    editor.mode = 'draw'
                    editor.selection.selecting = False
                    editor.selection.active = False
                return 



================================================
File: src/editor/pixle_art_editor.py
================================================
import pygame
from pygame.locals import *
import tkinter as tk
from tkinter import filedialog, colorchooser
import sys
import os
import json
import copy
import colorsys

# Import the centralized config
from src.core import config

# Import newly created modules
from src.core.event_handler import EventHandler
from src.editor.editor_ui import Button, Palette, PALETTE
from src.editor.selection_manager import SelectionTool
from src.editor.sprite_editor import SpriteEditor
from src.editor.tool_manager import ToolManager

# Initialize Tkinter root window and hide it
root = None # Keep module-level variable as None, Editor will manage its own instance

# --- Initialize Tkinter Root FIRST --- 
tk_root = None
tkinter_error = None
try:
    print("Attempting to initialize tk.Tk() globally...")
    tk_root = tk.Tk()
    tk_root.withdraw() # Hide the main window
    print("Global tk.Tk() initialized successfully.")
except Exception as e:
    # Store error if Tkinter fails to initialize globally
    print(f"ERROR: Global Tkinter initialization failed: {e}")
    tkinter_error = e 
# --- End Tkinter Init ---

# Now import and initialize Pygame
pygame.init()

# Constants are now in config.py
# WIDTH, HEIGHT = 1300, 800
# EDITOR_GRID_SIZE = 32 # Visual grid size for editing
# PIXEL_SIZE = 15  # Visual size of each 'pixel' in the editor grid
# NATIVE_SPRITE_RESOLUTION = (32, 32) # Actual resolution of the sprite data
# FPS = 60
# BACKGROUND_WIDTH, BACKGROUND_HEIGHT = 1600, 800
# MAX_BRUSH_SIZE = 20
# PALETTE_COLS = 20
# PALETTE_ROWS = 8

# Setup
screen = pygame.display.set_mode((config.EDITOR_WIDTH, config.EDITOR_HEIGHT))
pygame.display.set_caption("Advanced Pixel Art Sprite Editor with Enhanced Features")
clock = pygame.time.Clock()

# Load monster data
def load_monsters():
    """
    Load monster data from the 'monsters.json' file.

    This function reads the 'monsters.json' file, which contains information about
    various monsters, including their names, types, max HP, and moves. The data
    is used to populate the editor with monster sprites and their attributes.

    Returns:
        list: A list of dictionaries, each representing a monster with its attributes.
    """
    # Use path from config
    monsters_file = os.path.join(config.DATA_DIR, "monsters.json")

    try:
        with open(monsters_file, "r") as f:
            monsters = json.load(f)
        if not isinstance(monsters, list):
            raise ValueError("monsters.json should contain a list of monsters.")
        return monsters
    except FileNotFoundError:
        print(f"Error: Could not find monsters.json in {os.path.dirname(monsters_file)}")
        print("Make sure you've created the data directory and added the monsters.json file.")
        pygame.quit()
        sys.exit(1)
    except (json.JSONDecodeError, ValueError) as e:
        print(f"Error: {e}")
        pygame.quit()
        sys.exit(1)

monsters = load_monsters()

# Editor Class with Enhanced Features
class Editor:
    """
    The main controller class for the pixel art editor application.

    This class orchestrates the entire pixel art editing experience, managing
    sprite editors, color palettes, tool selection, and user interactions. It
    handles both monster sprite editing and background editing modes.

    Attributes:
        current_color (tuple): The currently selected color (R, G, B, A).
        current_monster_index (int): Index of the currently edited monster.
        drawing (bool): Flag indicating if drawing is currently active.
        eraser_mode (bool): Flag for eraser tool activation.
        fill_mode (bool): Flag for fill tool activation.
        current_sprite (str): Identifier of the currently active sprite ('front' or 'back').
        sprites (dict): Dictionary of SpriteEditor instances for each sprite type.
        palette (Palette): The color palette instance.
        brush_size (int): Current brush size for drawing.
        selection (SelectionTool): The selection tool instance.
        copy_buffer (dict): Buffer for copied pixel data.
        mode (str): Current editing mode ('draw' or 'select').
        backgrounds (list): List of available background images.
        edit_mode (str): Current editing mode ('monster' or 'background').
        editor_zoom (float): Current zoom level of the editor.

    Methods:
        handle_event(event: pygame.event.Event) -> bool
        draw_ui() -> None
        save_current() -> None
        load_session() -> None
        undo() -> None
        redo() -> None
        # ... (other methods)
    """

    def __init__(self):
        """
        Initialize a new Editor instance.
        """
        self.current_color = PALETTE[0] # <<< Uses imported PALETTE
        self.current_monster_index = 0
        self.eraser_mode = False # Keep temporarily? DrawTool uses it.
        self.fill_mode = False # Keep temporarily? Needed for FillTool logic later.
        self.paste_mode = False # Keep temporarily? Needed for PasteTool logic later.
        self.current_sprite = 'front'
        self.sprites = {
            'front': SpriteEditor((50, 110), 'front', config.SPRITE_DIR),
            'back': SpriteEditor((575, 110), 'back', config.SPRITE_DIR) 
        }
        self.palette = Palette((50, config.EDITOR_HEIGHT - 180))
        self.brush_size = 1
        self.adjusting_brush = False
        self.selection = SelectionTool(self) # SelectionTool might become a tool in ToolManager later
        self.copy_buffer = None
        self.mode = 'draw'  # Keep? Or manage via ToolManager? Keep for 'select' vs other tools for now.
        self.backgrounds = self.load_backgrounds()
        self.current_background_index = 0 if self.backgrounds else -1
        self.edit_mode = None
        self.editor_zoom = 1.0
        self.view_offset_x = 0 
        self.view_offset_y = 0
        self.panning = False

        # Instantiate the EventHandler
        self.event_handler = EventHandler(self)

        # Instantiate the ToolManager <<< NEW
        self.tool_manager = ToolManager(self)

        self.current_background = None
        self.canvas_rect = None

        # Undo/Redo stacks
        self.undo_stack = []
        self.redo_stack = []

        self.buttons = [] # Start with empty buttons

        self.font = pygame.font.Font(config.DEFAULT_FONT, config.EDITOR_INFO_FONT_SIZE)

        self.brush_slider = pygame.Rect(50, config.EDITOR_HEIGHT - 40, 200, 20)

        # --- Reference Image Attributes ---
        self.reference_image_path = None
        self.reference_image = None # Original loaded surface
        self.scaled_reference_image = None # Scaled and alpha-applied surface for display
        self.reference_alpha = 128 # Default alpha (50% opaque)
        self.adjusting_alpha = False # Flag for slider interaction
        self.subject_alpha = 255 # << Add subject alpha (fully opaque default)
        self.adjusting_subject_alpha = False # << Add flag for subject slider

        # --- Reference Image Panning/Scaling State ---
        self.ref_img_offset = pygame.Vector2(0, 0) # Pan offset (x, y)
        self.ref_img_scale = 1.0 # Scale factor

        # Define slider rect (adjust position/size as needed)
        # Reference Alpha Slider
        ref_slider_x = 300 # Position next to brush slider for now
        ref_slider_y = config.EDITOR_HEIGHT - 40
        ref_slider_width = 150
        ref_slider_height = 20
        self.ref_alpha_slider_rect = pygame.Rect(ref_slider_x, ref_slider_y, ref_slider_width, ref_slider_height)
        ref_knob_slider_width = self.ref_alpha_slider_rect.width - 10 # Available track width
        initial_ref_knob_x = self.ref_alpha_slider_rect.x + int((self.reference_alpha / 255) * ref_knob_slider_width)
        self.ref_alpha_knob_rect = pygame.Rect(initial_ref_knob_x, ref_slider_y, 10, ref_slider_height)

        # Subject Alpha Slider (Position below reference slider)
        subj_slider_x = ref_slider_x 
        subj_slider_y = ref_slider_y + ref_slider_height + 10 # Place below ref slider
        subj_slider_width = ref_slider_width
        subj_slider_height = ref_slider_height
        self.subj_alpha_slider_rect = pygame.Rect(subj_slider_x, subj_slider_y, subj_slider_width, subj_slider_height)
        subj_knob_slider_width = self.subj_alpha_slider_rect.width - 10
        initial_subj_knob_x = self.subj_alpha_slider_rect.x + int((self.subject_alpha / 255) * subj_knob_slider_width)
        self.subj_alpha_knob_rect = pygame.Rect(initial_subj_knob_x, subj_slider_y, 10, subj_slider_height)

        # --- Dialog State ---
        self.dialog_mode = None # e.g., 'choose_edit_mode', 'choose_bg_action', 'save_bg', 'load_bg', 'color_picker', 'input_text'
        self.dialog_prompt = ""
        self.dialog_options = [] # List of tuples: (text, value) or Button objects
        self.dialog_callback = None # Function to call with the chosen value
        self.dialog_input_text = "" # For text input dialogs
        self.dialog_input_active = False # Is the text input active?
        self.dialog_input_rect = None # Rect for the input field
        self.dialog_input_max_length = 50 # Max chars for filename
        self.dialog_file_list = [] # List of files for file browser dialog
        self.dialog_file_scroll_offset = 0 # Scroll offset for file list
        self.dialog_selected_file_index = -1 # Index of selected file in list
        self.dialog_color_picker_hue = 0 # Hue for HSV color picker
        self.dialog_color_picker_sat = 1 # Saturation for HSV
        self.dialog_color_picker_val = 1 # Value for HSV
        self.dialog_color_picker_rects = {} # Rects for color picker elements
        # --- End Dialog State ---

        self.tk_root = None # Initialize instance variable for Tkinter root

        # <<< --- ADD THE CALL HERE --- >>>
        self.choose_edit_mode() # Setup the initial dialog state AFTER resetting dialog attrs

    def _ensure_tkinter_root(self):
        """Check if the global Tkinter root was initialized successfully."""
        # Access the global tk_root variable
        global tk_root, tkinter_error 
        if tk_root is None:
             print(f"Tkinter root unavailable. Global init error: {tkinter_error}")
             return False
        # If global root exists, return True
        return True

    def choose_edit_mode(self):
        """
        Set up the dialog state to choose the editing mode (monster or background).
        The actual choice will be handled in the main loop via dialog state.
    
        Returns:
            None: Sets the initial dialog state instead of returning the mode directly.
        """
        self.dialog_mode = 'choose_edit_mode'
        self.dialog_prompt = "Choose Edit Mode:"

        # Calculate positions for vertically stacked buttons centered
        dialog_center_x = config.EDITOR_WIDTH // 2
        dialog_center_y = config.EDITOR_HEIGHT // 2
        button_width = 150
        button_height = 40
        button_padding = 10
        monster_button_y = dialog_center_y - button_height - button_padding // 2
        background_button_y = dialog_center_y + button_padding // 2
        button_x = dialog_center_x - button_width // 2

        self.dialog_options = [
            Button(pygame.Rect(button_x, monster_button_y, button_width, button_height), "Monster", value="monster"), # No action, store value
            Button(pygame.Rect(button_x, background_button_y, button_width, button_height), "Background", value="background"), # No action, store value
        ]
        self.dialog_callback = self._set_edit_mode_and_continue
        # print(f"DEBUG: choose_edit_mode finished. self.dialog_mode = {self.dialog_mode}") # DEBUG

        # <<< --- REMOVE THIS RETURN --- >>>
        # return "monster" # Default to monster initially

    def _set_edit_mode_and_continue(self, mode):
        """Callback after choosing edit mode."""
        # print(f"DEBUG: Start _set_edit_mode_and_continue(mode='{mode}')") # DEBUG 4 - REMOVE
        self.edit_mode = mode # Set mode FIRST
        if mode == 'background':
            # --- Setup for Background Mode --- 
            self.canvas_rect = pygame.Rect(50, 100, config.DEFAULT_BACKGROUND_WIDTH, config.DEFAULT_BACKGROUND_HEIGHT)
            self.current_background = pygame.Surface(self.canvas_rect.size, pygame.SRCALPHA)
            self.current_background.fill(config.WHITE) # Default to white
            # --- End Setup ---
            # Now trigger the background action choice (new/edit)
            # print(f"DEBUG: Before calling choose_background_action()") # DEBUG 5 - REMOVE
            self.choose_background_action()
        else: # Monster mode
            # If monster mode, initialization is complete
            # Clear potential background canvas rect
            self.canvas_rect = None
            self.current_background = None
            self.load_monster() # Ensure monster is loaded if chosen
            self.buttons = self.create_buttons() # Recreate buttons for the correct mode
            # --- ADD CLEARING LOGIC FOR MONSTER MODE --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        # print(f"DEBUG: End _set_edit_mode_and_continue. dialog_mode={self.dialog_mode}") # DEBUG 6 - REMOVE

    def _handle_dialog_choice(self, value):
        """Internal handler for dialog button values or direct calls."""
        # print(f"DEBUG: Start _handle_dialog_choice(value={repr(value)})") # DEBUG 1 - REMOVE
        callback_to_call = self.dialog_callback # Store before potential modification
        if callback_to_call:
            if value is None: # Cancel Path
                 print("Dialog action cancelled by user.")
                 self.dialog_mode = None
                 self.dialog_prompt = ""
                 self.dialog_options = []
                 # Set back to None
                 # if hasattr(self, 'dialog_callback'):
                 #     del self.dialog_callback 
                 self.dialog_callback = None # <<< REVERT TO THIS
                 # Reset input-specific state too
                 self.dialog_input_text = ""
                 # ... rest of cancel path clearing ...
            else: # Value is not None (Confirm Path)
                 try:
                     # print(f"DEBUG: Before calling callback {getattr(callback_to_call, '__name__', 'unknown')}") # DEBUG 2 - REMOVE
                     callback_to_call(value)
                     # Callback handles its own state transitions now
                 except Exception as e:
                     print(f"ERROR during dialog callback {getattr(callback_to_call, '__name__', 'unknown')}: {e}")
                     # Clear dialog on error
                     self.dialog_mode = None
                     # ... clear other stuff ...
        # print(f"DEBUG: End _handle_dialog_choice. dialog_mode={self.dialog_mode}") # DEBUG 3 - REMOVE

    def refocus_pygame_window(self):
        """
        Refocus the Pygame window - REMOVED as Tkinter is gone.
        """
        # pygame.display.iconify() - REMOVED
        # pygame.display.set_mode((config.EDITOR_WIDTH, config.EDITOR_HEIGHT)) - REMOVED
        # print("Editor window refocused.") - REMOVED
        pass # No longer needed

    def create_buttons(self):
        """
        Create the buttons for the editor UI.

        This method creates the buttons for the editor UI based on the current
        edit mode. It returns a list of Button instances.

        Returns:
            list: A list of Button instances.
        """
        buttons = []
        button_width = 100
        button_height = 30
        padding = 5
        start_x = config.EDITOR_WIDTH - button_width - padding
        start_y = 50

        # Determine the correct save action based on the edit mode
        save_action = None
        if self.edit_mode == 'monster':
            save_action = self.save_current_monster_sprites
        elif self.edit_mode == 'background':
            save_action = self.save_background
        else:
            # Default or error handling if mode is unexpected during init
            print(f"Warning: Unknown edit mode '{self.edit_mode}' during button creation. Save button disabled.")
            save_action = lambda: print("Save disabled.") # No-op action

        all_buttons = [
            ("Save", save_action), # Use the determined action
            ("Load", self.trigger_load_background_dialog if self.edit_mode == 'background' else lambda: print("Load BG only in BG mode")),
            ("Clear", self.clear_current),
            ("Color Picker", self.open_color_picker),
            ("Eraser", self.toggle_eraser),
            ("Fill", self.toggle_fill),
            ("Select", self.toggle_selection_mode),
            ("Copy", self.copy_selection),
            ("Paste", self.paste_selection),
            ("Mirror", self.mirror_selection),
            ("Rotate", self.rotate_selection),
            ("Undo", self.undo),
            ("Redo", self.redo),
            # Add Reference Image Buttons (only relevant in monster mode?)
            ("Load Ref Img", self.load_reference_image if self.edit_mode == 'monster' else lambda: print("Ref Img only in Monster mode")),
            ("Clear Ref Img", self.clear_reference_image if self.edit_mode == 'monster' else lambda: print("Ref Img only in Monster mode")),
        ]

        if self.edit_mode == 'monster':
            all_buttons += [
                ("Prev Monster", self.previous_monster),
                ("Next Monster", self.next_monster),
                ("Switch Sprite", self.switch_sprite),
            ]
        elif self.edit_mode == 'background':
            all_buttons += [
                ("Zoom In", self.zoom_in),
                ("Zoom Out", self.zoom_out),
                ("Brush +", self.increase_brush_size),
                ("Brush -", self.decrease_brush_size),
                ("Prev BG", self.previous_background),
                ("Next BG", self.next_background),
                # Add Panning Buttons
                ("Pan Up", self.pan_up),
                ("Pan Down", self.pan_down),
                ("Pan Left", self.pan_left),
                ("Pan Right", self.pan_right),
            ]

        for i, (text, action) in enumerate(all_buttons):
            rect = (start_x, start_y + i * (button_height + padding), button_width, button_height)
            buttons.append(Button(rect, text, action))

        return buttons

    def save_current_monster_sprites(self):
        """Saves both front and back sprites for the current monster."""
        try:
            # Ensure monsters list and index are valid
            if not hasattr(config, 'monsters') or not isinstance(config.monsters, list):
                print("Error: Monster data not loaded or invalid. Cannot save.")
                return
            if not (0 <= self.current_monster_index < len(config.monsters)):
                print(f"Error: current_monster_index {self.current_monster_index} out of range. Cannot save.")
                return

            monster_name = config.monsters[self.current_monster_index].get('name')
            if not monster_name:
                print(f"Error: Monster name not found at index {self.current_monster_index}. Cannot save.")
                return

            # Save both front and back sprites
            self.sprites['front'].save_sprite(monster_name)
            self.sprites['back'].save_sprite(monster_name)
            print(f"Saved sprites for {monster_name}")

        except Exception as e:
            print(f"An unexpected error occurred during save_current_monster_sprites: {e}")

    def clear_current(self):
        """Clears the currently active editing area (sprite or background)."""
        self.save_state() # Save state before clearing
        if self.edit_mode == 'monster':
            sprite = self.sprites.get(self.current_sprite)
            if sprite:
                sprite.frame.fill((*config.BLACK[:3], 0)) # Fill with transparent black
                print(f"Cleared {self.current_sprite} sprite.")
            else:
                print(f"Error: Could not find sprite editor for {self.current_sprite} to clear.")
        elif self.edit_mode == 'background':
            if self.current_background:
                # Assuming default background is white, fill with that
                # Or could use a different default clear color if needed
                self.current_background.fill((*config.WHITE, 255)) # Fill with opaque white
                print("Cleared current background.")
            else:
                print("Error: No current background loaded to clear.")
        else:
            print(f"Warning: Unknown edit mode '{self.edit_mode}' for clear operation.")

    def toggle_eraser(self):
        """Toggle eraser mode (now handled by DrawTool state)."""
        # If already draw tool, just toggle erase_mode
        if self.tool_manager.active_tool_name == 'draw':
             self.eraser_mode = not self.eraser_mode
             print(f"Eraser mode: {self.eraser_mode}")
             # Ensure other potentially conflicting modes are off
             self.fill_mode = False 
             self.paste_mode = False
        else:
             # If switching from another tool, activate draw tool and set erase mode
             self.tool_manager.set_active_tool('draw')
             self.eraser_mode = True
             print(f"Eraser mode: {self.eraser_mode}")
        # No longer need to manage select mode here, set_active_tool does it

    def toggle_fill(self):
        """Activate fill tool."""
        # self.fill_mode = not self.fill_mode # OLD
        # self.eraser_mode = False # OLD
        # self.paste_mode = False # OLD
        # if self.mode == 'select': # OLD
        #     self.mode = 'draw' # OLD
        #     self.selection.selecting = False # OLD
        #     self.selection.active = False # OLD
        # print(f"Fill mode: {self.fill_mode}") # OLD
        self.tool_manager.set_active_tool('fill') # <<< NEW
        # We might need flags like self.fill_mode if FillTool needs them?
        # For now, assume activating the tool is sufficient.
        # ToolManager.set_active_tool handles turning off other flags.
        self.fill_mode = True # Keep flag for now until FillTool state is internal
        self.eraser_mode = False
        self.paste_mode = False

    def toggle_selection_mode(self):
        """Toggle selection mode."""
        # Selection is not yet a formal tool in ToolManager
        # Keep existing logic for now
        if self.mode == 'select':
            self.mode = 'draw'
            self.selection.selecting = False
            self.selection.active = False
            # Ensure draw tool is active when exiting select mode
            self.tool_manager.set_active_tool('draw') 
            print("Switched to Draw mode.")
        else:
            self.mode = 'select'
            self.selection.toggle() # Activate selection tool logic
            # Deactivate other tools implicitly by switching mode (handled by event handler checks)
            self.eraser_mode = False
            self.fill_mode = False
            self.paste_mode = False
            # Maybe explicitly deactivate the ToolManager's tool?
            if self.tool_manager.active_tool:
                 self.tool_manager.active_tool.deactivate(self)
            print("Switched to Select mode.")

    def copy_selection(self):
        """Copy the selected pixels to the buffer."""
        if self.mode == 'select' and self.selection.active:
            # Get the currently active sprite editor
            sprite_editor = self.sprites.get(self.current_sprite)
            if not sprite_editor:
                 print("Copy failed: Cannot find active sprite editor.")
                 return
                 
            # Pass the sprite_editor instance
            self.copy_buffer = self.selection.get_selected_pixels(sprite_editor)
            
            if self.copy_buffer:
                 print(f"Copied {len(self.copy_buffer)} pixels.")
            else:
                 print("Copy failed: No pixels selected or error getting pixels.")
        else:
            print("Copy failed: No active selection.")

    def paste_selection(self):
        """Activate paste mode with the buffered pixels."""
        if self.copy_buffer:
            # self.paste_mode = True # OLD
            # self.mode = 'draw' # Exit select mode implicitly # OLD
            # self.selection.active = False # OLD
            # self.eraser_mode = False # OLD
            # self.fill_mode = False # OLD
            # print("Paste mode activated. Click to place.") # OLD
            self.tool_manager.set_active_tool('paste') # <<< NEW
            # Keep flags for now until PasteTool state is internal?
            self.paste_mode = True 
            self.eraser_mode = False
            self.fill_mode = False
        else:
            print("Paste failed: Copy buffer is empty.")

    def mirror_selection(self):
        """Mirror the selected pixels horizontally in-place."""
        if self.mode != 'select' or not self.selection.active:
            print("Mirror failed: Make an active selection first.")
            return

        sprite_editor = self.sprites.get(self.current_sprite)
        if not sprite_editor:
            print("Mirror failed: Active sprite editor not found.")
            return

        self.save_state() # Save state before modifying
        selection_rect = self.selection.rect

        # Create a subsurface referencing the selected area (no copy needed yet)
        try:
             original_area = sprite_editor.frame.subsurface(selection_rect)
             mirrored_area = pygame.transform.flip(original_area, True, False) # Flip horizontal
        except ValueError as e:
             print(f"Error creating subsurface for mirroring: {e}")
             self.undo_stack.pop() # Remove the state we just saved
             return

        # ---> ADD THIS LINE: Clear the original area first <---
        sprite_editor.frame.fill((*config.BLACK[:3], 0), selection_rect)

        # Blit mirrored surface back onto the main frame
        sprite_editor.frame.blit(mirrored_area, selection_rect.topleft)
        print("Selection mirrored.")
        # Keep selection active

    def rotate_selection(self):
        """Rotate the selected pixels 90 degrees clockwise in-place."""
        if self.mode != 'select' or not self.selection.active:
            print("Rotate failed: Make an active selection first.")
            return

        sprite_editor = self.sprites.get(self.current_sprite)
        if not sprite_editor:
            print("Rotate failed: Active sprite editor not found.")
            return

        self.save_state() # Save state before modifying
        selection_rect = self.selection.rect

        # Create a subsurface and rotate it
        try:
            original_area = sprite_editor.frame.subsurface(selection_rect)
            # Rotating might change dimensions, so handle carefully
            rotated_area = pygame.transform.rotate(original_area, -90) # Clockwise
        except ValueError as e:
            print(f"Error creating subsurface for rotation (maybe 0 size?): {e}")
            return

        # Clear original area ONLY IF rotation doesn't change size AND it fits
        # A simpler approach for now: Overwrite with rotated, centered.
        # Clear original area first
        sprite_editor.frame.fill((*config.BLACK[:3], 0), selection_rect)

        # Blit rotated surface back, centered in the original rect bounds
        blit_pos = rotated_area.get_rect(center=selection_rect.center)
        sprite_editor.frame.blit(rotated_area, blit_pos)
        print("Selection rotated 90 degrees clockwise.")
        # Keep selection active, rect might be slightly off if not square

    def zoom_in(self):
        """Zoom in on the background canvas."""
        if self.edit_mode == 'background':
            # Increase zoom level, potentially up to a max limit
            self.editor_zoom *= 1.2 # Example: Increase by 20%
            max_zoom = 8.0 # Example maximum zoom
            self.editor_zoom = min(self.editor_zoom, max_zoom)
            print(f"Zoom In: Level {self.editor_zoom:.2f}x")
            # TODO: Adjust view offset based on mouse position
        else:
            print("Zoom only available in background mode.")

    def zoom_out(self):
        """Zoom out on the background canvas."""
        if self.edit_mode == 'background':
            # Decrease zoom level, potentially down to a min limit
            self.editor_zoom /= 1.2 # Example: Decrease by 20%
            min_zoom = 0.25 # Example minimum zoom
            self.editor_zoom = max(self.editor_zoom, min_zoom)
            print(f"Zoom Out: Level {self.editor_zoom:.2f}x")
            # TODO: Adjust view offset based on mouse position
        else:
             print("Zoom only available in background mode.")

    def increase_brush_size(self):
        """Increase brush size."""
        if self.brush_size < config.MAX_BRUSH_SIZE:
            self.brush_size += 1
            print(f"Brush size: {self.brush_size}")
        else:
             print("Max brush size reached.")

    def decrease_brush_size(self):
        """Decrease brush size."""
        if self.brush_size > 1:
            self.brush_size -= 1
            print(f"Brush size: {self.brush_size}")
        else:
             print("Min brush size reached.")

    def previous_background(self):
        """Switch to the previous background image."""
        if self.edit_mode == 'background' and self.backgrounds:
            if self.current_background_index > 0:
                self.current_background_index -= 1
                self.current_background = self.backgrounds[self.current_background_index][1].copy()
                self.undo_stack = [] # Reset undo/redo for new image
                self.redo_stack = []
                print(f"Switched to previous background: {self.backgrounds[self.current_background_index][0]}")
            else:
                print("Already at the first background.")
        else:
             print("Previous background only available in background mode with existing backgrounds.")

    def next_background(self):
        """Switch to the next background image."""
        if self.edit_mode == 'background' and self.backgrounds:
            if self.current_background_index < len(self.backgrounds) - 1:
                self.current_background_index += 1
                self.current_background = self.backgrounds[self.current_background_index][1].copy()
                self.undo_stack = [] # Reset undo/redo for new image
                self.redo_stack = []
                print(f"Switched to next background: {self.backgrounds[self.current_background_index][0]}")
            else:
                print("Already at the last background.")
        else:
             print("Next background only available in background mode with existing backgrounds.")

    def open_color_picker(self):
        """Open the system's native color picker dialog using Tkinter."""
        if not self._ensure_tkinter_root():
            # Message already printed by _ensure_tkinter_root
            return

        # Convert current color to Tkinter format (hex string)
        initial_color_hex = "#{:02x}{:02x}{:02x}".format(*self.current_color[:3])

        # Open the dialog, passing the global root as parent
        try:
             # Use the global tk_root directly
             chosen_color = colorchooser.askcolor(parent=tk_root, color=initial_color_hex, title="Select Color")
        except tk.TclError as e:
             print(f"Error opening native color picker: {e}")
             chosen_color = None
        except Exception as e: # Catch other potential errors
             print(f"Unexpected error during color chooser: {e}")
             chosen_color = None

        # Bring Pygame window back to focus might be needed here too if dialog issues persist

        if chosen_color and chosen_color[1] is not None: 
            rgb, _ = chosen_color
            new_color_rgba = (int(rgb[0]), int(rgb[1]), int(rgb[2]), 255) # Add full alpha
            self.select_color(new_color_rgba)
            print(f"Color selected via native picker: {new_color_rgba}")
        else:
            print("Color selection cancelled or failed.")

    def _get_current_picker_color(self):
        # ... This method is now only relevant for a potential Pygame fallback ...
        pass

    def _color_picker_callback(self, color):
        # ... This method is now only relevant for a potential Pygame fallback ...
        pass

    def select_color(self, color):
        """
        Select a color from the palette.

        This method sets the currently selected color based on the provided color
        tuple. It also deactivates the eraser and fill modes.

        Args:
            color (tuple): The RGBA color tuple to select.
        """
        if color is not None:
            self.current_color = color
            self.eraser_mode = False # Keep? DrawTool uses this
            self.fill_mode = False   # Keep? FillTool might need later?
            self.paste_mode = False  # Explicitly set paste mode flag off
            
            # Switch back to draw tool if another tool was active
            if self.tool_manager.active_tool_name != 'draw':
                self.tool_manager.set_active_tool('draw')
            
            # Also ensure selection mode is off
            if self.mode == 'select':
                self.mode = 'draw' # Already handled by set_active_tool if needed
                self.selection.selecting = False
                self.selection.active = False
            print(f"Selected color: {color}")

    def load_backgrounds(self):
        """
        Load available background images from the 'backgrounds' directory.

        This method scans the 'backgrounds' directory for PNG files and attempts
        to load them as background images. It returns a list of tuples, where each
        tuple contains the filename and the corresponding Pygame Surface.

        Returns:
            list: A list of tuples, each containing a filename and a Pygame Surface.
        """
        backgrounds = []
        # config should ensure BACKGROUND_DIR exists
        # if not os.path.exists(config.BACKGROUND_DIR):
        #     os.makedirs(config.BACKGROUND_DIR)
        for filename in os.listdir(config.BACKGROUND_DIR):
            if filename.endswith('.png'):
                path = os.path.join(config.BACKGROUND_DIR, filename)
                try:
                    bg = pygame.image.load(path).convert_alpha()
                    backgrounds.append((filename, bg))
                except pygame.error as e:
                    print(f"Failed to load background {filename}: {e}")
        return backgrounds

    def show_edit_mode_dialog(self):
        """
        Display a dialog to choose the editing mode - REMOVED / Replaced by dialog state.
        """
        # REMOVED Tkinter dialog code
        print("DEBUG: show_edit_mode_dialog was called but is replaced by dialog state.")
        return "monster" # Return default, logic moved to choose_edit_mode

    def show_background_action_dialog(self):
        """
        Display a dialog to choose the background action - REMOVED / Replaced by dialog state.
        """
        # REMOVED Tkinter dialog code
        print("DEBUG: show_background_action_dialog was called but is replaced by dialog state.")
        return "new" # Return default, logic moved to choose_background_action

    def choose_background_action(self):
        """
        Handle background-specific actions (new or edit) using dialog state.
        """
        # print(f"DEBUG: Start choose_background_action()") # DEBUG 7 - REMOVE
        if not self.backgrounds:
            print("No existing backgrounds. Creating a new one.")
            # print(f"DEBUG: Before calling create_new_background()") # DEBUG 8 - REMOVE
            self.create_new_background()
        else:
            self.dialog_mode = 'choose_bg_action'
            self.dialog_prompt = "Choose Background Action:"
            # --- Calculate positions --- Needed if creating buttons here
            dialog_center_x = config.EDITOR_WIDTH // 2
            dialog_center_y = config.EDITOR_HEIGHT // 2
            button_width = 150
            button_height = 40
            button_padding = 10
            new_button_y = dialog_center_y - button_height - button_padding // 2
            edit_button_y = dialog_center_y + button_padding // 2
            button_x = dialog_center_x - button_width // 2
            # --- UNCOMMENT AND SETUP DIALOG OPTIONS --- 
            self.dialog_options = [
                Button(pygame.Rect(button_x, new_button_y, button_width, button_height), "New", value="new"),
                Button(pygame.Rect(button_x, edit_button_y, button_width, button_height), "Edit Existing", value="edit")
            ]
            self.dialog_callback = self._handle_background_action_choice
        # print(f"DEBUG: End choose_background_action. dialog_mode={self.dialog_mode}") # DEBUG 9 - REMOVE

    def _handle_background_action_choice(self, action):
        """Callback after choosing background action."""
        print(f"Background action chosen: {action}")
        if action == 'new':
            self.create_new_background() # This sets dialog_mode = 'input_text'
            # Don't clear dialog state here, let the next step handle it
        elif action == 'edit' and self.backgrounds:
            self.current_background_index = 0
            self.current_background = self.backgrounds[self.current_background_index][1].copy()
            print(f"Editing background: {self.backgrounds[self.current_background_index][0]}")
            self.buttons = self.create_buttons() # Recreate buttons for the correct mode
            # --- ADD CLEARING LOGIC FOR EDIT BACKGROUND --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Invalid action or no backgrounds to edit. Creating new.")
            self.create_new_background() # This sets dialog_mode = 'input_text'
            # Don't clear dialog state here

    def create_new_background(self):
        """
        Create a new background image.
        """
        # print(f"DEBUG: Start create_new_background()") # DEBUG 10 - REMOVE
        self.dialog_mode = 'input_text'
        # print(f"DEBUG: Set dialog_mode='{self.dialog_mode}' in create_new_background") # DEBUG 11 - REMOVE
        self.dialog_prompt = "Enter filename for new background (.png):"
        self.dialog_input_text = "new_background.png" # Default text
        self.dialog_input_active = True
        self.dialog_options = [
            Button(pygame.Rect(0,0, 100, 40), "Save", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
            Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._create_new_background_callback
        # print(f"DEBUG: End create_new_background. dialog_mode={self.dialog_mode}") # DEBUG 12 - REMOVE

    def _create_new_background_callback(self, filename):
        """Callback after getting filename for new background."""
        # We don't clear dialog state here immediately, as _handle_dialog_choice handles cancel
        if filename:
            if not filename.endswith('.png'):
                filename += '.png'
            # Ensure filename is just the base name, save to BACKGROUND_DIR
            base_filename = os.path.basename(filename)
            full_path = os.path.join(config.BACKGROUND_DIR, base_filename)

            self.current_background = pygame.Surface((config.DEFAULT_BACKGROUND_WIDTH, config.DEFAULT_BACKGROUND_HEIGHT), pygame.SRCALPHA)
            self.current_background.fill((*config.WHITE, 255))  # Set to white with full opacity
            try:
                pygame.image.save(self.current_background, full_path)
                print(f"Saved background as {full_path}")
            except pygame.error as e:
                 print(f"Error saving new background {full_path}: {e}")
                 # Handle error, maybe show message? For now, just print.

            # Reload backgrounds to include the new one
            self.backgrounds = self.load_backgrounds()
            self.current_background_index = next(
                (i for i, (name, _) in enumerate(self.backgrounds) if name == base_filename),
                -1 # Should find it if save succeeded
            )
            # Ensure buttons are created/updated for the correct mode
            self.buttons = self.create_buttons()
            # --- ADD CLEARING LOGIC ON SUCCESS --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("New background creation cancelled.")
            # If cancellation happened during initial setup, decide what to do.
            # Maybe default to the first existing background or quit?
            # For now, just print. If edit_mode wasn't fully set, it might be unstable.
            if self.edit_mode == 'background' and self.current_background_index == -1:
                 print("Warning: No background loaded after cancellation.")
                 # Optionally load a default or the first available one
                 if self.backgrounds:
                      self.current_background_index = 0
                      self.current_background = self.backgrounds[0][1].copy()
                      self.buttons = self.create_buttons()
                 else:
                      # Handle case with absolutely no backgrounds - maybe quit or show error message
                      pass

    def save_background(self, filename=None):
        """
        Save the current background image.
        Uses Pygame input dialog if no filename provided or saving new.
        """
        current_filename = None
        # Corrected Indentation:
        if self.current_background_index >= 0 and self.backgrounds:
            current_filename = self.backgrounds[self.current_background_index][0]

        if not filename:
            # Use current filename if available, otherwise prompt
            filename_to_save = current_filename
            if not filename_to_save:
                 # Trigger input dialog for saving a potentially new file
                 self.dialog_mode = 'input_text'
                 self.dialog_prompt = "Enter filename to save background (.png):"
                 self.dialog_input_text = "background.png"
                 self.dialog_input_active = True
                 self.dialog_options = [
                     Button(pygame.Rect(0,0, 100, 40), "Save", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
                     Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
                 ]
                 self.dialog_callback = self._save_background_callback
                 return # Exit function, wait for dialog callback
            else:
                 # If we have a current filename, save directly without dialog
                 self._save_background_callback(filename_to_save)
        else:
             # If a specific filename is passed (e.g., for "Save As"), use it
             # This might also need a dialog in a full implementation, but for now save directly
             print(f"Warning: Direct saving to specified filename '{filename}' without dialog.")
             self._save_background_callback(filename)

    def _save_background_callback(self, filename):
        """Callback after getting filename for saving background."""
        # We don't clear dialog state here immediately
        if filename:
            if not filename.endswith('.png'):
                filename += '.png'
            # Ensure filename is just the base name, save to BACKGROUND_DIR
            base_filename = os.path.basename(filename)
            full_path = os.path.join(config.BACKGROUND_DIR, base_filename)
            try:
                 pygame.image.save(self.current_background, full_path)
                 print(f"Saved background as {full_path}")
            except pygame.error as e:
                 print(f"Error saving background {full_path}: {e}")
                 return # Don't update index if save failed
                 
            # Reload and find index only after successful save
            self.backgrounds = self.load_backgrounds()
            self.current_background_index = next(
                (i for i, (name, _) in enumerate(self.backgrounds) if name == base_filename),
                -1 # Should be found
            )
            # Update buttons if needed (though likely already correct)
            self.buttons = self.create_buttons()
            # --- ADD CLEARING LOGIC ON SUCCESS --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Background save cancelled.")

    def load_monster(self):
        """
        Load the current monster's sprites.

        This method loads the sprites for the currently selected monster. It updates
        the sprite frames and prints a status message.
        """
        try:
            # Ensure monsters list and index are valid
            if not hasattr(config, 'monsters') or not isinstance(config.monsters, list):
                print("Error: Monster data not loaded or invalid.")
                return
            if not (0 <= self.current_monster_index < len(config.monsters)):
                print(f"Error: current_monster_index {self.current_monster_index} out of range.")
                return

            monster_name = config.monsters[self.current_monster_index]['name']
            # Corrected Indentation:
            for sprite in self.sprites.values():
                sprite.load_sprite(monster_name) # Pass monster_name here
            print(f"Loaded monster: {monster_name}")
        except KeyError:
             print(f"Error: Monster data missing 'name' key at index {self.current_monster_index}.")
        except Exception as e:
             print(f"An unexpected error occurred during load_monster: {e}")

    def switch_sprite(self):
        """
        Switch between the front and back sprites.

        This method toggles between the front and back sprites for the current
        monster. It updates the current sprite and deactivates the selection.
        """
        self.current_sprite = 'back' if self.current_sprite == 'front' else 'front'
        print(f"Switched to sprite: {self.current_sprite}")
        self.selection.active = False  # Deactivate selection on sprite switch

    def previous_monster(self):
        """
        Switch to the previous monster in the list.

        This method decrements the current monster index and loads the previous
        monster's sprites. It prints a status message.
        """
        if self.current_monster_index > 0:
            self.current_monster_index -= 1
            self.load_monster()
            print(f"Switched to previous monster: {config.monsters[self.current_monster_index]['name']}")
        else:
            print("Already at the first monster.")

    def next_monster(self):
        """
        Switch to the next monster in the list.

        This method increments the current monster index and loads the next
        monster's sprites. It prints a status message.
        """
        # Ensure monsters list is loaded and valid
        if not hasattr(config, 'monsters') or not isinstance(config.monsters, list):
            print("Error: Monster data not loaded or invalid. Cannot switch.")
            return
        
        if self.current_monster_index < len(config.monsters) - 1:
            self.current_monster_index += 1
            self.load_monster()
            print(f"Switched to next monster: {config.monsters[self.current_monster_index].get('name', 'Unknown')}")
        else:
            print("Already at the last monster.")

    def _get_background_files(self):
        """Helper to get list of .png files in background directory."""
        try:
            return [f for f in os.listdir(config.BACKGROUND_DIR) if f.endswith('.png')]
        except FileNotFoundError:
            print(f"Warning: Background directory {config.BACKGROUND_DIR} not found.")
            return []

    def trigger_load_background_dialog(self):
        """Initiates the dialog for loading a background file."""
        # Ensure we are in background mode, otherwise this button shouldn't be active/visible
        if self.edit_mode != 'background':
            print("Load background only available in background edit mode.")
            return

        self.dialog_mode = 'load_bg'
        self.dialog_prompt = "Select Background to Load:"
        self.dialog_file_list = self._get_background_files() # Get the list of files
        self.dialog_file_scroll_offset = 0
        self.dialog_selected_file_index = -1

        # Define buttons for the dialog (Load and Cancel)
        # Actions will call _handle_dialog_choice with filename or None
        self.dialog_options = [
            # Buttons are positioned dynamically in draw_dialog
            Button(pygame.Rect(0, 0, 100, 40), "Load", action=lambda: self._handle_dialog_choice(
                self.dialog_file_list[self.dialog_selected_file_index] if 0 <= self.dialog_selected_file_index < len(self.dialog_file_list) else None
            )),
            Button(pygame.Rect(0, 0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._load_selected_background_callback

    def _load_selected_background_callback(self, filename):
        """Callback after selecting a background file to load."""
        # We don't clear dialog state here immediately
        if filename:
            full_path = os.path.join(config.BACKGROUND_DIR, filename)
            try:
                loaded_bg = pygame.image.load(full_path).convert_alpha()
                # Find the index in the self.backgrounds list (which contains Surfaces)
                found_index = -1
                for i, (name, _) in enumerate(self.backgrounds):
                    if name == filename:
                        found_index = i
                        break
                
                if found_index != -1:
                    self.current_background_index = found_index
                    self.current_background = self.backgrounds[found_index][1].copy() # Load from pre-loaded list
                    print(f"Loaded background: {filename}")
                else:
                    # If not found in pre-loaded list (shouldn't happen if list is up-to-date)
                    # Load it directly and add it (or maybe just load directly?)
                    self.current_background = loaded_bg
                    # Add to list if desired, or just use the directly loaded one
                    # For simplicity, let's just use the loaded one and reset index
                    self.backgrounds.append((filename, loaded_bg))
                    self.current_background_index = len(self.backgrounds) - 1
                    print(f"Loaded background {filename} directly.")
                
                # Reset undo/redo for the new background
                self.undo_stack = []
                self.redo_stack = []
                # Potentially save initial state for undo here if desired

            except pygame.error as e:
                print(f"Error loading background {full_path}: {e}")
            except FileNotFoundError:
                print(f"Error: Background file {full_path} not found.")
            # --- ADD CLEARING LOGIC ON SUCCESS --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Background load cancelled.")

    def save_state(self):
        """Save the current state of the active canvas to the undo stack."""
        # Limit stack size if desired (optional)
        # if len(self.undo_stack) > MAX_UNDO_STEPS:
        #     self.undo_stack.pop(0)

        current_state = None
        if self.edit_mode == 'monster':
            sprite = self.sprites.get(self.current_sprite)
            if sprite:
                # Store a copy of the frame and which sprite it belongs to
                current_state = ('monster', self.current_sprite, sprite.frame.copy())
        elif self.edit_mode == 'background':
            if self.current_background:
                current_state = ('background', self.current_background_index, self.current_background.copy())

        if current_state:
            self.undo_stack.append(current_state)
            self.redo_stack.clear() # Clear redo stack on new action
            # print(f"State saved. Undo stack size: {len(self.undo_stack)}") # Debug
        # else: # Debug
            # print("Save state failed: No valid state to save.")

    def undo(self):
        """Revert to the previous state from the undo stack."""
        if not self.undo_stack:
            print("Nothing to undo.")
            return

        # Get the state to restore
        state_to_restore = self.undo_stack.pop()
        state_type, state_id, state_surface = state_to_restore

        # Save current state to redo stack BEFORE restoring
        current_state_for_redo = None
        if self.edit_mode == 'monster':
            sprite = self.sprites.get(self.current_sprite)
            if sprite:
                 current_state_for_redo = ('monster', self.current_sprite, sprite.frame.copy())
        elif self.edit_mode == 'background':
             if self.current_background:
                  current_state_for_redo = ('background', self.current_background_index, self.current_background.copy())
        
        if current_state_for_redo:
             self.redo_stack.append(current_state_for_redo)

        # Restore the popped state
        if state_type == 'monster':
            sprite = self.sprites.get(state_id)
            if sprite:
                sprite.frame = state_surface.copy() # Use copy to avoid issues
                # Ensure the editor is focused on the restored sprite if it changed
                self.current_sprite = state_id 
                self.edit_mode = 'monster' # Ensure mode is correct
                print(f"Undid action for sprite: {state_id}")
            else: # Corrected indent for this else
                 print(f"Undo failed: Could not find sprite editor '{state_id}' to restore state.")
                 # Put the state back on the undo stack? Or discard?
                 self.undo_stack.append(state_to_restore) # Re-add for now
                 # Check if redo_stack is not empty before popping
                 if self.redo_stack: self.redo_stack.pop() # Remove the state we just added
        elif state_type == 'background':
            self.current_background = state_surface.copy() # Use copy
            self.current_background_index = state_id # Restore index too
            self.edit_mode = 'background' # Ensure mode is correct
            print(f"Undid action for background index: {state_id}")
        else:
            print("Undo failed: Unknown state type in stack.")
            self.undo_stack.append(state_to_restore) # Re-add
            if self.redo_stack: self.redo_stack.pop() # Remove corresponding redo

        # Update buttons if mode changed
        self.buttons = self.create_buttons()

    def redo(self):
        """Reapply the last undone action from the redo stack."""
        if not self.redo_stack:
            print("Nothing to redo.")
            return

        # Get the state to restore from redo stack
        state_to_restore = self.redo_stack.pop()
        state_type, state_id, state_surface = state_to_restore

        # Save current state to undo stack BEFORE restoring
        current_state_for_undo = None
        if self.edit_mode == 'monster':
             sprite = self.sprites.get(self.current_sprite)
             if sprite:
                  current_state_for_undo = ('monster', self.current_sprite, sprite.frame.copy())
        elif self.edit_mode == 'background':
             if self.current_background:
                  current_state_for_undo = ('background', self.current_background_index, self.current_background.copy())

        if current_state_for_undo:
             self.undo_stack.append(current_state_for_undo)

        # Restore the popped state from redo stack
        if state_type == 'monster':
            sprite = self.sprites.get(state_id)
            if sprite:
                sprite.frame = state_surface.copy()
                self.current_sprite = state_id
                self.edit_mode = 'monster'
                print(f"Redid action for sprite: {state_id}")
            else:
                 print(f"Redo failed: Could not find sprite editor '{state_id}' to restore state.")
                 self.redo_stack.append(state_to_restore) # Re-add
                 self.undo_stack.pop() # Remove corresponding undo
        elif state_type == 'background':
            self.current_background = state_surface.copy()
            self.current_background_index = state_id
            self.edit_mode = 'background'
            print(f"Redid action for background index: {state_id}")
        else:
            print("Redo failed: Unknown state type in stack.")
            self.redo_stack.append(state_to_restore) # Re-add
            if self.undo_stack: self.undo_stack.pop() # Remove corresponding undo

        # Update buttons if mode changed
        self.buttons = self.create_buttons()

    def _get_sprite_editor_at_pos(self, pos):
        """Return the SpriteEditor instance at the given screen position, or None."""
        if self.edit_mode == 'monster':
            for name, sprite_editor in self.sprites.items():
                editor_rect = pygame.Rect(sprite_editor.position, (sprite_editor.display_width, sprite_editor.display_height))
                if editor_rect.collidepoint(pos):
                    return sprite_editor
        return None

    def handle_event(self, event):
        """Process a single Pygame event by delegating to the EventHandler."""
        return self.event_handler.process_event(event)

    def load_reference_image(self):
        """Opens a dialog to select a reference image, loads and scales it."""
        if not self._ensure_tkinter_root():
            # Message already printed by _ensure_tkinter_root
            return

        try:
            # Use the global tk_root directly
            file_path = filedialog.askopenfilename(
                parent=tk_root, # Explicitly set parent
                title="Select Reference Image",
                filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All Files", "*.*")]
            )
        except tk.TclError as e:
            print(f"Error opening file dialog: {e}")
            file_path = None
        except Exception as e: # Catch other potential errors
             print(f"Unexpected error during file dialog: {e}")
             file_path = None

        # Bring Pygame window back to focus might be needed here too if dialog issues persist

        if file_path and os.path.exists(file_path):
            try:
                self.reference_image = pygame.image.load(file_path).convert_alpha()
                self.reference_image_path = file_path
                print(f"Loaded reference image: {file_path}")
                self._scale_reference_image() 
                self.apply_reference_alpha() 
            except pygame.error as e:
                print(f"Error loading image {file_path}: {e}")
                self.reference_image = None
                self.reference_image_path = None
                self.scaled_reference_image = None
            except Exception as e: 
                print(f"An unexpected error occurred during reference image loading: {e}")
                self.reference_image = None
                self.reference_image_path = None
                self.scaled_reference_image = None
        else:
            # Only print cancel message if file_path was initially valid but selection was cancelled
            # Avoids printing cancel if the dialog itself failed to open
            if file_path is not None:
                 print("Reference image loading cancelled or file not found.")

    def _scale_reference_image(self):
        """Scales the loaded reference image using Aspect Fit, then applies
           user-defined scale and offset, preparing it for display behind the active editor.
        """
        if not self.reference_image:
            self.scaled_reference_image = None
            return

        # Target dimensions are the display size of the sprite editor grid
        sprite_editor = self.sprites.get('front')
        if not sprite_editor:
            print("Error: Cannot scale reference image, sprite editor 'front' not found.")
            self.scaled_reference_image = None
            return

        canvas_w = sprite_editor.display_width
        canvas_h = sprite_editor.display_height
        orig_w, orig_h = self.reference_image.get_size()

        if orig_w == 0 or orig_h == 0:
             print("Warning: Reference image has zero dimension. Cannot scale.")
             self.scaled_reference_image = None
             return

        # 1. Calculate initial aspect fit scale
        scale_w_ratio = canvas_w / orig_w
        scale_h_ratio = canvas_h / orig_h
        aspect_scale = min(scale_w_ratio, scale_h_ratio)
        initial_scaled_w = int(orig_w * aspect_scale)
        initial_scaled_h = int(orig_h * aspect_scale)

        # 2. Apply user scale on top of aspect fit
        current_scaled_w = int(initial_scaled_w * self.ref_img_scale)
        current_scaled_h = int(initial_scaled_h * self.ref_img_scale)

        # Prevent scaling to zero size
        if current_scaled_w <= 0 or current_scaled_h <= 0:
             print("Warning: Calculated final scaled size is zero or negative. Cannot scale.")
             self.scaled_reference_image = None
             return

        try:
            # 3. Scale the ORIGINAL image to the final calculated size
            user_scaled_surf = pygame.transform.smoothscale(self.reference_image, (current_scaled_w, current_scaled_h))

            # 4. Create the final surface matching canvas size, transparent background
            final_display_surf = pygame.Surface((canvas_w, canvas_h), pygame.SRCALPHA)
            final_display_surf.fill((0, 0, 0, 0)) # Fully transparent

            # 5. Calculate centering position AND apply user offset
            center_x = (canvas_w - current_scaled_w) // 2
            center_y = (canvas_h - current_scaled_h) // 2
            blit_x = center_x + int(self.ref_img_offset.x)
            blit_y = center_y + int(self.ref_img_offset.y)

            # 6. Blit the user-scaled image onto the transparent canvas at the final position
            final_display_surf.blit(user_scaled_surf, (blit_x, blit_y))

            # Store this surface before applying alpha
            self.scaled_reference_image = final_display_surf

            # Apply the current alpha value
            self.apply_reference_alpha()

        except pygame.error as e:
            print(f"Error during reference image scaling: {e}")
            self.scaled_reference_image = None
        except ValueError as e: # Catch potential issues with smoothscale
            print(f"Error during reference image scaling (ValueError): {e}")
            self.scaled_reference_image = None


    def clear_reference_image(self):
        """Removes the current reference image."""
        self.reference_image_path = None
        self.reference_image = None
        self.scaled_reference_image = None
        # Reset panning and scaling
        self.ref_img_offset.update(0, 0)
        self.ref_img_scale = 1.0
        print("Reference image cleared.")

    def set_reference_alpha(self, alpha_value):
        """Sets the alpha value (0-255) for the reference image."""
        new_alpha = max(0, min(255, int(alpha_value))) # Clamp value
        if new_alpha != self.reference_alpha:
            self.reference_alpha = new_alpha
            #print(f"Set reference alpha to: {self.reference_alpha}") # Debug
            self.apply_reference_alpha()

    def apply_reference_alpha(self):
        """Applies the current alpha value to the scaled reference image surface."""
        # This logic needs refinement. set_alpha modifies the surface in-place.
        # We need to re-apply alpha if the base scaled image changes or alpha changes.
        # Let's re-scale if the reference_image exists but scaled is None
        if self.reference_image and not self.scaled_reference_image:
             self._scale_reference_image()
             # _scale_reference_image now calls apply_reference_alpha internally at the end
             return # Scaling handles alpha application

        # If scaled image exists, just set its alpha
        if self.scaled_reference_image:
            try:
                # Create a fresh scaled surface if it doesn't exist (should be handled above)
                # if not self.scaled_reference_image: self._scale_reference_image()
                # If still none, exit
                # if not self.scaled_reference_image: return

                # Apply alpha to the existing scaled surface
                self.scaled_reference_image.set_alpha(self.reference_alpha)

                # Update knob position based on new alpha
                slider_width = self.ref_alpha_slider_rect.width - self.ref_alpha_knob_rect.width
                # Ensure slider_width is not zero to avoid division error
                if slider_width > 0:
                    knob_x = self.ref_alpha_slider_rect.x + int((self.reference_alpha / 255) * slider_width)
                    self.ref_alpha_knob_rect.x = knob_x
                else: # Handle edge case where slider is too small
                    self.ref_alpha_knob_rect.x = self.ref_alpha_slider_rect.x

            except pygame.error as e:
                print(f"Error applying alpha to reference image: {e}")
            except AttributeError:
                 # Handle case where scaled_reference_image might be None unexpectedly
                 print("Warning: Tried to apply alpha but scaled_reference_image is None.")

    def set_subject_alpha(self, alpha_value):
        """Sets the alpha value (0-255) for the subject sprite being edited."""
        new_alpha = max(0, min(255, int(alpha_value))) # Clamp value
        if new_alpha != self.subject_alpha:
            self.subject_alpha = new_alpha
            # Update knob position
            slider_width = self.subj_alpha_slider_rect.width - self.subj_alpha_knob_rect.width
            if slider_width > 0:
                knob_x = self.subj_alpha_slider_rect.x + int((self.subject_alpha / 255) * slider_width)
                self.subj_alpha_knob_rect.x = knob_x
            else:
                self.subj_alpha_knob_rect.x = self.subj_alpha_slider_rect.x
            # No need to call apply_alpha here, draw_ui will use the value
            
    def draw_ui(self):
        """Draw the entire editor UI onto the screen."""
        screen.fill(config.EDITOR_BG_COLOR)
        # print(f"DEBUG: draw_ui start. self.dialog_mode = {self.dialog_mode}") # REMOVE EXCESSIVE PRINT

        # --- Draw Dialog FIRST if active --- 
        if self.dialog_mode:
            self.draw_dialog(screen)
            # Don't draw the rest of the UI while a dialog is fully obscuring it
            # (Except maybe a background blur/tint, already handled by draw_dialog overlay)
            return # Stop drawing here if a dialog is active

        # --- Draw Main UI (Only if no dialog active and mode is set) ---
        if self.edit_mode is None:
             # This state should ideally not persist after the initial dialog
             # If we reach here, something might be wrong with dialog flow
             # Maybe draw a "Loading..." or error message?
             loading_font = pygame.font.Font(config.DEFAULT_FONT, 30)
             loading_surf = loading_font.render("Waiting for mode selection...", True, config.BLACK)
             loading_rect = loading_surf.get_rect(center=screen.get_rect().center)
             screen.blit(loading_surf, loading_rect)
             return # Don't draw buttons etc. if mode not set

        # Draw based on mode
        if self.edit_mode == 'monster':
            # 1. Draw Editor Backgrounds (Checkerboards) for BOTH editors
            for sprite_editor in self.sprites.values():
                sprite_editor.draw_background(screen)

            # 2. Draw Reference Image (if active) behind the ACTIVE editor
            if self.scaled_reference_image:
                active_sprite_editor = self.sprites.get(self.current_sprite)
                if active_sprite_editor:
                    screen.blit(self.scaled_reference_image, active_sprite_editor.position)

            # 3. Draw Sprite Pixels for BOTH editors (on top of checkerboard and ref image)
            for name, sprite_editor in self.sprites.items():
                # --- Apply Subject Alpha --- 
                # Create a temporary surface with the subject alpha applied
                display_surface = sprite_editor.frame.copy() # Get the native sprite data
                # Scale it up first for display
                scaled_display_frame = pygame.transform.scale(display_surface, (sprite_editor.display_width, sprite_editor.display_height))
                # Apply the subject alpha to the scaled surface
                scaled_display_frame.set_alpha(self.subject_alpha) 
                # Blit the alpha-modified scaled surface
                screen.blit(scaled_display_frame, sprite_editor.position)
                # --- End Apply Subject Alpha ---
            
            # 4. Draw Highlight for the ACTIVE editor
            active_sprite_editor = self.sprites.get(self.current_sprite)
            if active_sprite_editor:
                active_sprite_editor.draw_highlight(screen, self.current_sprite) # Pass current_sprite

            # Draw Palette & Info Text (Existing)
            self.palette.draw(screen, self.current_color) # Pass current_color
            monster_name = config.monsters[self.current_monster_index].get('name', 'Unknown')
            info_text = f"Editing: {monster_name} ({self.current_sprite})" 
            info_surf = self.font.render(info_text, True, config.BLACK)
            screen.blit(info_surf, (50, 50))

        elif self.edit_mode == 'background':
            # Draw background canvas with zoom and pan
            if self.current_background:
                # 1. Calculate the scaled size of the full background image
                scaled_width = int(self.current_background.get_width() * self.editor_zoom)
                scaled_height = int(self.current_background.get_height() * self.editor_zoom)
                
                # Prevent scaling to zero size
                if scaled_width <= 0 or scaled_height <= 0:
                    print("Warning: Invalid zoom level resulting in zero size.")
                else:
                    # 2. Scale the original background to the zoomed size (consider performance for large images)
                    # Using pygame.transform.smoothscale might be slow; regular scale is faster for pixel art feel if needed.
                    zoomed_bg = pygame.transform.scale(self.current_background, (scaled_width, scaled_height))
                    
                    # 3. Define the source rect (area from zoomed_bg to display)
                    # Clamp view_offset to prevent scrolling beyond image boundaries
                    max_offset_x = max(0, scaled_width - self.canvas_rect.width)
                    max_offset_y = max(0, scaled_height - self.canvas_rect.height)
                    self.view_offset_x = max(0, min(self.view_offset_x, max_offset_x))
                    self.view_offset_y = max(0, min(self.view_offset_y, max_offset_y))
                    
                    source_rect = pygame.Rect(self.view_offset_x, self.view_offset_y, 
                                            self.canvas_rect.width, self.canvas_rect.height)
                                            
                    # 4. Blit the visible portion (source_rect) to the canvas destination rect
                    screen.blit(zoomed_bg, self.canvas_rect.topleft, source_rect)
            
            # Draw border around the canvas view area
            pygame.draw.rect(screen, config.BLACK, self.canvas_rect, 1) 
            
            # Draw Palette
            self.palette.draw(screen, self.current_color)
            # Draw Info Text
            bg_name = self.backgrounds[self.current_background_index][0] if self.current_background_index != -1 else "New BG"
            info_text = f"Editing BG: {bg_name} | Brush: {self.brush_size} | Zoom: {self.editor_zoom:.2f}x"
            info_surf = self.font.render(info_text, True, config.BLACK)
            screen.blit(info_surf, (50, 50))

        # Draw common elements (Buttons, Selection, Slider)
        if hasattr(self, 'buttons') and self.buttons:
             for button in self.buttons:
                  button.draw(screen)
        else:
             print("Warning: edit_mode is set but self.buttons not found in draw_ui")

        # Only draw selection if in monster mode and select mode is active
        if self.edit_mode == 'monster' and self.mode == 'select':
            active_sprite_editor = self.sprites.get(self.current_sprite)
            if active_sprite_editor: # Ensure we have the editor
                self.selection.draw(screen, active_sprite_editor.position)
            # else: # Optional: Handle case where current_sprite is somehow invalid
            #     print(f"Warning: Cannot draw selection, invalid current_sprite: {self.current_sprite}")

        # Draw Brush Size Slider (Existing)
        pygame.draw.rect(screen, config.GRAY_LIGHT, self.brush_slider)
        pygame.draw.rect(screen, config.BLACK, self.brush_slider, 1)
        # Draw brush size knob/indicator (if needed)
        # Add Label for Brush Slider <<<<<< NEW
        brush_text = f"Brush: {self.brush_size}"
        brush_surf = self.font.render(brush_text, True, config.BLACK)
        brush_rect = brush_surf.get_rect(midleft=(self.brush_slider.right + 10, self.brush_slider.centery))
        screen.blit(brush_surf, brush_rect)

        # --- Draw Reference Alpha Slider --- (Existing)
        # Draw slider track
        pygame.draw.rect(screen, config.GRAY_LIGHT, self.ref_alpha_slider_rect)
        pygame.draw.rect(screen, config.BLACK, self.ref_alpha_slider_rect, 1)
        # Draw slider knob
        pygame.draw.rect(screen, config.BLUE, self.ref_alpha_knob_rect) # Use a distinct color for knob
        # Draw alpha value text near slider
        alpha_text = f"Ref Alpha: {self.reference_alpha}"
        alpha_surf = self.font.render(alpha_text, True, config.BLACK)
        alpha_rect = alpha_surf.get_rect(midleft=(self.ref_alpha_slider_rect.right + 10, self.ref_alpha_slider_rect.centery))
        screen.blit(alpha_surf, alpha_rect)

        # --- Draw Subject Alpha Slider (only in monster mode) --- 
        if self.edit_mode == 'monster':
            # Draw slider track
            pygame.draw.rect(screen, config.GRAY_LIGHT, self.subj_alpha_slider_rect)
            pygame.draw.rect(screen, config.BLACK, self.subj_alpha_slider_rect, 1)
            # Draw slider knob
            pygame.draw.rect(screen, config.RED, self.subj_alpha_knob_rect) # Use a different color? Red for now
            # Draw alpha value text near slider
            subj_alpha_text = f"Subj Alpha: {self.subject_alpha}"
            subj_alpha_surf = self.font.render(subj_alpha_text, True, config.BLACK)
            subj_alpha_rect = subj_alpha_surf.get_rect(midleft=(self.subj_alpha_slider_rect.right + 10, self.subj_alpha_slider_rect.centery))
            screen.blit(subj_alpha_surf, subj_alpha_rect)
        
        # ... (draw dialog) ...

    def draw_dialog(self, surface):
        """Draws the current dialog box overlay."""
        # Placeholder - needs full implementation for different dialog types
        # Basic semi-transparent overlay
        overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
        overlay.fill((*config.BLACK[:3], 180))
        surface.blit(overlay, (0, 0))

        # Simple box and prompt
        dialog_width = 400
        dialog_height = 300
        dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        dialog_rect.center = surface.get_rect().center
        pygame.draw.rect(surface, config.WHITE, dialog_rect, border_radius=5)
        pygame.draw.rect(surface, config.BLACK, dialog_rect, 2, border_radius=5)

        prompt_surf = self.font.render(self.dialog_prompt, True, config.BLACK)
        prompt_rect = prompt_surf.get_rect(midtop=(dialog_rect.centerx, dialog_rect.top + 20))
        surface.blit(prompt_surf, prompt_rect)

        # Draw options (buttons) - needs proper layout
        button_y = prompt_rect.bottom + 30
        for i, option in enumerate(self.dialog_options):
             if isinstance(option, Button):
                  # REMOVED incorrect re-centering. Buttons have correct Rects already.
                  # option.rect.center = (dialog_rect.centerx, button_y + i * (option.rect.height + 10))
                  option.draw(surface) # Draw using the button's own Rect
        # Add rendering for other dialog elements (text input, file list, color picker)

    def run(self):
        """Main application loop."""
        running = True
        while running:
            # Event handling
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                self.handle_event(event) # Pass event to editor

            # Drawing
            self.draw_ui()

            # Update display
            pygame.display.flip()

            # Cap frame rate
            clock.tick(config.FPS)

        pygame.quit()

    # --- Add Panning Methods --- 
    def _pan_view(self, dx=0, dy=0):
        """Helper method to adjust view offset and clamp values."""
        if self.edit_mode != 'background':
            return
            
        self.view_offset_x += dx
        self.view_offset_y += dy

        # Clamp view offset
        if self.current_background:
            scaled_width = int(self.current_background.get_width() * self.editor_zoom)
            scaled_height = int(self.current_background.get_height() * self.editor_zoom)
            max_offset_x = max(0, scaled_width - self.canvas_rect.width)
            max_offset_y = max(0, scaled_height - self.canvas_rect.height)
            self.view_offset_x = max(0, min(self.view_offset_x, max_offset_x))
            self.view_offset_y = max(0, min(self.view_offset_y, max_offset_y))

    def pan_up(self):
        self._pan_view(dy=-config.PAN_SPEED_PIXELS)

    def pan_down(self):
        self._pan_view(dy=config.PAN_SPEED_PIXELS)

    def pan_left(self):
        self._pan_view(dx=-config.PAN_SPEED_PIXELS)

    def pan_right(self):
        self._pan_view(dx=config.PAN_SPEED_PIXELS)
    # --- End Panning Methods --- 

# Main execution block
if __name__ == "__main__":
    # --- Initialize Tkinter Root HERE --- 
    try:
        print("Attempting to initialize tk.Tk() for main execution...")
        tk_root = tk.Tk()
        tk_root.withdraw() # Hide the main window
        print("Main execution tk.Tk() initialized successfully.")
    except Exception as e:
        print(f"ERROR: Main execution Tkinter initialization failed: {e}")
        tkinter_error = e
    # --- End Tkinter Init --- 

    # Set up necessary directories if they don't exist
    # ... (directory setup code remains the same) ...
    if not os.path.exists(config.SPRITE_DIR):
        os.makedirs(config.SPRITE_DIR)
        print(f"Created missing directory: {config.SPRITE_DIR}")
    if not os.path.exists(config.BACKGROUND_DIR):
        os.makedirs(config.BACKGROUND_DIR)
        print(f"Created missing directory: {config.BACKGROUND_DIR}")
    if not os.path.exists(config.DATA_DIR):
         os.makedirs(config.DATA_DIR)
         print(f"Created missing directory: {config.DATA_DIR}")

    # Ensure monster data is loaded globally for the Editor
    # ... (monster loading code remains the same) ...
    if 'monsters' not in globals() or not monsters:
         print("Reloading monster data for main execution...")
         monsters = load_monsters() 
         if not monsters:
              print("Fatal: Could not load monster data. Exiting.")
              sys.exit(1)
    config.monsters = monsters 

    editor = Editor()
    editor.run()



================================================
File: src/editor/selection_manager.py
================================================
import pygame
# from ..core import config # Relative import
from src.core import config # Absolute import

# Selection Tool Class
class SelectionTool:
    """
    A selection tool for the pixel art editor.

    This class allows users to select and manipulate a rectangular area of pixels
    within the editor. It supports copying, pasting, mirroring, and rotating
    the selected area.

    Attributes:
        editor (Editor): The main editor instance.
        selecting (bool): Flag indicating if the selection tool is currently active.
        active (bool): Flag indicating if a selection is currently in progress.
        start_pos (tuple): The starting position of the selection rectangle.
        end_pos (tuple): The ending position of the selection rectangle.
        rect (pygame.Rect): The current selection rectangle.

    Methods:
        toggle() -> None
        start(pos: tuple) -> None
        update(pos: tuple) -> None
        end_selection(pos: tuple) -> None
        update_rect() -> None
        draw(surface: pygame.Surface) -> None
        get_selected_pixels(sprite_editor) -> dict
    """

    def __init__(self, editor):
        """
        Initialize a new SelectionTool instance.

        Args:
            editor (Editor): The main editor instance.
        """
        self.editor = editor
        self.selecting = False
        self.active = False
        self.start_pos = None
        self.end_pos = None
        self.rect = pygame.Rect(0, 0, 0, 0)

    def toggle(self):
        """
        Toggle the selection tool's activation state.
        """
        self.selecting = True  # Always start fresh selection
        self.active = False  # Reset active state
        self.start_pos = None  # Reset start position
        self.end_pos = None  # Reset end position
        self.rect = pygame.Rect(0, 0, 0, 0)  # Reset rectangle
        print("Selection mode activated.")

    def start(self, pos, sprite_editor):
        """
        Start a new selection at the given position on the specified sprite editor.

        Args:
            pos (tuple): The starting screen position of the selection rectangle.
            sprite_editor (SpriteEditor): The sprite editor where the selection is starting.
        """
        grid_pos = sprite_editor.get_grid_position(pos)
        if grid_pos:
            self.start_pos = grid_pos
            self.end_pos = grid_pos
            self.update_rect()
            print(f"Selection started at: {self.start_pos}")

    def update(self, pos, sprite_editor):
        """
        Update the selection rectangle based on the given position on the specified sprite editor.

        Args:
            pos (tuple): The current screen position of the mouse.
            sprite_editor (SpriteEditor): The sprite editor where the selection is active.
        """
        grid_pos = sprite_editor.get_grid_position(pos)
        if grid_pos:
            self.end_pos = grid_pos
            self.update_rect()
            print(f"Selection updated to: {self.end_pos}")

    def end_selection(self, pos, sprite_editor):
        """
        End the current selection at the given position on the specified sprite editor.

        Args:
            pos (tuple): The ending screen position of the selection rectangle.
            sprite_editor (SpriteEditor): The sprite editor where the selection ended.
        """
        grid_pos = sprite_editor.get_grid_position(pos)
        if grid_pos:
            self.end_pos = grid_pos
            self.update_rect()
            self.active = True
            self.selecting = False
            print(f"Selection defined: {self.rect}")

    def update_rect(self):
        """
        Update the selection rectangle based on the start and end positions.
        """
        if self.start_pos and self.end_pos:
            x1, y1 = self.start_pos
            x2, y2 = self.end_pos
            left = min(x1, x2)
            top = min(y1, y2)
            width = abs(x2 - x1) + 1
            height = abs(y2 - y1) + 1
            self.rect = pygame.Rect(left, top, width, height)

    def draw(self, surface, sprite_position):
        """
        Draw the selection rectangle on a given surface, relative to the sprite's position.

        Args:
            surface (pygame.Surface): The surface on which to draw the selection.
            sprite_position (tuple): The screen coordinates (x, y) of the top-left corner of the sprite editor.
        """
        # Draw selection rectangle while selecting (mouse down) or when selection is active
        if (self.selecting and self.start_pos and self.end_pos) or self.active:
            x0, y0 = sprite_position
            selection_surface = pygame.Surface((self.rect.width * config.EDITOR_PIXEL_SIZE, self.rect.height * config.EDITOR_PIXEL_SIZE), pygame.SRCALPHA)
            selection_surface.fill(config.SELECTION_FILL_COLOR)  # Semi-transparent blue
            pygame.draw.rect(selection_surface, config.BLUE, selection_surface.get_rect(), 2)
            surface.blit(selection_surface, (x0 + self.rect.x * config.EDITOR_PIXEL_SIZE, y0 + self.rect.y * config.EDITOR_PIXEL_SIZE))

    def get_selected_pixels(self, sprite_editor):
        """ Get the pixels within the selection rectangle (coords relative to 32x32 grid). """
        if not sprite_editor or not self.active:
            return {}

        pixels = {}
        # self.rect is relative to the visual grid (0-31 range)
        # Native frame is also 32x32, so coords match directly
        for x in range(self.rect.width):
            for y in range(self.rect.height):
                grid_x = self.rect.x + x
                grid_y = self.rect.y + y
                # Check bounds against native resolution (32x32)
                if 0 <= grid_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= grid_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                    color = sprite_editor.get_pixel_color((grid_x, grid_y))
                    if color is not None:
                        pixels[(x, y)] = color # Store relative to selection top-left
        return pixels

    def apply_paste(self, sprite_editor, top_left_grid_pos, copy_buffer):
        """Pastes the copy_buffer onto the sprite_editor frame."""
        if not copy_buffer or not sprite_editor:
            return

        start_x, start_y = top_left_grid_pos
        for (rel_x, rel_y), color in copy_buffer.items():
            abs_x = start_x + rel_x
            abs_y = start_y + rel_y
            # Check bounds before attempting to draw
            if 0 <= abs_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= abs_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                # Only paste non-transparent pixels.
                if color[3] > 0:
                    sprite_editor.draw_pixel((abs_x, abs_y), color)



================================================
File: src/editor/sprite_editor.py
================================================
import pygame
import os
# from ..core import config # Relative import
from src.core import config # Absolute import

class SpriteEditor:
    """ Edits sprites at 32x32 native resolution. """
    def __init__(self, position, name, sprite_dir):
        self.position = position
        self.name = name
        self.sprite_dir = sprite_dir # Store the directory
        # Internal frame stores the actual sprite data at native resolution (32x32)
        self.frame = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
        self.frame.fill((*config.BLACK[:3], 0)) # Transparent black
        # Calculate the total display size of the editor grid
        self.display_width = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE
        self.display_height = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE

    def load_sprite(self, monster_name):
        """Loads sprite, checks size, scales to NATIVE_SPRITE_RESOLUTION if needed."""
        self.frame.fill((*config.BLACK[:3], 0)) # Transparent black
        # Use the stored sprite_dir
        filename = os.path.join(self.sprite_dir, f"{monster_name}_{self.name}.png")
        if os.path.exists(filename):
            try:
                loaded_image = pygame.image.load(filename).convert_alpha()
                # Scale to native (32x32) if it doesn't match
                if loaded_image.get_size() != config.NATIVE_SPRITE_RESOLUTION:
                    print(f"Warning: Loaded sprite {filename} size {loaded_image.get_size()} does not match native {config.NATIVE_SPRITE_RESOLUTION}. Scaling down.")
                    loaded_image = pygame.transform.smoothscale(loaded_image, config.NATIVE_SPRITE_RESOLUTION)
                self.frame.blit(loaded_image, (0, 0))
            except pygame.error as e:
                 print(f"Error loading sprite {filename}: {e}")
                 # Use a placeholder color from config
                 placeholder_color = (*config.RED[:3], 100) if hasattr(config, 'RED') else (255, 0, 0, 100)
                 self.frame.fill(placeholder_color) # Semi-transparent red/magenta placeholder
        else:
            print(f"Sprite not found: {filename}. Creating blank.")
            self.frame.fill((*config.BLACK[:3], 0))

    def save_sprite(self, monster_name):
        """Saves the internal 32x32 frame directly, requires monster_name."""
        # config.py should ensure SPRITE_DIR exists

        # Ensure monster_name is provided
        if not monster_name:
            print("Error: Cannot save sprite. Monster name is required.")
            return

        filename = os.path.join(self.sprite_dir, f"{monster_name}_{self.name}.png")
        try:
            pygame.image.save(self.frame, filename)
            print(f"Saved sprite: {filename} at {config.NATIVE_SPRITE_RESOLUTION}")
        except pygame.error as e:
             print(f"Error saving sprite {filename}: {e}")

    def draw_background(self, surface):
        """Draws the checkerboard background for the editor grid."""
        for y in range(config.EDITOR_GRID_SIZE):
            for x in range(config.EDITOR_GRID_SIZE):
                rect = (self.position[0] + x * config.EDITOR_PIXEL_SIZE, 
                        self.position[1] + y * config.EDITOR_PIXEL_SIZE, 
                        config.EDITOR_PIXEL_SIZE, config.EDITOR_PIXEL_SIZE)
                # Use checkerboard colors from config
                color1 = config.GRID_COLOR_1 if hasattr(config, 'GRID_COLOR_1') else (200, 200, 200)
                color2 = config.GRID_COLOR_2 if hasattr(config, 'GRID_COLOR_2') else (180, 180, 180)
                color = color1 if (x + y) % 2 == 0 else color2
                pygame.draw.rect(surface, color, rect)

    def draw_pixels(self, surface):
        """Draws the scaled sprite pixels onto the target surface."""
        # Scale the 32x32 native frame up to the display size (e.g., 480x480)
        # Use regular scale for pixel art sharpness
        scaled_display_frame = pygame.transform.scale(self.frame, (self.display_width, self.display_height))
        surface.blit(scaled_display_frame, self.position)

    def draw_highlight(self, surface, current_sprite_name):
        """Draws the highlight rectangle if this editor is active."""
        if current_sprite_name == self.name:
            highlight_rect = pygame.Rect(self.position[0] - 10, self.position[1] - 10,
                                         self.display_width + 20, self.display_height + 20)
            # Use highlight color from config
            highlight_color = config.SELECTION_HIGHLIGHT_COLOR if hasattr(config, 'SELECTION_HIGHLIGHT_COLOR') else (0, 255, 0)
            pygame.draw.rect(surface, highlight_color, highlight_rect, 3)

    def draw(self, surface):
        """Draws the scaled-up sprite editor grid onto the target surface.
           DEPRECATED in favor of draw_background and draw_pixels.
           Kept for compatibility or potential future use, but logic moved.
        """
        # This method is now simplified or can be removed if draw_ui is fully updated.
        # For safety, let's make it call the new methods for now.
        self.draw_background(surface)
        self.draw_pixels(surface)
        # Highlight is drawn separately in draw_ui now.

    def get_grid_position(self, pos):
        """Converts screen coordinates (within display area) to 32x32 grid coordinates."""
        x, y = pos
        # Check if click is within the visual editor bounds
        if not (self.position[0] <= x < self.position[0] + self.display_width and
                self.position[1] <= y < self.position[1] + self.display_height):
            return None

        # Calculate grid coordinates directly from relative position and PIXEL_SIZE
        grid_x = (x - self.position[0]) // config.EDITOR_PIXEL_SIZE
        grid_y = (y - self.position[1]) // config.EDITOR_PIXEL_SIZE

        # Ensure coordinates are within the 32x32 grid bounds
        if 0 <= grid_x < config.EDITOR_GRID_SIZE and 0 <= grid_y < config.EDITOR_GRID_SIZE:
             # Since native is 32x32 and editor grid is 32x32, coords are the same
            return grid_x, grid_y
        return None

    def draw_pixel(self, grid_pos, color):
        """Draws a pixel at the given 32x32 grid coordinates."""
        if 0 <= grid_pos[0] < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= grid_pos[1] < config.NATIVE_SPRITE_RESOLUTION[1]:
            self.frame.set_at(grid_pos, color)

    def get_pixel_color(self, grid_pos):
         """Gets the color of a pixel from the 32x32 grid coordinates."""
         if 0 <= grid_pos[0] < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= grid_pos[1] < config.NATIVE_SPRITE_RESOLUTION[1]:
            return self.frame.get_at(grid_pos)
         return None 


================================================
File: src/editor/tool_manager.py
================================================
# tool_manager.py

"""Manages different editing tools (Draw, Fill, Paste, etc.) for the pixel editor."""

import pygame
# from ..core import config # Relative import
from src.core import config # Absolute import
# Need SpriteEditor for type hinting potentially, or direct manipulation
# from .sprite_editor import SpriteEditor # Relative import
from src.editor.sprite_editor import SpriteEditor # Absolute import

# --- Base Tool --- (Optional, but good for structure)
class BaseTool:
    def __init__(self, name):
        self.name = name

    def handle_click(self, editor, pos):
        """Handles a mouse click event at the given position."""
        raise NotImplementedError

    def handle_drag(self, editor, pos):
        """Handles a mouse drag event at the given position."""
        # Default behavior for many tools might be same as click
        self.handle_click(editor, pos)

    def activate(self, editor):
        """Called when the tool becomes active."""
        print(f"{self.name} tool activated.")
        pass # Optional setup

    def deactivate(self, editor):
        """Called when the tool is deactivated."""
        print(f"{self.name} tool deactivated.")
        pass # Optional cleanup

# --- Draw/Erase Tool ---
class DrawTool(BaseTool):
    def __init__(self):
        super().__init__("Draw/Erase")

    def _get_target(self, editor, pos):
        """Helper to get the target sprite editor or background surface."""
        if editor.edit_mode == 'monster':
            return editor._get_sprite_editor_at_pos(pos)
        elif editor.edit_mode == 'background' and editor.canvas_rect and editor.current_background:
            if editor.canvas_rect.collidepoint(pos):
                return editor.current_background # Return the surface
        return None

    def _draw_on_sprite(self, editor, sprite_editor, grid_pos):
        """Handles drawing/erasing on a SpriteEditor."""
        color = (*config.BLACK[:3], 0) if editor.eraser_mode else editor.current_color
        half_brush = (editor.brush_size - 1) // 2
        for dy in range(-half_brush, half_brush + 1):
            for dx in range(-half_brush, half_brush + 1):
                # Optional: Add check for circular brush shape if desired
                # if dx*dx + dy*dy <= half_brush*half_brush:
                draw_x = grid_pos[0] + dx
                draw_y = grid_pos[1] + dy
                if 0 <= draw_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= draw_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                    sprite_editor.draw_pixel((draw_x, draw_y), color)

    def _draw_on_background(self, editor, background_surface, pos):
        """Handles drawing/erasing on the background surface."""
        if not editor.canvas_rect: return

        # Calculate position relative to the background canvas top-left
        screen_x_rel = pos[0] - editor.canvas_rect.x
        screen_y_rel = pos[1] - editor.canvas_rect.y
        
        # Convert screen coordinates within canvas_rect to coordinates on the original surface
        original_x = int((screen_x_rel + editor.view_offset_x) / editor.editor_zoom)
        original_y = int((screen_y_rel + editor.view_offset_y) / editor.editor_zoom)
        
        # Check if calculated coordinates are within the original background bounds
        bg_width, bg_height = background_surface.get_size()
        if 0 <= original_x < bg_width and 0 <= original_y < bg_height:
            color = config.WHITE if editor.eraser_mode else editor.current_color[:3] # Use opaque colors for BG
            # Scale the brush radius based on zoom
            scaled_radius = max(1, int((editor.brush_size / 2) / editor.editor_zoom))
            pygame.draw.circle(background_surface, color, (original_x, original_y), scaled_radius)


    def handle_click(self, editor, pos):
        target = self._get_target(editor, pos)
        if not target: 
            return

        if isinstance(target, SpriteEditor): # Target is SpriteEditor
            sprite_editor = target
            grid_pos = sprite_editor.get_grid_position(pos)
            if grid_pos:
                self._draw_on_sprite(editor, sprite_editor, grid_pos)
        elif isinstance(target, pygame.Surface): # Target is background Surface
            self._draw_on_background(editor, target, pos)

# --- Fill Tool ---
class FillTool(BaseTool):
    def __init__(self):
        super().__init__("Fill")

    def _flood_fill_sprite(self, sprite_editor, start_pos, fill_color):
        """Perform flood fill on the sprite editor's frame."""
        native_res = config.NATIVE_SPRITE_RESOLUTION
        target_color = sprite_editor.get_pixel_color(start_pos)

        if target_color == fill_color:
            return # No need to fill

        stack = [start_pos]
        visited = {start_pos}

        while stack:
            x, y = stack.pop()
            # Check color again in case it was changed by another path
            current_pixel_color = sprite_editor.get_pixel_color((x, y))
            if current_pixel_color == target_color:
                sprite_editor.draw_pixel((x, y), fill_color)
                # Check neighbors
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < native_res[0] and 0 <= ny < native_res[1]:
                        neighbor_pos = (nx, ny)
                        if neighbor_pos not in visited:
                             stack.append(neighbor_pos)
                             visited.add(neighbor_pos)
        print("Fill complete.")
        # Note: editor.save_state() should be called *before* invoking the tool's handle_click

    def _flood_fill_background(self, editor, background_surface, start_screen_pos, fill_color):
        """Perform flood fill on the background surface."""
        print("Background Fill - Not Implemented Yet")
        # TODO: Implement background fill logic
        # Needs to handle zoom/pan to convert screen coords to surface coords
        # Needs to handle potentially large surfaces efficiently
        pass

    def handle_click(self, editor, pos):
        if editor.edit_mode == 'monster':
            sprite_editor = editor._get_sprite_editor_at_pos(pos)
            if sprite_editor:
                grid_pos = sprite_editor.get_grid_position(pos)
                if grid_pos:
                    fill_color_rgba = editor.current_color # Use full RGBA
                    self._flood_fill_sprite(sprite_editor, grid_pos, fill_color_rgba)
        elif editor.edit_mode == 'background' and editor.canvas_rect and editor.current_background:
             if editor.canvas_rect.collidepoint(pos):
                 fill_color_rgb = editor.current_color[:3] # Use RGB for background
                 self._flood_fill_background(editor, editor.current_background, pos, fill_color_rgb)
        
    # Drag usually doesn't make sense for fill
    def handle_drag(self, editor, pos):
        pass 

# --- Paste Tool ---
class PasteTool(BaseTool):
    def __init__(self):
        super().__init__("Paste")

    def _apply_paste_sprite(self, editor, sprite_editor, top_left_grid_pos):
        """Pastes the editor's copy_buffer onto the sprite_editor frame."""
        if not editor.copy_buffer:
            print("Paste Error: Copy buffer is empty.")
            return

        start_x, start_y = top_left_grid_pos
        for (rel_x, rel_y), color in editor.copy_buffer.items():
            abs_x = start_x + rel_x
            abs_y = start_y + rel_y
            # Check bounds before attempting to draw
            if 0 <= abs_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= abs_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                # Only paste non-transparent pixels.
                if color[3] > 0:
                    sprite_editor.draw_pixel((abs_x, abs_y), color)
        print("Pasted selection.")
        # Paste mode typically allows multiple pastes until cancelled/switched
        # We might not want to deactivate immediately after one click.
        # This depends on desired UX. For now, clicking just pastes once.

    def _apply_paste_background(self, editor, background_surface, top_left_screen_pos):
        """Pastes the editor's copy_buffer onto the background frame."""
        print("Background Paste - Not Implemented Yet")
        # TODO: Implement background paste logic
        # Needs to handle zoom/pan for positioning
        # Needs to handle potentially different data in copy_buffer (if BG copy is added)
        pass

    def handle_click(self, editor, pos):
        if not editor.copy_buffer:
             print("Cannot paste: Copy buffer is empty.")
             editor.tool_manager.set_active_tool('draw') # Switch back to draw if buffer empty
             return
             
        if editor.edit_mode == 'monster':
            sprite_editor = editor._get_sprite_editor_at_pos(pos)
            if sprite_editor:
                grid_pos = sprite_editor.get_grid_position(pos)
                if grid_pos:
                    self._apply_paste_sprite(editor, sprite_editor, grid_pos)
                    # Optional: Deactivate paste mode after one paste? 
                    # editor.tool_manager.set_active_tool('draw') 
        elif editor.edit_mode == 'background' and editor.canvas_rect and editor.current_background:
             if editor.canvas_rect.collidepoint(pos):
                 self._apply_paste_background(editor, editor.current_background, pos)
                 # Optional: Deactivate paste mode after one paste?
                 # editor.tool_manager.set_active_tool('draw') 

    # Drag usually doesn't make sense for paste
    def handle_drag(self, editor, pos):
        pass


# --- Tool Manager ---
class ToolManager:
    def __init__(self, editor):
        self.editor = editor
        self.tools = {
            'draw': DrawTool(),
            'fill': FillTool(),    # <<< Add FillTool
            'paste': PasteTool(),   # <<< Add PasteTool
            # 'select': SelectionTool() # Selection might be managed differently
        }
        self.active_tool_name = 'draw' # Default tool
        self.active_tool = self.tools[self.active_tool_name]
        self.active_tool.activate(self.editor)

    def set_active_tool(self, tool_name):
        if tool_name in self.tools and tool_name != self.active_tool_name:
            if self.active_tool:
                self.active_tool.deactivate(self.editor)
            
            self.active_tool_name = tool_name
            self.active_tool = self.tools[tool_name]
            self.active_tool.activate(self.editor)
            print(f"Switched to {tool_name} tool") # Debug
            # Reset specific editor modes when switching tools
            # (This logic might need refinement based on tool interactions)
            self.editor.eraser_mode = False
            self.editor.fill_mode = False 
            self.editor.paste_mode = False
            if self.editor.mode == 'select': # Exit select mode if switching tool
                self.editor.mode = 'draw' 
                self.editor.selection.active = False
                self.editor.selection.selecting = False

    def handle_click(self, pos):
        if self.active_tool:
            # Need to pass the editor instance to the tool method
            self.active_tool.handle_click(self.editor, pos)

    def handle_drag(self, pos):
        if self.active_tool:
            # Need to pass the editor instance to the tool method
            self.active_tool.handle_drag(self.editor, pos)




================================================
File: src/editor/undo_redo_manager.py
================================================







================================================
File: src/ui/__init__.py
================================================
 


================================================
File: src/ui/ui_manager.py
================================================



================================================
File: tests/__init__.py
================================================



================================================
File: tests/_test_pixle_art_editor.py
================================================
import pytest
import pygame
import os
import shutil
from unittest.mock import patch, MagicMock, ANY
import colorsys
import unittest
import json
import tkinter as tk # Import tkinter to patch it

# --- Patch Tkinter Globally for Test Session --- 
# This prevents the tk.Tk() call in pixle_art_editor.py top-level from running
# when pytest imports the module.
@pytest.fixture(scope="session", autouse=True)
def patch_global_tkinter():
    # Create a mock object that behaves like a withdrawn Tk root
    mock_root = MagicMock(spec=tk.Tk)
    mock_root.withdraw = MagicMock()
    
    with patch('tkinter.Tk', return_value=mock_root) as mock_tk_global:
        print("DEBUG: Applied global tkinter.Tk patch for tests.")
        yield mock_tk_global # Provide the mock if needed, but primary goal is patching import
    print("DEBUG: Removed global tkinter.Tk patch.")
# --- End Global Patch --- 

# Adjust the path to import from the root directory
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.core import config
# Now import pixle_art_editor AFTER the global patch is set up by the fixture
from src.editor.pixle_art_editor import SpriteEditor, Editor, PALETTE
# Import EventHandler
from src.core.event_handler import EventHandler
# Import Button from editor_ui
from src.editor.editor_ui import Button 
# Import SelectionTool for patching
from src.editor.selection_manager import SelectionTool

# Pygame setup fixture (optional, but good practice)
@pytest.fixture(scope="session", autouse=True)
def pygame_setup():
    # Initialize Pygame minimally for surface creation etc.
    # Avoid full display init if possible
    pygame.init()
    yield
    pygame.quit()

# Fixture to create a temporary directory for test sprites
@pytest.fixture
def temp_sprite_dir(tmp_path):
    sprite_dir = tmp_path / "sprites"
    sprite_dir.mkdir()
    # Temporarily override the config SPRITE_DIR
    original_sprite_dir = config.SPRITE_DIR
    config.SPRITE_DIR = str(sprite_dir)
    yield str(sprite_dir)
    # Restore original config and clean up
    config.SPRITE_DIR = original_sprite_dir
    # No need to manually remove tmp_path contents, pytest handles it

# Fixture to create a temporary Editor instance (mocks problematic parts)
@pytest.fixture
def mock_editor(temp_sprite_dir):
    # Mock problematic parts to avoid GUI popups or complex setup during tests
    mock_monster_data = [{'name': 'TestMon', 'type': 'Test', 'max_hp': 10, 'moves': []}] # Define mock data
    with patch('src.editor.pixle_art_editor.Editor._get_background_files', return_value=['bg1.png', 'bg2.png'], create=True), \
         patch('src.editor.pixle_art_editor.load_monsters', return_value=mock_monster_data), \
         patch('pygame.display.set_mode', return_value=pygame.Surface((10, 10))), \
         patch('pygame.display.set_caption', return_value=None), \
         patch('pygame.font.Font', return_value=MagicMock(render=MagicMock(return_value=pygame.Surface((10, 10))))), \
         patch('src.editor.pixle_art_editor.tk.Tk') as mock_tk, \
         patch('src.editor.pixle_art_editor.filedialog.askopenfilename') as mock_askopenfilename, \
         patch('src.editor.pixle_art_editor.colorchooser.askcolor') as mock_askcolor:

        # Configure the tk.Tk mock if needed (e.g., mock withdraw method)
        mock_tk.return_value.withdraw = MagicMock()

        # --- Assign mock data to config BEFORE editor init --- 
        config.monsters = mock_monster_data 

        original_sprite_dir = config.SPRITE_DIR
        config.SPRITE_DIR = temp_sprite_dir
        try:
            # Mock load_backgrounds BEFORE Editor init if it affects choose_background_action logic
            with patch('src.editor.pixle_art_editor.Editor.load_backgrounds', return_value=[('existing_bg.png', pygame.Surface((10,10)))]) as mock_load_bgs:
                editor = Editor()
            # Initial state should be dialog_mode = 'choose_edit_mode'
            # edit_mode should be None
            # No buttons should be created yet
            
            # Attach mocks if needed for assertions later in tests
            editor.mock_tk = mock_tk
            editor.mock_askopenfilename = mock_askopenfilename
            editor.mock_askcolor = mock_askcolor
            yield editor
        finally:
            config.SPRITE_DIR = original_sprite_dir
            # Clean up config.monsters if necessary
            if hasattr(config, 'monsters'):
                 del config.monsters

# Helper function to simulate clicking a button in a list (UI or Dialog)
def simulate_button_click(editor, button_list, button_text):
    """Helper to simulate clicking a button within a SPECIFIC list."""
    target_button = None
    for btn in button_list: # Search ONLY the provided list
         if isinstance(btn, Button) and btn.text == button_text:
              target_button = btn
              break # Found it
              
    assert target_button is not None, f"Button '{button_text}' not found in the provided list for simulation."
    # Use the found button's rect center
    mock_event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=target_button.rect.center)
    editor.event_handler.process_event(mock_event)

# --- Tests for POKE-3 --- 

# TODO: Add tests for SpriteEditor load/save behavior BEFORE refactoring
def test_sprite_editor_save_current_behavior(mock_editor, temp_sprite_dir):
    """ 
    Tests the current (incorrect) save behavior where the sprite is scaled up.
    This test is expected to FAIL after POKE-3 is correctly implemented.
    """
    # Arrange
    sprite_editor = mock_editor.sprites['front'] # Get the front sprite editor
    # Directly use the mock monster name defined in the fixture
    monster_name = 'TestMon' 
    original_filepath = os.path.join(temp_sprite_dir, f"{monster_name}_front.png")

    # Create a dummy native-size sprite file to load
    dummy_surface = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
    dummy_surface.fill((10, 20, 30, 255)) # Use a distinct color
    pygame.image.save(dummy_surface, original_filepath)

    # Act
    sprite_editor.load_sprite(monster_name) # Load the dummy sprite
    # Manually set the editor's current monster index for saving
    mock_editor.current_monster_index = 0 
    # Patch the global `monsters` variable specifically for the save call
    mock_monster_data = [{'name': monster_name, 'type': 'Test', 'max_hp': 10, 'moves': []}]
    with patch('src.editor.pixle_art_editor.monsters', mock_monster_data):
        # Pass monster_name to save_sprite
        sprite_editor.save_sprite(monster_name) # Save (this is the method being tested)

    # Assert - Check the dimensions of the *saved* file
    # The current save_sprite scales UP, so the saved file should NOT match native res
    saved_surface = pygame.image.load(original_filepath).convert_alpha()
    
    # Calculate the expected (incorrect) scaled-up size
    # This depends on how save_sprite worked *before* POKE-3 (it doesn't scale anymore)
    # Let's assume the old behavior saved at native resolution (as it should now)
    # If the old behavior *did* scale up, this assertion would need to change.
    expected_dimensions = config.NATIVE_SPRITE_RESOLUTION 
    # We actually want to assert the current (correct) behavior here to see if it passes *now*
    # This test name is slightly misleading now, it tests the *desired* behavior.
    assert saved_surface.get_size() == expected_dimensions, \
           f"Saved sprite should have native dimensions {expected_dimensions}, but got {saved_surface.get_size()}"
    
    # Optional: Check content if needed (e.g., check a pixel color)
    assert saved_surface.get_at((0, 0)) == (10, 20, 30, 255), "Pixel color mismatch"


# TODO: Add tests for SpriteEditor load/save behavior AFTER refactoring

def test_sprite_editor_load_behavior(mock_editor, temp_sprite_dir):
    """Tests that load_sprite stores the image at native resolution in self.frame."""
    # Arrange
    sprite_editor = mock_editor.sprites['front']
    monster_name = 'TestMon'
    filepath = os.path.join(temp_sprite_dir, f"{monster_name}_front.png")

    # Create a sprite file with native resolution
    native_surface = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
    native_surface.fill((50, 100, 150, 200))
    pygame.image.save(native_surface, filepath)

    # Act
    sprite_editor.load_sprite(monster_name)

    # Assert
    assert sprite_editor.frame.get_size() == config.NATIVE_SPRITE_RESOLUTION, \
           f"Frame buffer should have native dimensions {config.NATIVE_SPRITE_RESOLUTION}, but got {sprite_editor.frame.get_size()}"
    assert sprite_editor.frame.get_at((0, 0)) == (50, 100, 150, 200), "Pixel color mismatch in frame buffer"

def test_sprite_editor_load_scales_down(mock_editor, temp_sprite_dir):
    """Tests that load_sprite scales down an oversized image to native resolution."""
    # Arrange
    sprite_editor = mock_editor.sprites['front']
    monster_name = 'TestMon'
    filepath = os.path.join(temp_sprite_dir, f"{monster_name}_front.png")

    # Create an oversized sprite file
    oversized_dims = (config.NATIVE_SPRITE_RESOLUTION[0] * 2, config.NATIVE_SPRITE_RESOLUTION[1] * 2)
    oversized_surface = pygame.Surface(oversized_dims, pygame.SRCALPHA)
    oversized_surface.fill((255, 0, 0, 255))
    pygame.image.save(oversized_surface, filepath)

    # Act
    sprite_editor.load_sprite(monster_name) # This should print a warning

    # Assert
    assert sprite_editor.frame.get_size() == config.NATIVE_SPRITE_RESOLUTION, \
           f"Frame buffer should be scaled down to native {config.NATIVE_SPRITE_RESOLUTION}, but got {sprite_editor.frame.get_size()}"
    # Note: Checking pixel color after scaling might be unreliable due to smoothscale interpolation.
    # We primarily care about the dimensions here.

# --- Tests for POKE-21 (Tool Activation Bug) ---

def find_button(editor, text):
    """Helper to find a button by its text."""
    for button in editor.buttons:
        # Handle cases where button text might change (e.g., "Eraser" / "Brush")
        if button.text.startswith(text):
            return button
    return None

def simulate_monster_mode_choice(editor):
    """Helper to simulate choosing 'Monster' mode from the initial dialog."""
    if editor.dialog_mode == 'choose_edit_mode':
        monster_option = next((opt for opt in editor.dialog_options if opt.text == "Monster"), None)
        assert monster_option is not None, "(Helper) Monster dialog option not found"
        editor._handle_dialog_choice(monster_option.value)
        assert editor.edit_mode == 'monster', "(Helper) Failed to set monster mode"
        assert editor.dialog_mode is None, "(Helper) Dialog mode not cleared after monster choice"

def test_toggle_eraser_mode(mock_editor):
    """Tests toggling the eraser mode via its button."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    eraser_button = find_button(editor, "Eraser")
    assert eraser_button is not None, "Eraser button not found (after mode choice)"

    # Initial state check (after mode choice, should be False)
    assert not editor.eraser_mode

    # Click 1: Activate Eraser
    click_pos = eraser_button.rect.center
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert editor.eraser_mode, "Eraser mode should be True after first click"
    assert not editor.fill_mode, "Fill mode should be False when Eraser is active"

    # Click 2: Deactivate Eraser
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert not editor.eraser_mode, "Eraser mode should be False after second click"

def test_toggle_fill_mode(mock_editor):
    """Tests toggling the fill mode via its button."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    fill_button = find_button(editor, "Fill")
    assert fill_button is not None, "Fill button not found (after mode choice)"

    # Initial state check
    assert not editor.fill_mode

    # Click 1: Activate Fill
    click_pos = fill_button.rect.center
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert editor.fill_mode, "Fill mode should be True after first click"
    assert not editor.eraser_mode, "Eraser mode should be False when Fill is active"

    # Click 2: Deactivate Fill
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert not editor.fill_mode, "Fill mode should be False after second click"

def test_tool_persistence_on_canvas_click(mock_editor):
    """Tests if Eraser/Fill mode persists after clicking the canvas (BUG FIX TEST)."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    eraser_button = find_button(editor, "Eraser")
    fill_button = find_button(editor, "Fill")
    assert eraser_button is not None # Re-assert after mode choice
    assert fill_button is not None
    sprite_editor_rect = editor.sprites['front'].frame.get_rect(topleft=editor.sprites['front'].position)
    canvas_click_pos = sprite_editor_rect.center

    # Test Eraser Persistence
    editor.eraser_mode = False # Ensure starting state
    event_eraser = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': eraser_button.rect.center})
    editor.handle_event(event_eraser)
    assert editor.eraser_mode, "Eraser should be active after button click"
    # Simulate click on canvas *after* activating tool
    event_canvas = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': canvas_click_pos})
    editor.handle_event(event_canvas)
    assert editor.eraser_mode, "BUG: Eraser mode deactivated after clicking canvas"

    # Test Fill Persistence
    editor.fill_mode = False # Ensure starting state
    editor.eraser_mode = False # Ensure eraser is off
    event_fill = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': fill_button.rect.center})
    editor.handle_event(event_fill)
    assert editor.fill_mode, "Fill should be active after button click"
    # Simulate click on canvas *after* activating tool
    event_canvas = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': canvas_click_pos})
    editor.handle_event(event_canvas)
    assert editor.fill_mode, "BUG: Fill mode deactivated after clicking canvas"

def test_tool_deactivation_on_palette_click(mock_editor):
    """Tests if Eraser/Fill mode deactivates correctly when palette is clicked."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    eraser_button = find_button(editor, "Eraser")
    fill_button = find_button(editor, "Fill")
    assert eraser_button is not None # Re-assert
    assert fill_button is not None
    # Use a known palette color for the direct call (use global PALETTE)
    test_color = PALETTE[1] if len(PALETTE) > 1 else PALETTE[0]

    # Test Eraser Deactivation
    editor.eraser_mode = False
    # Activate eraser via button click simulation
    event_eraser = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': eraser_button.rect.center})
    editor.handle_event(event_eraser) # Activate eraser
    assert editor.eraser_mode, "Eraser should be active after button click"

    # Directly call select_color instead of simulating palette click event
    print(f"Directly calling select_color({test_color})")
    editor.select_color(test_color) # Directly select a color

    # Assert deactivation after direct call
    assert not editor.eraser_mode, "FAIL: Eraser mode should deactivate after DIRECTLY calling select_color"

    # Test Fill Deactivation
    editor.fill_mode = False
    editor.eraser_mode = False # Ensure eraser is off
    # Activate fill via button click simulation
    event_fill = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': fill_button.rect.center})
    editor.handle_event(event_fill) # Activate fill
    assert editor.fill_mode, "Fill should be active after button click"

    # Directly call select_color instead of simulating palette click event
    print(f"Directly calling select_color({test_color}) for fill test")
    editor.select_color(test_color) # Directly select a color

    # Assert deactivation after direct call
    assert not editor.fill_mode, "FAIL: Fill mode should deactivate after DIRECTLY calling select_color"

def test_placeholder():
    """Placeholder test to ensure the file runs."""
    assert True

# --- Tests for POKE-9 (Dialog System) ---

def test_editor_starts_in_choose_mode_dialog(mock_editor):
    """Tests that the editor starts in the correct initial dialog mode."""
    editor = mock_editor
    # Editor.__init__ calls choose_edit_mode(), which sets the dialog state
    assert editor.dialog_mode == 'choose_edit_mode', "Editor should start in choose_edit_mode dialog"
    assert editor.edit_mode is None, "Editor should start with no edit mode selected"
    assert editor.dialog_callback is not None, "Dialog callback should be set"
    assert len(editor.dialog_options) == 2, "Should have two dialog options"

def test_choose_edit_mode_monster(mock_editor):
    """
    Tests selecting 'Monster' from the initial edit mode dialog.
    Ensures it sets the edit_mode correctly, clears the dialog,
    and creates the appropriate UI buttons.
    """
    editor = mock_editor
    # Editor starts in 'choose_edit_mode' dialog (verified by test_editor_starts_in_choose_mode_dialog)
    assert editor.dialog_mode == 'choose_edit_mode'
    assert editor.edit_mode is None
    assert len(editor.dialog_options) == 2

    # Find the 'Monster' option in the dialog options
    monster_option = next((opt for opt in editor.dialog_options if opt.text == "Monster"), None)
    assert monster_option is not None, "Monster dialog option not found"

    # Simulate choosing the 'Monster' option by directly calling the handler
    # This bypasses event processing and directly tests the choice logic
    editor._handle_dialog_choice(monster_option.value) # value should be 'monster'

    # Assert the state AFTER the choice and callback (_set_edit_mode_and_continue)
    assert editor.edit_mode == 'monster', "Edit mode should be set to 'monster'"
    assert editor.dialog_mode is None, "Dialog mode should be cleared"
    assert editor.dialog_options == [], "Dialog options should be cleared"
    assert editor.dialog_callback is None, "Dialog callback should be cleared"

    # Assert that the correct UI buttons for monster mode are now present
    button_texts = {btn.text for btn in editor.buttons}
    # Define expected buttons more accurately based on create_buttons logic for monster mode
    expected_buttons = {
        "Save", "Load", "Clear", "Color Picker", "Eraser", "Fill", "Select",
        "Copy", "Paste", "Mirror", "Rotate", "Undo", "Redo", "Load Ref Img",
        "Clear Ref Img", "Prev Monster", "Next Monster", "Switch Sprite"
    }
    missing_buttons = expected_buttons - button_texts
    extra_buttons = button_texts - expected_buttons
    assert not missing_buttons, f"Missing expected monster mode buttons: {missing_buttons}"
    assert not extra_buttons, f"Found unexpected buttons: {extra_buttons}"

    # Also check that the sprite editors were initialized (part of monster mode setup)
    assert 'front' in editor.sprites
    assert 'back' in editor.sprites
    # Ensure current_sprite is set (might be 'front' by default in load_monster)
    assert editor.current_sprite is not None 


def test_choose_edit_mode_background_leads_to_action_dialog(mock_editor):
    """
    Tests selecting 'Background' from the initial edit mode dialog.
    Ensures it clears the initial dialog and presents the 'new'/'edit' background dialog.
    """
    editor = mock_editor
    # Editor starts in 'choose_edit_mode' dialog
    assert editor.dialog_mode == 'choose_edit_mode'
    assert editor.edit_mode is None
    assert len(editor.dialog_options) == 2

    # Find the 'Background' option
    background_option = next((opt for opt in editor.dialog_options if opt.text == "Background"), None)
    assert background_option is not None, "Background dialog option not found"

    # Simulate choosing the 'Background' option
    # No need to patch _get_background_files here now, load_backgrounds is mocked
    editor._handle_dialog_choice(background_option.value) # value should be 'background'

    # Assert the state AFTER the choice and callback (_set_edit_mode_and_continue)
    assert editor.edit_mode == 'background', "Edit mode should be set to 'background'"
    # Choosing background should lead to 'choose_bg_action' because load_backgrounds was mocked
    assert editor.dialog_mode == 'choose_bg_action', "Should be in the 'choose_bg_action' dialog"
    assert editor.dialog_callback is not None, "A new dialog callback should be set"
    assert len(editor.dialog_options) == 2, "Should have two options (New, Edit Existing)"
    option_texts = {opt.text for opt in editor.dialog_options}
    assert option_texts == {"New", "Edit Existing"}, "Dialog options should be 'New' and 'Edit Existing'"
    button_texts = {btn.text for btn in editor.buttons}
    assert "Save" not in button_texts, "Main UI buttons should not be created yet"


@patch('os.path.exists', return_value=False) # Assume background file does NOT exist
def test_choose_background_action_new_leads_to_input(mock_exists, mock_editor):
    """
    Tests choosing 'New' from the background action dialog when no file exists.
    Simulates: Initial Dialog -> Background -> New -> Input Dialog.
    """
    editor = mock_editor
    # Ensure backgrounds list is empty for this specific test path
    editor.backgrounds = []
    editor.current_background_index = -1 # Ensure index reflects empty list

    # 1. Simulate getting into background mode first
    editor.dialog_mode = 'choose_edit_mode' # Reset to initial state if needed
    editor.edit_mode = None
    editor.choose_edit_mode() # Set up the initial dialog state again
    background_option = next((opt for opt in editor.dialog_options if opt.text == "Background"), None)
    assert background_option is not None
    editor._handle_dialog_choice(background_option.value)

    # State check: Should directly go to 'input_text' because backgrounds is empty
    print(f"DEBUG TEST: editor.dialog_mode = {editor.dialog_mode}")
    assert editor.dialog_mode == 'input_text', "Should be in 'input_text' dialog mode because no backgrounds exist"
    assert editor.edit_mode == 'background' # edit_mode is set before choose_background_action

    # Check prompt and default text
    assert editor.dialog_prompt == "Enter filename for new background (.png):"
    assert editor.dialog_input_text == "new_background.png"
    assert editor.dialog_callback == editor._create_new_background_callback, "Incorrect callback for new background input"
    option_texts = {opt.text for opt in editor.dialog_options}
    assert option_texts == {"Save", "Cancel"}, "Input dialog options incorrect"
    button_texts = {btn.text for btn in editor.buttons}
    assert "Save" not in button_texts, "Main UI buttons should not be created yet"


@patch('pygame.image.save') # Mock save to avoid actual file writing
def test_input_text_dialog_save(mock_save, mock_editor):
    """Tests clicking OK in the input text dialog (e.g., for new background name)."""
    editor = mock_editor
    # Background mode needs to be set for create_buttons to work correctly in the callback
    editor.edit_mode = 'background' 
    editor.dialog_mode = 'input_text'
    editor.input_prompt = "Test Prompt"
    editor.input_text = "test_name"
    editor.dialog_callback = editor._create_new_background_callback
    editor.dialog_options = [
        Button((0,0, 50, 30), "Save", value="test_name"),
        Button((0,0, 50, 30), "Cancel", value=None)
    ]
    save_button = next((opt for opt in editor.dialog_options if opt.text == "Save"), None)
    assert save_button is not None
    editor._handle_dialog_choice(save_button.value)
    mock_save.assert_called_once()
    expected_save_path = os.path.join(config.BACKGROUND_DIR, "test_name.png")
    saved_path_arg = mock_save.call_args[0][1] # Correct index for filename
    assert isinstance(saved_path_arg, str), f"Expected filename string, got {type(saved_path_arg)}"
    assert os.path.normpath(saved_path_arg) == os.path.normpath(expected_save_path), \
           f"Saved path mismatch. Expected {expected_save_path}, got {saved_path_arg}"
    assert editor.dialog_mode is None
    assert editor.dialog_options == []
    assert editor.dialog_callback is None
    # Assert edit_mode is now correctly set
    assert editor.edit_mode == 'background' 
    button_texts = {btn.text for btn in editor.buttons}
    assert "Save" in button_texts # Should now have background buttons
    assert editor.current_background is not None

def test_input_text_dialog_cancel(mock_editor):
    """Tests clicking Cancel in the input text dialog."""
    editor = mock_editor
    editor.dialog_mode = 'input_text'
    editor.input_prompt = "Test Prompt"
    editor.input_text = "some_text" 
    editor.dialog_callback = MagicMock() # Callback not called on cancel
    editor.dialog_options = [
        Button((0,0, 50, 30), "Save", value="some_text"),
        Button((0,0, 50, 30), "Cancel", value=None)
    ]
    cancel_button = next((opt for opt in editor.dialog_options if opt.text == "Cancel"), None)
    assert cancel_button is not None
    editor._handle_dialog_choice(cancel_button.value)

    # Dialog should be cleared
    assert editor.dialog_mode is None
    # Assert that the callback attribute is now None
    assert editor.dialog_callback is None, "Callback should be cleared on cancel"
    assert editor.dialog_input_text == "", "Dialog input text should be cleared on cancel"

@pytest.mark.skip(reason="Skipping tests that trigger native file dialog via button")
def test_load_background_dialog_trigger(mock_editor):
    # This test clicks the main "Load" button which internally calls trigger_load_background_dialog
    # which might eventually call _ensure_tkinter_root if not fully Pygame UI.
    # Skip for now to avoid Tkinter issues.
    pass

@pytest.mark.skip(reason="Skipping tests involving native file dialog interactions")
def test_file_select_dialog_load(mock_editor):
    # This test directly manipulates dialog state related to file loading
    # and simulates button clicks that rely on the mocked filedialog.
    # Skip for now.
    pass

@pytest.mark.skip(reason="Skipping tests involving native file dialog interactions")
def test_file_select_dialog_cancel(mock_editor):
    # Similar to above, skip for now.
    pass

@pytest.mark.skip(reason="Skipping tests that trigger native color picker")
def test_color_picker_dialog_trigger(mock_editor):
    # This test simulates clicking the 'Color Picker' button, which calls open_color_picker,
    # which calls _ensure_tkinter_root, triggering the problematic tk.Tk()
    editor = mock_editor
    editor.dialog_mode = None # Ensure no dialog active

    picker_button = find_button(editor, "Color Picker")
    assert picker_button is not None
    # This click would eventually call tk.Tk() via _ensure_tkinter_root
    # simulate_button_click(editor, [picker_button], "Color Picker") # Skip the click
    
    # Instead assert that the button exists, skipping the interaction part
    assert True # Replace with skip or remove test if button doesn't exist anymore

@pytest.mark.skip(reason="Skipping tests involving native color picker interactions")
def test_color_picker_dialog_ok(mock_editor):
    # Skip for now
    pass

@pytest.mark.skip(reason="Skipping tests involving native color picker interactions")
def test_color_picker_dialog_cancel(mock_editor):
    # Skip for now
    pass

# --- Test Reference Image Feature (Modify/Skip) ---

class TestReferenceImage(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Ensure necessary directories exist before tests run
        os.makedirs(config.SPRITE_DIR, exist_ok=True)
        os.makedirs(config.BACKGROUND_DIR, exist_ok=True)
        os.makedirs(config.DATA_DIR, exist_ok=True)
        # Ensure test assets dir exists (though created earlier)
        os.makedirs(os.path.join("tests", "assets"), exist_ok=True)
        # Create dummy monster/moves data if needed for Editor init
        if not os.path.exists(os.path.join(config.DATA_DIR, 'monsters.json')):
            with open(os.path.join(config.DATA_DIR, 'monsters.json'), 'w') as f:
                json.dump([{"name": "TestMon", "type": "Normal", "max_hp": 100, "attack": 10, "defense": 10, "moves": []}], f)
        # Add dummy moves.json if needed

    def setUp(self):
        """Set up a fresh Editor instance for each test.
           REMOVED patches here, apply them per test method.
        """
        # Basic editor setup without problematic patches
        # Mock choose_edit_mode directly during init maybe?
        # Or just manually set states after init.
        with patch('src.editor.pixle_art_editor.tk.Tk', return_value=mock_root), \
             patch('src.editor.pixle_art_editor.Editor.choose_edit_mode', return_value='monster'), \
             patch('src.editor.pixle_art_editor.load_monsters', return_value=[{"name": "TestMon", "type": "Normal", "max_hp": 100, "attack": 10, "defense": 10, "moves": []}]), \
             patch('pygame.image.load', side_effect=self.mock_pygame_load_basic): # Basic mock for init
                 self.editor = Editor()

        # Manually set required states after init
        self.editor.edit_mode = 'monster'
        self.editor.sprites = {
            'front': SpriteEditor((0, 0), 'front', config.SPRITE_DIR),
            'back': SpriteEditor((100, 0), 'back', config.SPRITE_DIR)
        }
        self.editor.current_sprite = 'front'
        # Resetting global mock is no longer needed here
        # mock_filedialog.reset_mock()
        # mock_filedialog.askopenfilename.reset_mock()

    def mock_pygame_load_basic(self, path):
        """Basic mock for pygame load used during setup, returns dummy surface."""
        return pygame.Surface((config.NATIVE_SPRITE_RESOLUTION[0], config.NATIVE_SPRITE_RESOLUTION[1]), pygame.SRCALPHA)

    def mock_pygame_load_for_ref_test(self, path):
        """Specific mock for pygame load used in reference image tests."""
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        if path == test_image_path:
            surf = pygame.Surface((16, 16), pygame.SRCALPHA)
            surf.fill((100, 150, 200, 255))
            return surf
        else:
            # For sprite loading during these specific tests
            return pygame.Surface((config.NATIVE_SPRITE_RESOLUTION[0], config.NATIVE_SPRITE_RESOLUTION[1]), pygame.SRCALPHA)

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_load_reference_image(self, mock_load, mock_filedialog_arg):
        """Test loading a reference image."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path

        self.assertIsNone(self.editor.reference_image)
        self.assertIsNone(self.editor.scaled_reference_image)
        self.assertIsNone(self.editor.reference_image_path)

        self.editor.load_reference_image()

        # Assert call on the mock passed as argument
        mock_filedialog_arg.askopenfilename.assert_called_once()
        mock_load.assert_called_with(test_image_path)
        self.assertIsNotNone(self.editor.reference_image, "Reference image should be loaded")
        self.assertIsNotNone(self.editor.scaled_reference_image, "Scaled reference image should exist after load")
        self.assertEqual(self.editor.reference_image_path, test_image_path)
        self.assertNotEqual(self.editor.reference_image.get_size(), 
                          self.editor.scaled_reference_image.get_size(),
                          "Original and scaled images should have different sizes due to scaling")
        self.assertEqual(self.editor.scaled_reference_image.get_width(), 
                         self.editor.sprites['front'].display_width,
                         "Scaled image width should match editor display width")

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_clear_reference_image(self, mock_load, mock_filedialog_arg):
        """Test clearing the loaded reference image."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        # First, load an image (patches are active)
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path
        self.editor.load_reference_image()
        self.assertIsNotNone(self.editor.reference_image)

        # Now, clear it
        self.editor.clear_reference_image()
        self.assertIsNone(self.editor.reference_image, "Reference image should be None after clear")
        self.assertIsNone(self.editor.scaled_reference_image, "Scaled reference image should be None after clear")
        self.assertIsNone(self.editor.reference_image_path, "Reference image path should be None after clear")

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_set_reference_alpha(self, mock_load, mock_filedialog_arg):
        """Test setting the alpha value."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        initial_alpha = self.editor.reference_alpha
        
        # Load image first (patches are active)
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path
        self.editor.load_reference_image()
        self.assertIsNotNone(self.editor.scaled_reference_image, "Scaled image needed for alpha test")

        # Test setting valid alpha
        test_alpha = 50
        self.editor.set_reference_alpha(test_alpha)
        self.assertEqual(self.editor.reference_alpha, test_alpha)
        self.assertEqual(self.editor.scaled_reference_image.get_alpha(), test_alpha, "Surface alpha should match set alpha")

        # Test clamping (below 0)
        self.editor.set_reference_alpha(-100)
        self.assertEqual(self.editor.reference_alpha, 0)
        self.assertEqual(self.editor.scaled_reference_image.get_alpha(), 0)
        
        # Test clamping (above 255)
        self.editor.set_reference_alpha(500)
        self.assertEqual(self.editor.reference_alpha, 255)
        self.assertEqual(self.editor.scaled_reference_image.get_alpha(), 255)

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_alpha_slider_interaction(self, mock_load, mock_filedialog_arg):
        """Simulate interacting with the alpha slider."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        # Load image first (patches are active)
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path
        self.editor.load_reference_image()
        self.assertIsNotNone(self.editor.scaled_reference_image)

        slider_rect = self.editor.ref_alpha_slider_rect
        knob_rect = self.editor.ref_alpha_knob_rect
        slider_width_effective = slider_rect.width - knob_rect.width
        if slider_width_effective <= 0: slider_width_effective = 1 # Prevent division by zero

        # Simulate clicking near the start (should result in low alpha)
        click_pos_start = (slider_rect.x + 5, slider_rect.centery)
        event_down_start = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos_start})
        self.editor.handle_event(event_down_start)
        self.assertTrue(self.editor.adjusting_alpha)
        expected_alpha_start = int((5 / slider_width_effective) * 255)
        self.assertEqual(self.editor.reference_alpha, max(0, min(255, expected_alpha_start)))
        
        # Simulate dragging near the end (should result in high alpha)
        drag_pos_end = (slider_rect.right - 5, slider_rect.centery)
        event_motion_end = pygame.event.Event(pygame.MOUSEMOTION, {'buttons': (1, 0, 0), 'pos': drag_pos_end})
        self.editor.handle_event(event_motion_end)
        expected_alpha_end = int(((slider_rect.width - 5) / slider_width_effective) * 255)
        self.assertEqual(self.editor.reference_alpha, max(0, min(255, expected_alpha_end)))

        # Simulate releasing the mouse
        event_up_end = pygame.event.Event(pygame.MOUSEBUTTONUP, {'button': 1, 'pos': drag_pos_end})
        self.editor.handle_event(event_up_end)
        self.assertFalse(self.editor.adjusting_alpha)

# --- Tests for EventHandler (Should mostly pass now) ---

@pytest.fixture
def event_handler(mock_editor):
    """Fixture to get the EventHandler instance."""
    # Access the handler created within the mocked editor
    return mock_editor.event_handler

class TestEventHandler:
    # Test methods use event_handler fixture
    def test_mouse_down_left_on_button(self, event_handler, mock_editor):
        """Test clicking a UI button calls its action."""
        editor = mock_editor
        simulate_monster_mode_choice(editor)

        mock_button_action = MagicMock()
        # Find a real button and assign the mock action
        # Use 'Clear' button for simplicity
        target_button = find_button(editor, "Clear")
        assert target_button is not None, "Could not find 'Clear' button to test"
        original_action = target_button.action
        target_button.action = mock_button_action

        mock_event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=target_button.rect.center)

        # The handler should process the event and call the button's action
        result = event_handler.process_event(mock_event)

        assert result is True # Event should be handled
        mock_button_action.assert_called_once()

        # Restore original action (optional, good practice)
        target_button.action = original_action

    def test_select_button_then_canvas_click_no_crash(self, event_handler, mock_editor):
        """Tests clicking Select button then clicking canvas starts selection."""
        editor = mock_editor
        simulate_monster_mode_choice(editor)
        select_button = find_button(editor, "Select")
        assert select_button is not None, "Select button not found (after mode choice)"

        # Click Select Button -> sets mode='select', selection.selecting=True
        event_button = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=select_button.rect.center)
        event_handler.process_event(event_button)
        assert editor.mode == 'select'
        assert editor.selection.selecting is True, "Toggle should set selecting=True"
        assert editor.selection.start_pos is None, "Start pos should be None after toggle"

        # Click Canvas -> should call selection.start
        canvas_pos = editor.sprites['front'].position
        event_canvas = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=canvas_pos)

        try:
            # Patch get_grid_position, but NOT selection.start
            with patch.object(editor.sprites['front'], 'get_grid_position', return_value=(5,5)) as mock_grid_pos:
                event_handler.process_event(event_canvas)
            
            # Assert that selection has started correctly
            assert editor.selection.start_pos == (5,5), "Selection start_pos not set correctly"
            assert editor.selection.end_pos == (5,5), "Selection end_pos not set correctly"
            # selecting flag remains True during the drag
            assert editor.selection.selecting is True, "Selection selecting flag should remain True"
            assert editor.selection.active is False, "Selection active flag should be False until mouse up"
        except TypeError as e:
            pytest.fail(f"TypeError occurred during canvas click after selecting: {e}")
        except Exception as e:
             pytest.fail(f"An unexpected error occurred: {e}")

    def test_select_button_does_not_start_selection(self, event_handler, mock_editor):
        """Tests that clicking the Select button ONLY changes mode, doesn't call selection.start."""
        editor = mock_editor
        simulate_monster_mode_choice(editor)
        select_button = find_button(editor, "Select")
        assert select_button is not None, "Select button not found (after mode choice)"

        # Patch the start method of the specific selection instance
        with patch.object(editor.selection, 'start', wraps=editor.selection.start) as mock_selection_start:
            # Click Select Button
            event_button = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=select_button.rect.center)
            event_handler.process_event(event_button)

            # Assert mode changed but start was NOT called by this event
            assert editor.mode == 'select'
            mock_selection_start.assert_not_called()

    # ... rest of TestEventHandler tests ...

# --- Tests for Editor Drawing --- 

@patch('pygame.display.flip') # Mock flip as it's called in run loop
@patch('pygame.event.get', return_value=[pygame.event.Event(pygame.QUIT)]) # Mock events
class TestEditorDrawing:

    def test_draw_ui_calls_selection_draw_correctly(self, mock_event_get, mock_flip, mock_editor):
        """Tests if Editor.draw_ui calls SelectionTool.draw with correct arguments in select mode."""
        editor = mock_editor
        # Set editor to monster mode and ensure dialog is cleared
        simulate_monster_mode_choice(editor)
        editor.mode = 'select' # Now set select mode
        editor.current_sprite = 'front' # Ensure a current sprite is set
        # Ensure selection is active for draw to be called
        editor.selection.active = True
        editor.selection.rect = pygame.Rect(1,1,2,2) # Needs a non-zero rect

        # Get the expected position
        active_sprite_editor = editor.sprites.get(editor.current_sprite)
        assert active_sprite_editor is not None
        expected_position = active_sprite_editor.position

        # Patch the draw method on the specific instance editor.selection
        with patch.object(editor.selection, 'draw') as mock_selection_draw:
            # Call draw_ui
            editor.draw_ui()

            # Assert that SelectionTool.draw was called
            mock_selection_draw.assert_called_once()

            # Get the arguments passed to the mock
            args, kwargs = mock_selection_draw.call_args
            
            # Assert the arguments
            assert isinstance(args[0], pygame.Surface) # Check screen surface
            assert args[1] == expected_position # Check sprite position

# --- Tests for Tkinter Initialization and Usage --- 

@patch('tkinter.Tk') # Mock Tkinter root creation
class TestTkinterIntegration:

    # Test that ensures _ensure_tkinter_root doesn't crash when tk_root is mocked
    def test_ensure_tkinter_root_no_crash_mocked(self, mock_tk, mock_editor):
        """Tests _ensure_tkinter_root executes without error when Tk is mocked."""
        editor = mock_editor
        try:
            # Simulate the global root having been mocked successfully (or failed gracefully)
            # The fixture likely already handles this, but we call the check method
            result = editor._ensure_tkinter_root()
            # We expect True if the global mock worked, or False if it failed gracefully
            # The main point is no crash occurs here.
            assert isinstance(result, bool)
        except Exception as e:
            pytest.fail(f"_ensure_tkinter_root raised an unexpected exception: {e}")

    # Test calling open_color_picker (mocks the actual dialog)
    @patch('src.editor.pixle_art_editor.colorchooser.askcolor')
    def test_open_color_picker_no_crash(self, mock_askcolor, mock_tk, mock_editor):
        """Tests calling open_color_picker doesn't crash (dialog is mocked)."""
        editor = mock_editor
        # Assume global tk_root mock setup worked via fixture
        
        # ---> Configure the mock return value <---
        mock_askcolor.return_value = ((100, 150, 200), '#6496c8') # Example valid return

        try:
            editor.open_color_picker()
            # Assert the mocked askcolor was called (ensures the function ran)
            mock_askcolor.assert_called_once()
        except Exception as e:
            pytest.fail(f"open_color_picker raised an unexpected exception: {e}")

    # Test calling load_reference_image (mocks the actual dialog)
    @patch('src.editor.pixle_art_editor.filedialog.askopenfilename')
    def test_load_reference_image_no_crash(self, mock_askopenfilename, mock_tk, mock_editor):
        """Tests calling load_reference_image doesn't crash (dialog is mocked)."""
        editor = mock_editor
        # Assume global tk_root mock setup worked via fixture

        try:
            editor.load_reference_image()
             # Assert the mocked askopenfilename was called
            mock_askopenfilename.assert_called_once()
        except Exception as e:
            pytest.fail(f"load_reference_image raised an unexpected exception: {e}")

# --- Tests for Selection Logic --- 

def test_selection_click_drag_release(mock_editor):
    """Tests the click-drag-release sequence for making a selection."""
    editor = mock_editor
    simulate_monster_mode_choice(editor) # Get into monster mode
    
    # Find the Select button and click it
    select_button = find_button(editor, "Select")
    assert select_button is not None, "Select button not found"
    event_button = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=select_button.rect.center)
    editor.handle_event(event_button)
    assert editor.mode == 'select', "Editor should be in select mode"
    assert editor.selection.selecting is True, "SelectionTool should be in selecting state after toggle"
    assert editor.selection.active is False, "Selection should not be active initially"

    # Simulate mouse down on canvas (start selection drag)
    start_grid_pos = (5, 10)
    start_screen_pos = (editor.sprites['front'].position[0] + start_grid_pos[0] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2,
                          editor.sprites['front'].position[1] + start_grid_pos[1] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2)
    with patch.object(editor.sprites['front'], 'get_grid_position', return_value=start_grid_pos):
        event_down = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=start_screen_pos)
        editor.handle_event(event_down)
    
    assert editor.selection.start_pos == start_grid_pos, f"Selection start_pos mismatch after down. Got {editor.selection.start_pos}"
    assert editor.selection.end_pos == start_grid_pos, f"Selection end_pos mismatch after down. Got {editor.selection.end_pos}"
    assert editor.selection.selecting is True, "SelectionTool should still be selecting during drag"
    assert editor.selection.active is False, "Selection should not be active during drag"
    expected_rect_down = pygame.Rect(start_grid_pos[0], start_grid_pos[1], 1, 1)
    assert editor.selection.rect == expected_rect_down, f"Selection rect incorrect after down. Got {editor.selection.rect}"

    # Simulate mouse motion (dragging)
    drag_grid_pos = (15, 20)
    drag_screen_pos = (editor.sprites['front'].position[0] + drag_grid_pos[0] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2,
                         editor.sprites['front'].position[1] + drag_grid_pos[1] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2)
    with patch.object(editor.sprites['front'], 'get_grid_position', return_value=drag_grid_pos):
        event_motion = pygame.event.Event(pygame.MOUSEMOTION, buttons=(1, 0, 0), pos=drag_screen_pos)
        editor.handle_event(event_motion)

    assert editor.selection.start_pos == start_grid_pos, "Selection start_pos should not change during drag"
    assert editor.selection.end_pos == drag_grid_pos, f"Selection end_pos mismatch after drag. Got {editor.selection.end_pos}"
    assert editor.selection.selecting is True, "SelectionTool should still be selecting during drag"
    assert editor.selection.active is False, "Selection should not be active during drag"
    expected_rect_drag = pygame.Rect(start_grid_pos[0], start_grid_pos[1], 
                                     drag_grid_pos[0] - start_grid_pos[0] + 1,
                                     drag_grid_pos[1] - start_grid_pos[1] + 1)
    assert editor.selection.rect == expected_rect_drag, f"Selection rect incorrect after drag. Got {editor.selection.rect}"

    # Simulate mouse up (end selection drag)
    end_grid_pos = (18, 22) # Can be slightly different from last motion pos
    end_screen_pos = (editor.sprites['front'].position[0] + end_grid_pos[0] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2,
                        editor.sprites['front'].position[1] + end_grid_pos[1] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2)
    with patch.object(editor.sprites['front'], 'get_grid_position', return_value=end_grid_pos):
        event_up = pygame.event.Event(pygame.MOUSEBUTTONUP, button=1, pos=end_screen_pos)
        editor.handle_event(event_up)

    assert editor.selection.start_pos == start_grid_pos, "Selection start_pos should persist after up"
    assert editor.selection.end_pos == end_grid_pos, f"Selection end_pos mismatch after up. Got {editor.selection.end_pos}"
    assert editor.selection.selecting is False, "SelectionTool should stop selecting after mouse up"
    assert editor.selection.active is True, "Selection should be active after mouse up"
    expected_rect_up = pygame.Rect(start_grid_pos[0], start_grid_pos[1], 
                                   end_grid_pos[0] - start_grid_pos[0] + 1,
                                   end_grid_pos[1] - start_grid_pos[1] + 1)
    assert editor.selection.rect == expected_rect_up, f"Selection rect incorrect after up. Got {editor.selection.rect}"

# --- Tests for Background Editing --- 

def test_background_draw_erase(mock_editor):
    """Tests drawing and erasing on the background canvas."""
    editor = mock_editor
    
    # --- Manually Set Up Background Mode State --- 
    # Bypass dialogs for this specific test
    editor.edit_mode = 'background'
    # Use default dimensions from config for the test canvas
    canvas_width = config.DEFAULT_BACKGROUND_WIDTH 
    canvas_height = config.DEFAULT_BACKGROUND_HEIGHT
    editor.canvas_rect = pygame.Rect(50, 100, canvas_width, canvas_height) # Example position
    # Create a plain white background for testing
    editor.current_background = pygame.Surface((canvas_width, canvas_height))
    editor.current_background.fill(config.WHITE)
    # Ensure background buttons are created
    editor.buttons = editor.create_buttons()
    # Ensure dialog mode is off
    editor.dialog_mode = None 
    # --- End Manual Setup ---

    # Define test parameters
    test_color = config.RED # (255, 0, 0)
    editor.select_color(test_color) # Set current color, also disables eraser/fill
    editor.brush_size = 5 # Use a brush size > 1
    click_canvas_rel_pos = (50, 60) # Relative position within the background surface
    click_screen_pos = (editor.canvas_rect.x + click_canvas_rel_pos[0], 
                        editor.canvas_rect.y + click_canvas_rel_pos[1])
    
    # Check initial color (should be white)
    initial_color = editor.current_background.get_at(click_canvas_rel_pos)
    assert initial_color == config.WHITE, f"Initial background pixel color mismatch. Expected WHITE, got {initial_color}"

    # --- Test Drawing --- 
    editor.eraser_mode = False # Ensure eraser is off
    event_draw = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=click_screen_pos)
    # Need to save state manually if not done by event handler in this test setup
    editor.save_state() 
    handled = editor.handle_event(event_draw)
    assert handled is True, "Draw event was not handled"

    # Check pixel color after drawing (should be red near the center)
    # _handle_canvas_click draws a circle based on brush_size
    color_after_draw = editor.current_background.get_at(click_canvas_rel_pos)
    assert color_after_draw == test_color[:3], f"Pixel color after draw mismatch. Expected {test_color[:3]}, got {color_after_draw}"
    
    # --- Test Erasing --- 
    editor.eraser_mode = True # Turn eraser on
    event_erase = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=click_screen_pos)
    # Save state before erasing
    editor.save_state() 
    handled_erase = editor.handle_event(event_erase)
    assert handled_erase is True, "Erase event was not handled"

    # Check pixel color after erasing (should be white)
    color_after_erase = editor.current_background.get_at(click_canvas_rel_pos)
    assert color_after_erase == config.WHITE[:3], f"Pixel color after erase mismatch. Expected {config.WHITE[:3]}, got {color_after_erase}"

# --- Main execution for unittest --- (if using unittest classes)

if __name__ == '__main__':
    # You might need to create a test suite and add all test classes
    suite = unittest.TestSuite()
    # Add existing tests (assuming they are named like TestSpriteLoadingSaving, etc.)
    # suite.addTest(unittest.makeSuite(TestSpriteLoadingSaving))
    # suite.addTest(unittest.makeSuite(TestUndoRedo)) 
    # ... add other existing test classes ...
    
    # Add the new test class
    suite.addTest(unittest.makeSuite(TestReferenceImage))

    runner = unittest.TextTestRunner()
    runner.run(suite)
    # Alternatively, just run discovery if setup allows:
    # unittest.main() # This might run tests multiple times if not structured carefully

    # ... (Rest of the existing code) ... 


================================================
File: tests/test_battle_simulator.py
================================================
import unittest
import copy
import os
import sys # Import sys earlier for path adjustments if needed
import unittest.mock # Move import here
from src.core import config # Updated import
from unittest.mock import MagicMock

# Add project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Adjust path to import from the parent directory if tests are in a subfolder
# Assuming test_battle_simulator.py is in the root alongside battle_simulator.py
# If not, you might need path adjustments like sys.path.append('..')
from src.battle.battle_simulator import Creature, Move, load_creatures, apply_stat_change, create_default_sprite

# Mock Pygame functionalities needed for loading if not running full Pygame init
class MockSurface:
    def __init__(self, size):
        self._size = size
    def get_size(self):
        return self._size
    def convert_alpha(self):
        return self
    def fill(self, color):
        pass
    def blit(self, source, dest, area=None, special_flags=0):
        # We don't need to simulate blitting, just accept the call
        pass

pygame_transform_scale_orig = None

def setup_mocks():
    global pygame_transform_scale_orig
    if hasattr(unittest.mock, 'patch'): # Check if mock is available
        try:
            # Mock pygame.transform.scale if it exists
            if 'pygame' in sys.modules and hasattr(sys.modules['pygame'], 'transform') and hasattr(sys.modules['pygame'].transform, 'scale'):
                pygame_transform_scale_orig = sys.modules['pygame'].transform.scale
                sys.modules['pygame'].transform.scale = lambda surface, size: MockSurface(size)
            else:
                print("Warning: Pygame or pygame.transform.scale not fully available for mocking.")
        except Exception as e:
            print(f"Warning: Could not set up Pygame mocks - {e}")

def teardown_mocks():
    global pygame_transform_scale_orig
    if pygame_transform_scale_orig and 'pygame' in sys.modules and hasattr(sys.modules['pygame'], 'transform'):
         sys.modules['pygame'].transform.scale = pygame_transform_scale_orig

# Mock the sprite loading part to avoid Pygame dependency during test
original_create_sprite_from_file = None
def mock_create_sprite_from_file(filename):
    """Mocks sprite creation to return a dummy surface."""
    # Return an instance of our mock surface, not a real one
    return MockSurface(config.NATIVE_SPRITE_RESOLUTION) 

class TestBattleSimulator(unittest.TestCase): # Renamed class for broader scope

    @classmethod
    def setUpClass(cls):
        """Set up mocks before tests run."""
        # Ensure data directory exists for loading
        if not os.path.exists('data'):
             raise FileNotFoundError("Data directory not found. Make sure tests run from project root.")
        if not os.path.exists('data/monsters.json'):
             raise FileNotFoundError("monsters.json not found in data directory.")
        if not os.path.exists('data/moves.json'):
            raise FileNotFoundError("moves.json not found in data directory.")
        if not os.path.exists('data/type_chart.json'):
            raise FileNotFoundError("type_chart.json not found in data directory.")

        # Mock sprite creation globally for this test class
        global original_create_sprite_from_file
        import src.battle.battle_simulator
        original_create_sprite_from_file = src.battle.battle_simulator.create_sprite_from_file
        src.battle.battle_simulator.create_sprite_from_file = mock_create_sprite_from_file

        # Set up general Pygame mocks
        setup_mocks()

    @classmethod
    def tearDownClass(cls):
        """Restore original functions after tests."""
        # Restore original sprite creation
        global original_create_sprite_from_file
        if original_create_sprite_from_file:
            import src.battle.battle_simulator
            src.battle.battle_simulator.create_sprite_from_file = original_create_sprite_from_file

        # Tear down general Pygame mocks
        teardown_mocks()

    def setUp(self):
        """Create a default creature for tests that need one."""
        # Mock a default sprite without pygame dependency if possible
        mock_sprite = unittest.mock.Mock(spec=MockSurface)
        mock_sprite.get_size.return_value = (64, 64)
        mock_sprite.convert_alpha.return_value = mock_sprite

        self.default_creature = Creature(
            name="TestMon", type_="Normal", max_hp=100, attack=50, defense=50,
            moves=[], sprite=mock_sprite # Use the mock surface created above
        )

    def test_poke_6_stat_reset_with_deepcopy(self):
        """Verify that stat changes on a copy don't affect the original."""
        # 1. Load creatures (uses mocked sprite loading)
        all_creatures = load_creatures()
        self.assertTrue(len(all_creatures) > 0, "Creature loading failed or returned empty list.")
        original_creature = all_creatures[0]

        # 2. Store original stat
        original_attack = original_creature.attack
        original_defense = original_creature.defense
        original_hp = original_creature.current_hp
        original_max_hp = original_creature.max_hp

        # 3. Create a deep copy
        creature_copy = copy.deepcopy(original_creature)

        # 4. Apply stat change to the copy (e.g., increase attack)
        apply_stat_change(creature_copy, 'attack', 2) # Increase attack stage by 2
        # Apply damage to the copy
        creature_copy.current_hp -= 10

        # 5. Assert original creature's stats are unchanged
        self.assertEqual(original_creature.attack, original_attack,
                         f"Original attack changed! Expected {original_attack}, got {original_creature.attack}")
        self.assertEqual(original_creature.defense, original_defense,
                         f"Original defense changed! Expected {original_defense}, got {original_creature.defense}")
        self.assertEqual(original_creature.current_hp, original_hp,
                         f"Original current HP changed! Expected {original_hp}, got {original_creature.current_hp}")
        self.assertEqual(original_creature.max_hp, original_max_hp,
                         f"Original max HP changed! Expected {original_max_hp}, got {original_creature.max_hp}")

        # 6. Assert copy's stats ARE changed
        self.assertNotEqual(creature_copy.attack, original_attack,
                          "Copied creature's attack did not change as expected.")
        self.assertLess(creature_copy.current_hp, original_hp,
                        "Copied creature's HP did not decrease as expected.")
        # Check if max HP is unchanged in copy (it should be)
        self.assertEqual(creature_copy.max_hp, original_max_hp,
                         "Copied creature's max HP changed unexpectedly.")

    # --- Tests for POKE-7 --- 
    def test_apply_stat_change_attack_increase(self):
        """Test increasing attack stat."""
        creature = self.default_creature
        initial_attack = creature.attack
        # Expected: 50 * (1 + 0.66 / (2**(1-1))) = 50 * (1 + 0.66/1) = 50 * 1.66 = 83
        apply_stat_change(creature, "attack", 1)
        self.assertEqual(creature.attack, 83)
        # Expected: 83 * (1 + 0.66 / (2**(2-1))) = 83 * (1 + 0.66/2) = 83 * 1.33 = 110.39 -> 110
        apply_stat_change(creature, "attack", 2) # This applies stage 2 multiplier to current stat
        self.assertEqual(creature.attack, 110) # Note: The function applies change relative to current stat

    def test_apply_stat_change_attack_decrease(self):
        """Test decreasing attack stat."""
        creature = self.default_creature
        initial_attack = creature.attack
        # Expected: 50 / (1 + 0.66 / (2**(1-1))) = 50 / (1 + 0.66/1) = 50 / 1.66 = 30.12 -> 30
        apply_stat_change(creature, "attack", -1)
        self.assertEqual(creature.attack, 30)
        # Expected: 30 / (1 + 0.66 / (2**(2-1))) = 30 / (1 + 0.66/2) = 30 / 1.33 = 22.55 -> 22
        apply_stat_change(creature, "attack", -2) # Applies stage 2 reduction to current stat
        self.assertEqual(creature.attack, 22)

    def test_apply_stat_change_defense_increase(self):
        """Test increasing defense stat."""
        creature = self.default_creature
        initial_defense = creature.defense
        # Expected: 50 * 1.66 = 83
        apply_stat_change(creature, "defense", 1)
        self.assertEqual(creature.defense, 83)
        # Expected: 83 * 1.33 = 110.39 -> 110
        apply_stat_change(creature, "defense", 2)
        self.assertEqual(creature.defense, 110)

    def test_apply_stat_change_defense_decrease(self):
        """Test decreasing defense stat."""
        creature = self.default_creature
        initial_defense = creature.defense
        # Expected: 50 / 1.66 = 30.12 -> 30
        apply_stat_change(creature, "defense", -1)
        self.assertEqual(creature.defense, 30)
        # Expected: 30 / 1.33 = 22.55 -> 22
        apply_stat_change(creature, "defense", -2)
        self.assertEqual(creature.defense, 22)

    def test_apply_stat_change_invalid_stat(self):
        """Test applying change to an invalid stat name."""
        creature = self.default_creature
        initial_attack = creature.attack
        initial_defense = creature.defense
        apply_stat_change(creature, "speed", 1) # Should do nothing
        self.assertEqual(creature.attack, initial_attack)
        self.assertEqual(creature.defense, initial_defense)

    def test_apply_stat_change_zero_change(self):
        """Test applying a zero change."""
        creature = self.default_creature
        initial_attack = creature.attack
        # The current logic might break with change=0 due to 2**(0-1)
        # Let's test what happens (it should ideally do nothing)
        # apply_stat_change(creature, "attack", 0) # Raises Error: 2**-1 is 0.5
        # For now, we assume change is always non-zero based on usage
        # If 0 change is possible, the function needs adjustment
        pass # Skipping test for change=0 as it's not handled

    # --- Tests for POKE-4 --- 

    def test_creature_init_stores_native_sprite(self):
        """Test if Creature stores the sprite at native resolution initially."""
        # Arrange
        native_sprite = MockSurface(config.NATIVE_SPRITE_RESOLUTION)
        
        # Act
        creature = Creature(
            name="TestSpriteMon", type_="Normal", max_hp=100, attack=50, defense=50,
            moves=[], sprite=native_sprite
        )
        
        # Assert
        # Check if the stored sprite object is the one passed in (or a copy)
        # Most importantly, check its size remains native
        self.assertEqual(creature.sprite.get_size(), config.NATIVE_SPRITE_RESOLUTION,
                         f"Creature sprite should be initialized with native resolution {config.NATIVE_SPRITE_RESOLUTION}, "
                         f"but got {creature.sprite.get_size()}")

    @unittest.mock.patch('src.battle.battle_simulator.pygame.transform.scale')
    def test_draw_battle_scales_sprite_correctly(self, mock_scale):
        """Test if draw_battle calls pygame.transform.scale with the correct target size."""
        # Arrange
        # Create creatures with native sprites
        native_sprite1 = MockSurface(config.NATIVE_SPRITE_RESOLUTION)
        creature1 = Creature("Mon1", "Normal", 100, 50, 50, [], native_sprite1)
        
        native_sprite2 = MockSurface(config.NATIVE_SPRITE_RESOLUTION)
        creature2 = Creature("Mon2", "Fire", 100, 50, 50, [], native_sprite2)
        
        mock_buttons = [] # draw_battle needs buttons list
        mock_background = MockSurface((config.BATTLE_WIDTH, config.BATTLE_HEIGHT))
        mock_screen = MockSurface((config.BATTLE_WIDTH, config.BATTLE_HEIGHT))

        # Mock SCREEN object used within draw_battle if necessary
        with unittest.mock.patch('src.battle.battle_simulator.SCREEN', mock_screen):
            # Mock blit to avoid errors if SCREEN is not a real surface
             with unittest.mock.patch.object(mock_screen, 'blit') as mock_blit:
                # Mock font rendering: Patch the Font constructor instead of the render method
                mock_font_instance = MagicMock()
                mock_font_instance.render.return_value = MockSurface((10,10)) # Configure the mock render
                with unittest.mock.patch('src.battle.battle_simulator.pygame.font.Font', return_value=mock_font_instance) as mock_font_constructor:
                     # ALSO patch pygame.draw.rect to avoid TypeError with MockSurface
                     with unittest.mock.patch('src.battle.battle_simulator.pygame.draw.rect') as mock_draw_rect:
                         # Act
                         from src.battle.battle_simulator import draw_battle
                         draw_battle(creature1, creature2, mock_buttons, mock_background)

        # Assert
        # Check if pygame.transform.scale was called correctly for both creatures
        expected_size = config.BATTLE_SPRITE_DISPLAY_SIZE
        calls = [
            unittest.mock.call(native_sprite1, expected_size),
            unittest.mock.call(native_sprite2, expected_size)
        ]
        mock_scale.assert_has_calls(calls, any_order=True)
        assert mock_scale.call_count == 2

    # --- Tests for TEST-2 (Damage Calculation) ---

    def test_calculate_damage_super_effective(self):
        """Test damage calculation with super effective multiplier (2.0x)."""
        # Arrange
        attacker = Creature("Attacker", "Fire", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Nature", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("FireBlast", "Fire", 90)
        # Expected damage uses the formula: (10 * Att * Pow) / (30 * Def) + 2) * Eff * Rand
        # Base = (10 * 50 * 90) / (30 * 50) + 2 = (45000 / 1500) + 2 = 30 + 2 = 32
        # Expected Damage Range = (32 * 2.0) * [0.85, 1.0] = 64 * [0.85, 1.0] = [54.4, 64.0]
        # We'll check if the damage falls within this range (integer conversion included).
        expected_min_dmg = 54
        expected_max_dmg = 64

        # Act
        from src.battle.battle_simulator import calculate_damage # Import locally to use updated type_chart
        # Run multiple times to account for randomness
        damages = [calculate_damage(attacker, defender, move)[0] for _ in range(100)]

        # Assert
        for dmg in damages:
            self.assertTrue(expected_min_dmg <= dmg <= expected_max_dmg,
                            f"Super effective damage {dmg} out of range [{expected_min_dmg}, {expected_max_dmg}]")

    def test_calculate_damage_not_very_effective(self):
        """Test damage calculation with not very effective multiplier (0.5x)."""
        attacker = Creature("Attacker", "Fire", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Water", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("FireBlast", "Fire", 90)
        # Base = 32
        # Expected Damage Range = (32 * 0.5) * [0.85, 1.0] = 16 * [0.85, 1.0] = [13.6, 16.0]
        expected_min_dmg = 13
        expected_max_dmg = 16

        from src.battle.battle_simulator import calculate_damage
        damages = [calculate_damage(attacker, defender, move)[0] for _ in range(100)]

        for dmg in damages:
            self.assertTrue(expected_min_dmg <= dmg <= expected_max_dmg,
                            f"Not very effective damage {dmg} out of range [{expected_min_dmg}, {expected_max_dmg}]")

    def test_calculate_damage_neutral(self):
        """Test damage calculation with neutral multiplier (1.0x)."""
        attacker = Creature("Attacker", "Fire", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Electric", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("FireBlast", "Fire", 90)
        # Base = 32
        # Expected Damage Range = (32 * 1.0) * [0.85, 1.0] = 32 * [0.85, 1.0] = [27.2, 32.0]
        expected_min_dmg = 27
        expected_max_dmg = 32

        from src.battle.battle_simulator import calculate_damage
        damages = [calculate_damage(attacker, defender, move)[0] for _ in range(100)]

        for dmg in damages:
            self.assertTrue(expected_min_dmg <= dmg <= expected_max_dmg,
                            f"Neutral damage {dmg} out of range [{expected_min_dmg}, {expected_max_dmg}]")

    def test_calculate_damage_immune(self):
        """Test damage calculation with immunity (0.0x)."""
        attacker = Creature("Attacker", "Mind", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Shadow", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("PsyBeam", "Mind", 65) # Mind attack
        # Expected Damage = 0

        from src.battle.battle_simulator import calculate_damage
        damage, effectiveness = calculate_damage(attacker, defender, move)

        self.assertEqual(damage, 0, f"Immune damage should be 0, got {damage}")
        # self.assertEqual(effectiveness, 0.0, "Effectiveness should be 0.0 for immunity") # Optional check

    def test_calculate_damage_stat_move(self):
        """Test that stat-changing moves deal 0 damage."""
        attacker = Creature("Attacker", "Normal", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Normal", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        # Assuming a stat move like Growl (Power 0, Effect: lower opponent attack)
        stat_move = Move("Growl", "Normal", 0, effect={'target': 'opponent', 'stat': 'attack', 'change': 1})

        from src.battle.battle_simulator import calculate_damage
        damage, effectiveness = calculate_damage(attacker, defender, stat_move)

        self.assertEqual(damage, 0, f"Stat move damage should be 0, got {damage}")


if __name__ == '__main__':
    # Need to import mock here if not already imported and handle potential absence
    # try:
    #     import unittest.mock  <- Remove from here
    # except ImportError:
    #     print("unittest.mock not available. Some mocking might not work.")

    # Mock Pygame init and display functions if they are called during imports
    try:
        # import sys <- Already imported at top
        if 'pygame' not in sys.modules:
            # If pygame hasn't been imported at all, create a dummy module
            class MockPygame:
                init = lambda: None
                quit = lambda: None
                display = unittest.mock.Mock()
                display.set_mode = lambda size: MockSurface(size)
                display.set_caption = lambda title: None
                transform = unittest.mock.Mock()
                transform.scale = lambda surface, size: MockSurface(size)
                font = unittest.mock.Mock()
                font.Font = lambda name, size: unittest.mock.Mock()
                Surface = MockSurface
                SRCALPHA = 0
                image = unittest.mock.Mock()
                image.load = lambda x: MockSurface((64,64))
                mixer = unittest.mock.Mock()
                mixer.init = lambda: None
                error = Exception

            sys.modules['pygame'] = MockPygame()
        else:
            # If pygame is imported, patch specific functions if needed
            pygame = sys.modules['pygame']
            if not hasattr(pygame, 'init'): pygame.init = lambda: None
            if not hasattr(pygame, 'quit'): pygame.quit = lambda: None
            if not hasattr(pygame, 'display'): pygame.display = unittest.mock.Mock()
            if not hasattr(pygame.display, 'set_mode'): pygame.display.set_mode = lambda size: MockSurface(size)
            if not hasattr(pygame.display, 'set_caption'): pygame.display.set_caption = lambda title: None
            # Add other necessary mocks if load_creatures triggers them

    except Exception as e:
        print(f"Warning: Could not set up full Pygame module mocks - {e}")

    unittest.main() 


================================================
File: tests/test_editor_ui.py
================================================
import unittest
from unittest.mock import MagicMock, patch
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
# Assuming editor_ui contains Button, Palette, PALETTE
from src.editor.editor_ui import Palette, PALETTE, Button 

class TestPalette(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Minimal Pygame setup needed for Font
        pygame.font.init()

    @classmethod
    def tearDownClass(cls):
        pygame.font.quit()

    def setUp(self):
        self.palette_pos = (50, 600)
        self.palette = Palette(self.palette_pos)
        # Mock the editor object that Palette.handle_click expects
        self.mock_editor = MagicMock()
        # We might need to mock specific editor attributes if handle_click uses them
        # For now, just mocking the select_color method is the primary need.
        # self.mock_editor.select_color = MagicMock()

    def test_initialization(self):
        """Test if the Palette initializes correctly."""
        self.assertEqual(self.palette.position, self.palette_pos)
        self.assertEqual(self.palette.scroll_offset, 0)
        self.assertTrue(hasattr(self.palette, 'font'))
        # Check if total_pages calculation seems reasonable
        expected_pages = (len(PALETTE) + self.palette.colors_per_page - 1) // self.palette.colors_per_page
        self.assertEqual(self.palette.total_pages, expected_pages)

    def test_handle_click_color_selection_first_page(self):
        """Test selecting a color block on the first page."""
        # Calculate the center position of the first color block (usually black)
        first_block_x = self.palette_pos[0] + self.palette.block_size // 2
        first_block_y = self.palette_pos[1] + self.palette.block_size // 2
        click_pos = (first_block_x, first_block_y)
        expected_color = PALETTE[0] # The first color

        self.palette.handle_click(click_pos, self.mock_editor)

        # Assert that the editor's select_color method was called once with the expected color
        self.mock_editor.select_color.assert_called_once_with(expected_color)

    def test_handle_click_scroll_down(self):
        """Test clicking the scroll down area."""
        initial_offset = self.palette.scroll_offset
        # Calculate a position within the approximate scroll down area
        scroll_x = self.palette_pos[0] + config.PALETTE_COLS * (self.palette.block_size + self.palette.padding) + 15
        scroll_y = self.palette_pos[1] + config.PALETTE_ROWS * (self.palette.block_size + self.palette.padding) - 10 # Near bottom
        click_pos = (scroll_x, scroll_y)

        # Only scroll if possible
        if self.palette.total_pages > 1:
            self.palette.handle_click(click_pos, self.mock_editor)
            self.assertEqual(self.palette.scroll_offset, initial_offset + 1)
            # Ensure select_color was NOT called
            self.mock_editor.select_color.assert_not_called()
        else:
            self.palette.handle_click(click_pos, self.mock_editor)
            self.assertEqual(self.palette.scroll_offset, initial_offset) # Should not change
            self.mock_editor.select_color.assert_not_called()

    def test_handle_click_scroll_up(self):
        """Test clicking the scroll up area."""
        # First, scroll down if possible to make scrolling up meaningful
        if self.palette.total_pages > 1:
            self.palette.scroll_offset = 1
        else:
             self.skipTest("Cannot test scroll up without multiple pages")
             
        initial_offset = self.palette.scroll_offset
        # Calculate a position within the approximate scroll up area
        scroll_x = self.palette_pos[0] + config.PALETTE_COLS * (self.palette.block_size + self.palette.padding) + 15
        scroll_y = self.palette_pos[1] + 10 # Near top
        click_pos = (scroll_x, scroll_y)

        self.palette.handle_click(click_pos, self.mock_editor)
        self.assertEqual(self.palette.scroll_offset, initial_offset - 1)
        self.mock_editor.select_color.assert_not_called()

    def test_handle_click_outside(self):
        """Test clicking outside the palette area."""
        click_pos = (self.palette_pos[0] - 10, self.palette_pos[1] - 10) # Clearly outside
        initial_offset = self.palette.scroll_offset

        self.palette.handle_click(click_pos, self.mock_editor)

        # Assert offset didn't change and select_color wasn't called
        self.assertEqual(self.palette.scroll_offset, initial_offset)
        self.mock_editor.select_color.assert_not_called()

    def test_draw_runs(self):
        """Test that the draw method runs without errors."""
        # We need a surface to draw on
        mock_surface = MagicMock(spec=pygame.Surface)
        # Need to mock surface methods if draw uses them (e.g., blit, draw.rect)
        mock_surface.blit = MagicMock()
        mock_surface.fill = MagicMock() # Palette draw might fill background?
        # Mock pygame.draw directly if needed
        with patch('pygame.draw.rect') as mock_draw_rect, \
             patch('pygame.draw.line') as mock_draw_line:
            try:
                # Pass a sample current color
                self.palette.draw(mock_surface, PALETTE[0])
            except Exception as e:
                self.fail(f"Palette.draw() raised exception unexpectedly: {e}")
            # Optionally, assert that drawing functions were called
            mock_draw_rect.assert_called()
            # mock_draw_line might be called for transparent colors
            # mock_surface.blit.assert_called() # For labels/arrows


if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/test_event_handler.py
================================================
import unittest
from unittest.mock import MagicMock, patch
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
from src.core.event_handler import EventHandler
# Need Palette for position/size calculation, even if mocked
from src.editor.editor_ui import Palette, Button
from src.editor.tool_manager import ToolManager
from src.editor.sprite_editor import SpriteEditor


class TestEventHandlerPaletteInteraction(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Minimal Pygame setup needed for Rect/Event/Font
        pygame.font.init() 

    @classmethod
    def tearDownClass(cls):
        pygame.font.quit()

    def setUp(self):
        # Mock the Editor
        self.mock_editor = MagicMock()
        self.mock_editor.dialog_mode = None # Ensure no dialog is active

        # --- Mock Palette --- 
        self.mock_editor.palette = MagicMock(spec=Palette)
        self.palette_pos = (50, 600) 
        self.mock_editor.palette.position = self.palette_pos
        self.mock_editor.palette.block_size = getattr(config, 'PALETTE_BLOCK_SIZE', 15)
        self.mock_editor.palette.padding = getattr(config, 'PALETTE_PADDING', 2)

        # --- Mock Sliders (to prevent EventHandler from handling clicks on them) ---
        # Mock ref alpha slider rect
        self.mock_editor.ref_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.ref_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.ref_alpha_slider_rect.width = 150 # Provide a width for comparison
        
        # Mock subject alpha slider rect (even if not always used, safer for the check)
        self.mock_editor.subj_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.subj_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.subj_alpha_slider_rect.width = 150 # Provide a width

        # Mock edit_mode for slider checks in EventHandler
        self.mock_editor.edit_mode = 'monster' # Assume monster mode for simplicity

        # The handle_click method on the mock palette is automatically a MagicMock

        # Create the real EventHandler instance with the mock Editor
        self.event_handler = EventHandler(self.mock_editor)

    def test_handle_mouse_down_calls_palette_click_correctly(self):
        """Verify EventHandler calls Palette.handle_click with correct args on palette click."""
        # Calculate a click position within the mocked palette area
        # (Simplified - assumes top-left block is clickable)
        click_x = self.palette_pos[0] + self.mock_editor.palette.block_size // 2
        click_y = self.palette_pos[1] + self.mock_editor.palette.block_size // 2
        click_pos = (click_x, click_y)

        # Create a mock MOUSEBUTTONDOWN event
        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEBUTTONDOWN
        mock_event.button = 1 # Left click
        mock_event.pos = click_pos

        # Call the method under test (can call process_event or the specific handler)
        # Calling process_event is slightly more integrated
        self.event_handler.process_event(mock_event)
        # Or: self.event_handler._handle_mouse_button_down(mock_event)

        # Assert: palette.handle_click was called once with (event.pos, editor)
        self.mock_editor.palette.handle_click.assert_called_once_with(click_pos, self.mock_editor)

# TODO: Add more tests for EventHandler logic (button clicks, canvas clicks, key presses etc.)

class TestEventHandlerOtherInteractions(unittest.TestCase):
    # Separate class for different setup/focus

    @classmethod
    def setUpClass(cls):
        pygame.font.init()

    @classmethod
    def tearDownClass(cls):
        pygame.font.quit()

    def setUp(self):
        self.mock_editor = MagicMock()
        self.mock_editor.dialog_mode = None
        self.mock_editor.edit_mode = 'monster' # Default to monster

        # Mock ToolManager
        self.mock_editor.tool_manager = MagicMock(spec=ToolManager)

        # Mock Buttons (list of mock buttons)
        self.mock_button_action = MagicMock() # Action for the button
        self.mock_button = MagicMock(spec=Button)
        self.mock_button.rect = pygame.Rect(500, 10, 100, 30)
        self.mock_button.action = self.mock_button_action
        # Mock is_clicked behavior
        # We'll control its return value in the test
        self.mock_button.is_clicked = MagicMock(return_value=False) 
        self.mock_editor.buttons = [self.mock_button]

        # Mock SpriteEditor related things for canvas click
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_editor._get_sprite_editor_at_pos = MagicMock(return_value=None) # Default to miss
        
        # Mock Background related things for canvas click
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=False) # Default to miss

        # Mock Selection related things
        self.mock_editor.mode = 'draw' # Default to draw mode
        self.mock_editor.selection = MagicMock()
        self.mock_editor.selection.selecting = False

        # Mock sliders to prevent interference
        self.mock_editor.ref_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.ref_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.ref_alpha_slider_rect.width = 150 # Provide a width
        self.mock_editor.subj_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.subj_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.subj_alpha_slider_rect.width = 150 # Provide a width
        self.mock_editor.adjusting_alpha = False # <<< Add mock attribute
        self.mock_editor.adjusting_subject_alpha = False # <<< Add mock attribute

        # Mock Palette interaction to prevent interference
        self.mock_editor.palette = MagicMock(spec=Palette)
        # Need to mock the rect calculation used in EventHandler
        # Or ensure the test click pos is outside the palette rect
        self.mock_editor.palette.position = (1000, 1000) # Position it off-screen
        self.mock_editor.palette.block_size = 15
        self.mock_editor.palette.padding = 2
        
        # Create EventHandler
        self.event_handler = EventHandler(self.mock_editor)

    def test_button_click_calls_action(self):
        """Verify clicking a button calls its action."""
        click_pos = self.mock_button.rect.center
        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEBUTTONDOWN
        mock_event.button = 1
        mock_event.pos = click_pos

        # Configure the mock button's is_clicked to return True for this event
        self.mock_button.is_clicked.return_value = True 

        # Process the event
        self.event_handler.process_event(mock_event)

        # Assert
        self.mock_button.is_clicked.assert_called_once_with(mock_event)
        self.mock_button_action.assert_called_once()

    def test_canvas_click_calls_tool_manager(self):
        """Verify clicking the canvas calls tool_manager.handle_click."""
        # Simulate clicking on a sprite editor
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        click_pos = (60, 60) # Assume this hits the sprite editor
        self.mock_editor.mode = 'draw' # Ensure not in select mode

        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEBUTTONDOWN
        mock_event.button = 1
        mock_event.pos = click_pos
        
        self.event_handler.process_event(mock_event)

        # Assert tool manager was called
        self.mock_editor.tool_manager.handle_click.assert_called_once_with(click_pos)
        # Ensure save_state was called (since not in select mode)
        self.mock_editor.save_state.assert_called_once()

    def test_canvas_drag_calls_tool_manager(self):
        """Verify dragging on the canvas calls tool_manager.handle_drag."""
        drag_pos = (70, 70)
        self.mock_editor.mode = 'draw' # Ensure not in select mode
        
        # Simulate mouse button being down before motion
        self.event_handler.left_mouse_button_down = True

        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEMOTION
        mock_event.buttons = (1, 0, 0) # Left button held
        mock_event.pos = drag_pos
        
        self.event_handler.process_event(mock_event)

        # Assert tool manager drag was called
        self.mock_editor.tool_manager.handle_drag.assert_called_once_with(drag_pos)

    def test_canvas_drag_ignored_in_select_mode(self):
        """Verify canvas drag is ignored by tool manager in select mode."""
        drag_pos = (70, 70)
        self.mock_editor.mode = 'select' # In select mode
        
        # Simulate mouse button being down before motion
        self.event_handler.left_mouse_button_down = True
        
        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEMOTION
        mock_event.buttons = (1, 0, 0) # Left button held
        mock_event.pos = drag_pos
        
        self.event_handler.process_event(mock_event)

        # Assert tool manager drag was NOT called
        self.mock_editor.tool_manager.handle_drag.assert_not_called()


if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/test_sprite_editor.py
================================================
import unittest
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
from src.editor.sprite_editor import SpriteEditor

class TestSpriteEditor(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Initialize Pygame minimally if needed for Surface creation
        # We might be able to avoid full pygame.init()
        # pygame.display.init() # <<< REMOVE THIS LINE
        pass # Keep setUpClass structure if needed later

    @classmethod
    def tearDownClass(cls):
        pygame.quit()

    def setUp(self):
        # Create a SpriteEditor instance for each test
        # Position doesn't really matter for these unit tests
        self.sprite_editor = SpriteEditor(position=(0, 0), name="test", sprite_dir="./temp_test_sprites")
        # Ensure the temp dir exists if needed for save/load tests later
        # os.makedirs("./temp_test_sprites", exist_ok=True)

    # def tearDown(self):
        # Clean up temp files/dirs if save/load tests are added
        # import shutil
        # if os.path.exists("./temp_test_sprites"):
        #     shutil.rmtree("./temp_test_sprites")

    def test_initialization(self):
        """Test if the SpriteEditor initializes correctly."""
        self.assertEqual(self.sprite_editor.frame.get_size(), config.NATIVE_SPRITE_RESOLUTION, "Frame size should match native resolution")
        # Check if it's transparent initially
        initial_color = self.sprite_editor.frame.get_at((0, 0))
        self.assertEqual(initial_color, (*config.BLACK[:3], 0), "Initial frame should be transparent black")
        self.assertEqual(self.sprite_editor.display_width, config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE)
        self.assertEqual(self.sprite_editor.display_height, config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE)

    def test_draw_pixel_within_bounds(self):
        """Test drawing a single pixel within the frame boundaries."""
        test_pos = (10, 15)
        test_color = (255, 0, 0, 255) # Opaque Red
        self.sprite_editor.draw_pixel(test_pos, test_color)
        drawn_color = self.sprite_editor.frame.get_at(test_pos)
        self.assertEqual(drawn_color, test_color, "Pixel color should match the drawn color")

    def test_draw_pixel_outside_bounds(self):
        """Test attempting to draw a pixel outside the frame boundaries."""
        # Test outside X
        test_pos_x = (config.NATIVE_SPRITE_RESOLUTION[0], 5)
        # Test outside Y
        test_pos_y = (5, config.NATIVE_SPRITE_RESOLUTION[1])
        test_color = (0, 255, 0, 255) # Opaque Green

        # Get initial color at a known valid position to check against later
        initial_color_check = self.sprite_editor.frame.get_at((0, 0))

        # Try drawing outside bounds - should have no effect
        self.sprite_editor.draw_pixel(test_pos_x, test_color)
        self.sprite_editor.draw_pixel(test_pos_y, test_color)

        # Check if a known valid pixel remained unchanged
        current_color_check = self.sprite_editor.frame.get_at((0, 0))
        self.assertEqual(current_color_check, initial_color_check, "Drawing outside bounds should not change pixels within bounds")
        # Pygame's set_at outside bounds raises IndexError, SpriteEditor handles this check
        # We are implicitly testing that no error is raised

    def test_get_pixel_color_within_bounds(self):
        """Test getting the color of a pixel within bounds."""
        test_pos = (5, 5)
        test_color = (0, 0, 255, 255) # Opaque Blue
        self.sprite_editor.draw_pixel(test_pos, test_color)
        retrieved_color = self.sprite_editor.get_pixel_color(test_pos)
        self.assertEqual(retrieved_color, test_color, "Retrieved color should match drawn color")

    def test_get_pixel_color_transparent(self):
        """Test getting the color of an un-drawn (transparent) pixel."""
        test_pos = (1, 1) # Assume this hasn't been drawn on
        retrieved_color = self.sprite_editor.get_pixel_color(test_pos)
        expected_transparent = (*config.BLACK[:3], 0)
        self.assertEqual(retrieved_color, expected_transparent, "Un-drawn pixel should be transparent black")

    def test_get_pixel_color_outside_bounds(self):
        """Test getting the color of a pixel outside bounds."""
        # Test outside X
        retrieved_color_x = self.sprite_editor.get_pixel_color((config.NATIVE_SPRITE_RESOLUTION[0], 5))
        # Test outside Y
        retrieved_color_y = self.sprite_editor.get_pixel_color((5, config.NATIVE_SPRITE_RESOLUTION[1]))
        self.assertIsNone(retrieved_color_x, "Getting color outside X bounds should return None")
        self.assertIsNone(retrieved_color_y, "Getting color outside Y bounds should return None")

    def test_get_grid_position_within_bounds(self):
        """Test converting screen coordinates within the visual editor bounds."""
        # Top-left corner pixel
        screen_pos_tl = (self.sprite_editor.position[0], self.sprite_editor.position[1])
        grid_pos_tl = self.sprite_editor.get_grid_position(screen_pos_tl)
        self.assertEqual(grid_pos_tl, (0, 0))

        # A position within the first pixel
        screen_pos_in_pixel = (self.sprite_editor.position[0] + config.EDITOR_PIXEL_SIZE // 2, self.sprite_editor.position[1] + config.EDITOR_PIXEL_SIZE // 2)
        grid_pos_in_pixel = self.sprite_editor.get_grid_position(screen_pos_in_pixel)
        self.assertEqual(grid_pos_in_pixel, (0, 0))

        # Center of the editor grid (approx)
        center_x_grid = config.EDITOR_GRID_SIZE // 2
        center_y_grid = config.EDITOR_GRID_SIZE // 2
        screen_pos_center = (self.sprite_editor.position[0] + center_x_grid * config.EDITOR_PIXEL_SIZE, 
                             self.sprite_editor.position[1] + center_y_grid * config.EDITOR_PIXEL_SIZE)
        grid_pos_center = self.sprite_editor.get_grid_position(screen_pos_center)
        self.assertEqual(grid_pos_center, (center_x_grid, center_y_grid))

        # Bottom-right corner pixel (test edge)
        br_x_grid = config.EDITOR_GRID_SIZE - 1
        br_y_grid = config.EDITOR_GRID_SIZE - 1
        screen_pos_br = (self.sprite_editor.position[0] + br_x_grid * config.EDITOR_PIXEL_SIZE, 
                           self.sprite_editor.position[1] + br_y_grid * config.EDITOR_PIXEL_SIZE)
        grid_pos_br = self.sprite_editor.get_grid_position(screen_pos_br)
        self.assertEqual(grid_pos_br, (br_x_grid, br_y_grid))

    def test_get_grid_position_outside_bounds(self):
        """Test converting screen coordinates outside the visual editor bounds."""
        # Just outside left
        screen_pos_left = (self.sprite_editor.position[0] - 1, self.sprite_editor.position[1])
        grid_pos_left = self.sprite_editor.get_grid_position(screen_pos_left)
        self.assertIsNone(grid_pos_left, "Position outside left bound should return None")

        # Just outside right
        screen_pos_right = (self.sprite_editor.position[0] + self.sprite_editor.display_width, self.sprite_editor.position[1])
        grid_pos_right = self.sprite_editor.get_grid_position(screen_pos_right)
        self.assertIsNone(grid_pos_right, "Position outside right bound should return None")

        # Just outside top
        screen_pos_top = (self.sprite_editor.position[0], self.sprite_editor.position[1] - 1)
        grid_pos_top = self.sprite_editor.get_grid_position(screen_pos_top)
        self.assertIsNone(grid_pos_top, "Position outside top bound should return None")

        # Just outside bottom
        screen_pos_bottom = (self.sprite_editor.position[0], self.sprite_editor.position[1] + self.sprite_editor.display_height)
        grid_pos_bottom = self.sprite_editor.get_grid_position(screen_pos_bottom)
        self.assertIsNone(grid_pos_bottom, "Position outside bottom bound should return None")

    # TODO: Add tests for load_sprite (requires mocking os.path.exists, pygame.image.load)
    # TODO: Add tests for save_sprite (requires mocking pygame.image.save, maybe os.makedirs)
    # TODO: Add tests for draw_background, draw_pixels, draw_highlight (verify calls/surface content?)

if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/test_tool_manager.py
================================================
import unittest
from unittest.mock import MagicMock, patch
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
from src.editor.tool_manager import DrawTool, FillTool, PasteTool, ToolManager
from src.editor.sprite_editor import SpriteEditor
from src.editor.selection_manager import SelectionTool

class TestDrawTool(unittest.TestCase):

    def setUp(self):
        self.draw_tool = DrawTool()
        self.mock_editor = MagicMock()
        # Common editor attributes needed by DrawTool
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor.current_color = (255, 0, 0, 255) # Red
        self.mock_editor.eraser_mode = False
        self.mock_editor.brush_size = 1
        # Mock SpriteEditor related things
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_sprite_editor.position = (50, 50) # Example position
        self.mock_sprite_editor.display_width = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE
        self.mock_sprite_editor.display_height = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = (10, 10) # Mock grid pos
        
        # Mock Background related things - Make canvas_rect a MagicMock
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        # Set necessary Rect attributes used by the code (optional but safer)
        self.mock_editor.canvas_rect.x = 100
        self.mock_editor.canvas_rect.y = 100
        self.mock_editor.canvas_rect.width = 200
        self.mock_editor.canvas_rect.height = 200
        # We will set collidepoint's return value in specific tests
        
        self.mock_editor.current_background = MagicMock(spec=pygame.Surface)
        self.mock_editor.current_background.get_size.return_value = (400, 400) # Example size
        self.mock_editor.view_offset_x = 0
        self.mock_editor.view_offset_y = 0
        self.mock_editor.editor_zoom = 1.0

    # --- Tests for _get_target ---
    def test_get_target_monster_mode_hit(self):
        """Test _get_target returns sprite editor in monster mode."""
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        target = self.draw_tool._get_target(self.mock_editor, (60, 60)) # Pos within mock sprite editor
        self.assertEqual(target, self.mock_sprite_editor)

    def test_get_target_monster_mode_miss(self):
        """Test _get_target returns None in monster mode if no sprite editor hit."""
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor._get_sprite_editor_at_pos.return_value = None
        target = self.draw_tool._get_target(self.mock_editor, (10, 10)) # Pos outside mock sprite editor
        self.assertIsNone(target)

    def test_get_target_background_mode_hit(self):
        """Test _get_target returns background surface in background mode."""
        self.mock_editor.edit_mode = 'background'
        # Mock canvas_rect.collidepoint to return True
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=True)
        target = self.draw_tool._get_target(self.mock_editor, (150, 150)) # Pos within mock canvas
        self.assertEqual(target, self.mock_editor.current_background)
        self.mock_editor.canvas_rect.collidepoint.assert_called_once_with((150, 150))

    def test_get_target_background_mode_miss(self):
        """Test _get_target returns None in background mode if outside canvas."""
        self.mock_editor.edit_mode = 'background'
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=False)
        target = self.draw_tool._get_target(self.mock_editor, (10, 10)) # Pos outside mock canvas
        self.assertIsNone(target)
        self.mock_editor.canvas_rect.collidepoint.assert_called_once_with((10, 10))

    # --- Tests for _draw_on_sprite ---
    def test_draw_on_sprite_single_pixel(self):
        """Test drawing a single pixel on sprite."""
        grid_pos = (5, 5)
        self.mock_editor.brush_size = 1
        self.mock_editor.eraser_mode = False
        self.draw_tool._draw_on_sprite(self.mock_editor, self.mock_sprite_editor, grid_pos)
        self.mock_sprite_editor.draw_pixel.assert_called_once_with(grid_pos, self.mock_editor.current_color)

    def test_erase_on_sprite_single_pixel(self):
        """Test erasing a single pixel on sprite."""
        grid_pos = (6, 6)
        self.mock_editor.brush_size = 1
        self.mock_editor.eraser_mode = True
        expected_erase_color = (*config.BLACK[:3], 0)
        self.draw_tool._draw_on_sprite(self.mock_editor, self.mock_sprite_editor, grid_pos)
        self.mock_sprite_editor.draw_pixel.assert_called_once_with(grid_pos, expected_erase_color)

    def test_draw_on_sprite_brush_size_3(self):
        """Test drawing with brush size 3 on sprite."""
        grid_pos = (10, 10)
        self.mock_editor.brush_size = 3
        self.mock_editor.eraser_mode = False
        self.draw_tool._draw_on_sprite(self.mock_editor, self.mock_sprite_editor, grid_pos)
        # Expect 3x3 = 9 calls
        self.assertEqual(self.mock_sprite_editor.draw_pixel.call_count, 9)
        # Check one of the calls (e.g., center)
        self.mock_sprite_editor.draw_pixel.assert_any_call(grid_pos, self.mock_editor.current_color)
        # Check another call (e.g., top-left of brush)
        self.mock_sprite_editor.draw_pixel.assert_any_call((9, 9), self.mock_editor.current_color)

    # --- Tests for _draw_on_background ---
    @patch('pygame.draw.circle')
    def test_draw_on_background_no_zoom(self, mock_draw_circle):
        """Test drawing on background with default zoom/pan."""
        screen_pos = (150, 150) # Within canvas_rect
        self.mock_editor.brush_size = 1
        self.mock_editor.eraser_mode = False
        self.mock_editor.editor_zoom = 1.0
        self.mock_editor.view_offset_x = 0
        self.mock_editor.view_offset_y = 0
        
        self.draw_tool._draw_on_background(self.mock_editor, self.mock_editor.current_background, screen_pos)
        
        # Expected original coordinates
        expected_orig_x = 150 - 100 # screen_pos.x - canvas_rect.x
        expected_orig_y = 150 - 100 # screen_pos.y - canvas_rect.y
        expected_radius = 1 # brush_size 1 -> radius 0.5 -> scaled_radius 1
        expected_color = self.mock_editor.current_color[:3] # RGB
        
        mock_draw_circle.assert_called_once_with(self.mock_editor.current_background, 
                                               expected_color, 
                                               (expected_orig_x, expected_orig_y), 
                                               expected_radius)

    @patch('pygame.draw.circle')
    def test_erase_on_background_zoomed_panned(self, mock_draw_circle):
        """Test erasing on background with zoom and pan."""
        screen_pos = (110, 120) # Within canvas_rect
        self.mock_editor.brush_size = 5
        self.mock_editor.eraser_mode = True
        self.mock_editor.editor_zoom = 2.0
        self.mock_editor.view_offset_x = 20
        self.mock_editor.view_offset_y = 40
        
        self.draw_tool._draw_on_background(self.mock_editor, self.mock_editor.current_background, screen_pos)
        
        # Expected original coordinates: ( (screen_x_rel + offset_x) / zoom )
        expected_orig_x = int(((110 - 100) + 20) / 2.0) # ((10) + 20) / 2 = 15
        expected_orig_y = int(((120 - 100) + 40) / 2.0) # ((20) + 40) / 2 = 30
        # Expected radius: max(1, int((brush_size / 2) / zoom)) = max(1, int(2.5 / 2.0)) = max(1, 1) = 1
        expected_radius = 1 
        expected_color = config.WHITE # Eraser color for background
        
        mock_draw_circle.assert_called_once_with(self.mock_editor.current_background, 
                                               expected_color, 
                                               (expected_orig_x, expected_orig_y), 
                                               expected_radius)

    # --- Tests for handle_click ---
    @patch.object(DrawTool, '_draw_on_sprite')
    def test_handle_click_delegates_to_sprite(self, mock_draw_on_sprite):
        """Test handle_click calls _draw_on_sprite correctly."""
        self.mock_editor.edit_mode = 'monster'
        click_pos = (60, 60)
        grid_pos = (10, 10)
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = grid_pos
        
        self.draw_tool.handle_click(self.mock_editor, click_pos)
        
        mock_draw_on_sprite.assert_called_once_with(self.mock_editor, self.mock_sprite_editor, grid_pos)

    @patch.object(DrawTool, '_draw_on_background')
    def test_handle_click_delegates_to_background(self, mock_draw_on_background):
        """Test handle_click calls _draw_on_background correctly."""
        self.mock_editor.edit_mode = 'background'
        click_pos = (150, 150)
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=True)
        
        self.draw_tool.handle_click(self.mock_editor, click_pos)
        
        mock_draw_on_background.assert_called_once_with(self.mock_editor, self.mock_editor.current_background, click_pos)


# --- Tests for FillTool ---
class TestFillTool(unittest.TestCase):

    def setUp(self):
        self.fill_tool = FillTool()
        self.mock_editor = MagicMock()
        # Common editor attributes needed by FillTool
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor.current_color = (0, 255, 0, 255) # Green (fill color)
        # Mock SpriteEditor related things
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = (5, 5) # Mock start grid pos
        
        # Mock pixel access - Need a way to simulate the changing colors during fill
        # Let's use a dictionary to represent a small grid state
        self.mock_grid_state = {
            (5, 5): (255, 0, 0, 255), # Target color (Red)
            (5, 6): (255, 0, 0, 255), # Target color
            (6, 5): (255, 0, 0, 255), # Target color
            (6, 6): (0, 0, 255, 255), # Different color (Blue)
        }
        DEFAULT_COLOR = (0,0,0,0) # Transparent black for other pixels

        def mock_get_pixel(pos):
            return self.mock_grid_state.get(pos, DEFAULT_COLOR)

        def mock_draw_pixel(pos, color):
            # Update the mock grid state when drawing
            if pos in self.mock_grid_state: # Only update tracked pixels for simplicity
                self.mock_grid_state[pos] = color
            # Print for debugging test state if needed:
            # print(f"Mock draw_pixel at {pos} with {color}")
            # print(f" Grid state: {self.mock_grid_state}")

        self.mock_sprite_editor.get_pixel_color.side_effect = mock_get_pixel
        self.mock_sprite_editor.draw_pixel.side_effect = mock_draw_pixel

        # Mock Background related things (less critical as fill is TODO)
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.canvas_rect.collidepoint.return_value = True # Assume hit for bg test
        self.mock_editor.current_background = MagicMock(spec=pygame.Surface)

    @patch.object(FillTool, '_flood_fill_sprite')
    def test_handle_click_calls_flood_fill_sprite(self, mock_flood_fill_sprite):
        """Test handle_click calls _flood_fill_sprite in monster mode."""
        self.mock_editor.edit_mode = 'monster'
        click_pos = (100, 100) # Example screen pos
        start_grid_pos = (5, 5)
        self.mock_sprite_editor.get_grid_position.return_value = start_grid_pos
        
        self.fill_tool.handle_click(self.mock_editor, click_pos)
        
        mock_flood_fill_sprite.assert_called_once_with(self.mock_sprite_editor, 
                                                      start_grid_pos, 
                                                      self.mock_editor.current_color)

    @patch.object(FillTool, '_flood_fill_background')
    def test_handle_click_calls_flood_fill_background(self, mock_flood_fill_background):
        """Test handle_click calls _flood_fill_background in background mode."""
        self.mock_editor.edit_mode = 'background'
        click_pos = (150, 150) # Example screen pos within mock canvas
        
        self.fill_tool.handle_click(self.mock_editor, click_pos)
        
        expected_bg_color = self.mock_editor.current_color[:3] # RGB for background
        mock_flood_fill_background.assert_called_once_with(self.mock_editor,
                                                         self.mock_editor.current_background, 
                                                         click_pos, 
                                                         expected_bg_color)

    def test_flood_fill_sprite_area(self):
        """Test _flood_fill_sprite actually fills contiguous area."""
        start_pos = (5, 5)
        fill_color = self.mock_editor.current_color # Green
        target_color = (255, 0, 0, 255) # Red
        other_color = (0, 0, 255, 255) # Blue

        # Ensure initial state
        self.assertEqual(self.mock_sprite_editor.get_pixel_color(start_pos), target_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((5, 6)), target_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 5)), target_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 6)), other_color)

        # Perform the fill
        self.fill_tool._flood_fill_sprite(self.mock_sprite_editor, start_pos, fill_color)

        # Check final state - Red pixels should now be Green
        self.assertEqual(self.mock_sprite_editor.get_pixel_color(start_pos), fill_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((5, 6)), fill_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 5)), fill_color)
        # Blue pixel should remain unchanged
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 6)), other_color)

    def test_flood_fill_sprite_no_change_needed(self):
        """Test _flood_fill_sprite when start pixel is already fill color."""
        start_pos = (5, 5)
        fill_color = (255, 0, 0, 255) # Red (same as initial target)
        self.mock_editor.current_color = fill_color # Make editor color same
        self.mock_grid_state[start_pos] = fill_color # Set start pixel to fill color
        
        initial_state = self.mock_grid_state.copy()

        self.fill_tool._flood_fill_sprite(self.mock_sprite_editor, start_pos, fill_color)
        
        # Assert draw_pixel was never called
        self.mock_sprite_editor.draw_pixel.assert_not_called()
        # Assert grid state is unchanged
        self.assertEqual(self.mock_grid_state, initial_state)

    def test_handle_drag_does_nothing(self):
        """Verify handle_drag for FillTool does nothing."""
        # Just call it and ensure no errors and no relevant mocks were called
        try:
            self.fill_tool.handle_drag(self.mock_editor, (1,1))
        except Exception as e:
            self.fail(f"FillTool.handle_drag raised exception: {e}")
        # Ensure no drawing methods were called
        self.mock_sprite_editor.draw_pixel.assert_not_called()


# --- Tests for PasteTool ---
class TestPasteTool(unittest.TestCase):

    def setUp(self):
        self.paste_tool = PasteTool()
        self.mock_editor = MagicMock()
        # Attributes needed by PasteTool
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor.copy_buffer = {
            (0, 0): (1, 1, 1, 255), # Pixel 1
            (1, 0): (2, 2, 2, 255), # Pixel 2
            (0, 1): (0, 0, 0, 0),   # Pixel 3 (transparent)
        }
        self.mock_editor.tool_manager = MagicMock(spec=ToolManager) # Needed for auto-switch on empty buffer
        # Mock SpriteEditor related things
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = (10, 10) # Mock paste target pos

        # Mock Background related things (less critical as paste is TODO)
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.canvas_rect.collidepoint.return_value = True
        self.mock_editor.current_background = MagicMock(spec=pygame.Surface)

    @patch.object(PasteTool, '_apply_paste_sprite')
    def test_handle_click_calls_apply_paste_sprite(self, mock_apply_paste_sprite):
        """Test handle_click calls _apply_paste_sprite in monster mode."""
        self.mock_editor.edit_mode = 'monster'
        click_pos = (100, 100)
        paste_grid_pos = (10, 10)
        self.mock_sprite_editor.get_grid_position.return_value = paste_grid_pos
        
        self.paste_tool.handle_click(self.mock_editor, click_pos)
        
        mock_apply_paste_sprite.assert_called_once_with(self.mock_editor, 
                                                      self.mock_sprite_editor, 
                                                      paste_grid_pos)

    @patch.object(PasteTool, '_apply_paste_background')
    def test_handle_click_calls_apply_paste_background(self, mock_apply_paste_background):
        """Test handle_click calls _apply_paste_background in background mode."""
        self.mock_editor.edit_mode = 'background'
        click_pos = (150, 150)
        
        self.paste_tool.handle_click(self.mock_editor, click_pos)
        
        mock_apply_paste_background.assert_called_once_with(self.mock_editor,
                                                          self.mock_editor.current_background, 
                                                          click_pos)

    def test_handle_click_empty_buffer_switches_tool(self):
        """Test handle_click switches to draw tool if copy_buffer is empty."""
        self.mock_editor.copy_buffer = None # Empty buffer
        click_pos = (100, 100)

        self.paste_tool.handle_click(self.mock_editor, click_pos)

        # Assert tool manager was called to switch tool
        self.mock_editor.tool_manager.set_active_tool.assert_called_once_with('draw')
        # Assert draw_pixel wasn't called
        self.mock_sprite_editor.draw_pixel.assert_not_called()

    def test_apply_paste_sprite_logic(self):
        """Test the logic of _apply_paste_sprite."""
        paste_grid_pos = (10, 10)
        
        self.paste_tool._apply_paste_sprite(self.mock_editor, self.mock_sprite_editor, paste_grid_pos)

        # Expect draw_pixel to be called for non-transparent pixels in buffer
        expected_calls = [
            unittest.mock.call((10, 10), (1, 1, 1, 255)), # Pastes (0,0) from buffer at (10,10)
            unittest.mock.call((11, 10), (2, 2, 2, 255)), # Pastes (1,0) from buffer at (11,10)
            # Pixel at (0,1) is transparent, so no call for (10, 11)
        ]
        self.mock_sprite_editor.draw_pixel.assert_has_calls(expected_calls, any_order=True)
        # Ensure exactly 2 calls (only non-transparent pixels)
        self.assertEqual(self.mock_sprite_editor.draw_pixel.call_count, 2)

    def test_apply_paste_sprite_empty_buffer(self):
        """Test _apply_paste_sprite does nothing with empty buffer."""
        self.mock_editor.copy_buffer = None
        paste_grid_pos = (10, 10)

        self.paste_tool._apply_paste_sprite(self.mock_editor, self.mock_sprite_editor, paste_grid_pos)

        self.mock_sprite_editor.draw_pixel.assert_not_called()

    def test_handle_drag_does_nothing(self):
        """Verify handle_drag for PasteTool does nothing."""
        try:
            self.paste_tool.handle_drag(self.mock_editor, (1,1))
        except Exception as e:
            self.fail(f"PasteTool.handle_drag raised exception: {e}")
        self.mock_sprite_editor.draw_pixel.assert_not_called()


# --- Tests for ToolManager ---
class TestToolManager(unittest.TestCase):

    def setUp(self):
        self.mock_editor = MagicMock()
        
        # Mock the actual tool instances
        self.mock_draw_tool = MagicMock(spec=DrawTool)
        self.mock_fill_tool = MagicMock(spec=FillTool)
        self.mock_paste_tool = MagicMock(spec=PasteTool)
        # self.mock_select_tool = MagicMock(spec=SelectionTool) # Select not part of manager yet
        
        # Initialize ToolManager - it will create real tools temporarily
        self.manager = ToolManager(self.mock_editor)
        
        # NOW, replace the instance's tools dict with our mocks
        self.manager.tools = {
            'draw': self.mock_draw_tool,
            'fill': self.mock_fill_tool,
            'paste': self.mock_paste_tool,
            # 'select': self.mock_select_tool
        }
        # Set the active tool to the mock draw tool (matching the default)
        self.manager.active_tool = self.mock_draw_tool
        self.manager.active_tool_name = 'draw'

        # Reset the mocks used in initialization by the real tools
        # (Mainly activate call on the real draw tool)
        # It's cleaner to just verify calls within each test.

    def test_init_default_tool(self):
        """Test ToolManager initializes with the default tool active."""
        # For init test, create a separate instance to check initial state
        temp_manager = ToolManager(self.mock_editor)
        self.assertEqual(temp_manager.active_tool_name, 'draw')
        # Check that the *type* of the active tool is DrawTool
        self.assertIsInstance(temp_manager.active_tool, DrawTool)

    def test_set_active_tool(self):
        """Test switching the active tool calls activate/deactivate."""
        # Reset mocks before test, as setUp involves activate call on real tool
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()
        initial_tool_mock = self.manager.active_tool # Should be mock_draw_tool

        self.manager.set_active_tool('fill')

        self.assertEqual(self.manager.active_tool_name, 'fill')
        self.assertEqual(self.manager.active_tool, self.mock_fill_tool)
        # Check deactivate was called on the mock draw tool
        initial_tool_mock.deactivate.assert_called_once_with(self.mock_editor)
        # Check activate was called on the mock fill tool
        self.mock_fill_tool.activate.assert_called_once_with(self.mock_editor)

    def test_set_invalid_tool(self):
        """Test setting an invalid tool name does not change the active tool."""
        initial_tool_mock = self.manager.active_tool
        initial_name = self.manager.active_tool_name
        # Reset mocks that might have been called during setup/previous tests
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()
        self.mock_paste_tool.reset_mock()

        self.manager.set_active_tool('invalid_tool_name')

        # Assert tool and name remain unchanged
        self.assertEqual(self.manager.active_tool, initial_tool_mock)
        self.assertEqual(self.manager.active_tool_name, initial_name)
        # Ensure no activate/deactivate calls happened on our mocks
        self.mock_draw_tool.deactivate.assert_not_called()
        self.mock_fill_tool.activate.assert_not_called()
        self.mock_paste_tool.activate.assert_not_called()
        self.mock_paste_tool.deactivate.assert_not_called()

    def test_handle_click_delegation(self):
        """Test handle_click delegates to the active tool."""
        click_pos = (50, 60)
        # Set active tool to fill using the method
        self.manager.set_active_tool('fill')
        # Reset mocks called during set_active_tool
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()

        self.manager.handle_click(click_pos)

        # Check fill tool's handle_click was called
        self.mock_fill_tool.handle_click.assert_called_once_with(self.mock_editor, click_pos)
        # Ensure other tools weren't called
        self.mock_draw_tool.handle_click.assert_not_called()
        self.mock_paste_tool.handle_click.assert_not_called()

    def test_handle_drag_delegation(self):
        """Test handle_drag delegates to the active tool."""
        drag_pos = (70, 80)
        # Active tool is 'draw' after setUp
        # Reset mocks before test
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()
        self.mock_paste_tool.reset_mock()

        self.manager.handle_drag(drag_pos)

        # Check draw tool's handle_drag was called
        self.mock_draw_tool.handle_drag.assert_called_once_with(self.mock_editor, drag_pos)
        # Ensure other tools weren't called
        self.mock_fill_tool.handle_drag.assert_not_called()
        self.mock_paste_tool.handle_drag.assert_not_called()

# Run tests if this file is executed directly
if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/.DS_Store
================================================
[Non-text file]



