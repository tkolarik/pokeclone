Directory structure:
â””â”€â”€ pokeclone/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ ToDo.md
    â”œâ”€â”€ battle_simulator.py
    â”œâ”€â”€ main_menu.py
    â”œâ”€â”€ pixle_art_editor.py
    â”œâ”€â”€ requirements-dev.txt
    â”œâ”€â”€ requirements.txt
    â”œâ”€â”€ backgrounds/
    â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ monsters.json
    â”‚   â”œâ”€â”€ moves.json
    â”‚   â”œâ”€â”€ type_chart.json
    â”‚   â”œâ”€â”€ maps/
    â”‚   â”‚   â”œâ”€â”€ demo_tiles.json
    â”‚   â”‚   â”œâ”€â”€ demo_tiles_new.json
    â”‚   â”‚   â”œâ”€â”€ map.json
    â”‚   â”‚   â”œâ”€â”€ map_one.json
    â”‚   â”‚   â”œâ”€â”€ map_two.json
    â”‚   â”‚   â””â”€â”€ world_layout.json
    â”‚   â””â”€â”€ tilesets/
    â”‚       â””â”€â”€ basic_overworld.json
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ map-editor-design.md
    â”‚   â””â”€â”€ overworld-system-design.md
    â”œâ”€â”€ references/
    â”œâ”€â”€ scripts/
    â”‚   â”œâ”€â”€ convert_sprites.py
    â”‚   â”œâ”€â”€ create_empty_sprites.py
    â”‚   â””â”€â”€ create_test_ref_image.py
    â”œâ”€â”€ songs/
    â”œâ”€â”€ sounds/
    â”‚   â”œâ”€â”€ .DS_Store
    â”‚   â”œâ”€â”€ monsters/
    â”‚   â””â”€â”€ moves/
    â”œâ”€â”€ sprites/
    â”‚   â””â”€â”€ .DS_Store
    â”œâ”€â”€ sprites_backup/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ backgrounds/
    â”‚   â”œâ”€â”€ battle/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ battle_simulator.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ core/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ config.py
    â”‚   â”‚   â”œâ”€â”€ event_handler.py
    â”‚   â”‚   â”œâ”€â”€ tileset.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ editor/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ dialog_manager.py
    â”‚   â”‚   â”œâ”€â”€ editor_ui.py
    â”‚   â”‚   â”œâ”€â”€ pixle_art_editor.py
    â”‚   â”‚   â”œâ”€â”€ selection_manager.py
    â”‚   â”‚   â”œâ”€â”€ sprite_editor.py
    â”‚   â”‚   â”œâ”€â”€ tool_manager.py
    â”‚   â”‚   â”œâ”€â”€ undo_redo_manager.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ overworld/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ map_editor.py
    â”‚   â”‚   â”œâ”€â”€ overworld.py
    â”‚   â”‚   â”œâ”€â”€ state.py
    â”‚   â”‚   â”œâ”€â”€ world_view.py
    â”‚   â”‚   â””â”€â”€ __pycache__/
    â”‚   â”œâ”€â”€ songs/
    â”‚   â”œâ”€â”€ sounds/
    â”‚   â”œâ”€â”€ sprites/
    â”‚   â””â”€â”€ ui/
    â”‚       â”œâ”€â”€ __init__.py
    â”‚       â”œâ”€â”€ main_menu.py
    â”‚       â”œâ”€â”€ ui_manager.py
    â”‚       â””â”€â”€ __pycache__/
    â”œâ”€â”€ tests/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ _test_pixle_art_editor.py
    â”‚   â”œâ”€â”€ test_battle_simulator.py
    â”‚   â”œâ”€â”€ test_editor_ui.py
    â”‚   â”œâ”€â”€ test_event_handler.py
    â”‚   â”œâ”€â”€ test_main_menu.py
    â”‚   â”œâ”€â”€ test_overworld_state.py
    â”‚   â”œâ”€â”€ test_sprite_editor.py
    â”‚   â”œâ”€â”€ test_tool_manager.py
    â”‚   â”œâ”€â”€ .DS_Store
    â”‚   â”œâ”€â”€ __pycache__/
    â”‚   â””â”€â”€ assets/
    â””â”€â”€ tiles/
        â””â”€â”€ basic_overworld/
            â””â”€â”€ npcs/
                â”œâ”€â”€ npc_guide/
                â””â”€â”€ test/

================================================
File: README.md
================================================
# PokeClone

A Pygame-based monster battling game featuring unique creatures with elemental types and special moves, along with an advanced pixel art editor for creating and editing sprites.

![Game Screenshot](docs/images/screenshot.png) <!-- TODO: Add actual screenshot -->

## ğŸ® Features

### Core Gameplay
- **Turn-based Combat System**: Engage in strategic battles where type advantages play a crucial role.
- **28 Unique Monsters**: Each monster comes with distinct stats and movesets.
- **80+ Different Moves**: A wide array of attacks and effects to enhance battles.
- **15 Elemental Types**: Diverse types with complex interactions to add depth to combat.
- **Stat Modification**: Utilize strategic buff and debuff mechanics to gain the upper hand.

### Pixel Art Editor
- **Advanced Editing Tools**: Selection, copy-paste, mirroring, and rotating tools for precise sprite editing.
- **Customizable Brush Sizes**: Adjust brush sizes to suit different editing needs.
- **Scrollable Color Palette**: Access a comprehensive range of colors for detailed sprite creation.
- **Sprite Management**: Easily switch between front and back sprites for each monster.
- **Undo/Redo Functionality**: Revert or reapply changes with ease.
- **Integration with Game**: Seamlessly create and edit sprites that integrate directly into the game.

### Elemental Types
- ğŸ”¥ Fire
- ğŸ’§ Water
- ğŸŒ Earth
- ğŸ’¨ Wind
- âš¡ Electric
- â„ï¸ Ice
- ğŸŒ¿ Nature
- ğŸ§  Mind
- ğŸ‘» Shadow
- âœ¨ Light
- ğŸ”§ Metal
- â˜ ï¸ Toxic
- ğŸ”Š Sound
- ğŸ’ Crystal
- ğŸŒŒ Cosmic

## ğŸš€ Getting Started

### Prerequisites
- **Python 3.6+**
- **Pygame library**
- **Tkinter** (usually included with Python)
- **Graphics card with OpenGL support** (recommended for optimal performance)

### Installation

1. **Clone the repository:**
    ```bash
    git clone https://github.com/yourusername/pokeclone.git
    cd pokeclone
    ```

2. **Create and activate a virtual environment (recommended):**
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```

3. **Install required dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

### Running the Game
```bash
python battle_simulator.py
```

### Using the Pixel Art Editor
1. **Run the Pixel Art Editor:**
    ```bash
    python pixel_art_editor.py
    ```

2. **Create or Edit Sprites:**
    - **Select Editing Mode:** Choose between editing monster sprites or background images.
    - **Use Tools:** Utilize selection, brush, eraser, fill, and other tools to create detailed pixel art.
    - **Save Your Work:** Save your edited sprites, which will be used in the main game.

## ğŸ¯ Game Mechanics

### Battle System
- **Turn-based Combat**: Players and opponents take turns selecting moves to attack or apply effects.
- **Type Effectiveness Multipliers**: Deals more or less damage based on the interaction between elemental types.
- **Switching Turns**: After a player uses a move, the opponent selects a move to respond.

### Stats System
- **HP (Health Points)**: Determines how much damage a creature can take before being defeated.
- **Attack**: Influences the damage dealt by physical moves.
- **Defense**: Reduces incoming physical damage.
- **Type Advantages/Disadvantages**: Certain types are stronger or weaker against others, affecting damage calculations.

### Move Categories
- **Damage Moves**: Deals direct damage with type advantages.
- **Buff Moves**: Enhances the user's stats.
- **Debuff Moves**: Reduces the opponent's stats.

## ğŸ—‚ï¸ Project Structure

```
pokeclone/
â”œâ”€â”€ battle_simulator.py     # Entry point script for the battle simulator
â”œâ”€â”€ pixle_art_editor.py     # Entry point script for the pixel art editor
â”œâ”€â”€ requirements.txt        # Project dependencies
â”œâ”€â”€ README.md               # This file
â”œâ”€â”€ LICENSE                 # MIT License (Assumed, add if exists)
â”œâ”€â”€ ToDo.md                 # KANBAN/ToDo list
â”œâ”€â”€ scripts/                # Utility and conversion scripts
â”‚   â”œâ”€â”€ convert_sprites.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ src/                    # Main source code directory
â”‚   â”œâ”€â”€ __init__.py         # Makes src a package
â”‚   â”œâ”€â”€ core/               # Core components (config, event handling)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â””â”€â”€ event_handler.py
â”‚   â”œâ”€â”€ battle/             # Battle simulator logic
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ battle_simulator.py
â”‚   â”œâ”€â”€ editor/             # Pixel art editor logic and UI
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ pixle_art_editor.py
â”‚   â”‚   â”œâ”€â”€ editor_ui.py
â”‚   â”‚   â”œâ”€â”€ sprite_editor.py
â”‚   â”‚   â””â”€â”€ ... (tool_manager, selection_manager, etc.)
â”‚   â””â”€â”€ ui/                 # General UI components (if any)
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ ui_manager.py
â”œâ”€â”€ data/                   # Game data files
â”‚   â”œâ”€â”€ monsters.json       # Monster definitions
â”‚   â”œâ”€â”€ moves.json          # Move definitions
â”‚   â””â”€â”€ type_chart.json     # Type effectiveness data
â”œâ”€â”€ sprites/                # Monster sprite images (native resolution)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ sprites_backup/         # Backups of original sprites (if conversion script used)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ backgrounds/            # Battle background images
â”‚   â””â”€â”€ ...
â”œâ”€â”€ sounds/                 # Game sound effects
â”‚   â””â”€â”€ ...
â”œâ”€â”€ songs/                  # Background music tracks
â”‚   â””â”€â”€ ...
â””â”€â”€ tests/                  # Unit and integration tests
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ test_battle_simulator.py
    â””â”€â”€ ...
```

## ğŸ® Controls

### In-Game Controls
- **Mouse Controls**
  - **Left Click**: Select options and moves.

### Pixel Art Editor Controls
- **Mouse Controls**
  - **Left Click**: Select pixels or interact with UI elements.
  - **Right Click**: Activate eraser mode.
  - **Scroll Wheel**: Zoom in and out.
- **Keyboard Shortcuts**
  - **Ctrl + Z**: Undo.
  - **Ctrl + Y**: Redo.
  - **Ctrl + S**: Save current work.
  - **Ctrl + O**: Open a background file.
  - **Ctrl + C**: Copy selected area.
  - **Ctrl + V**: Paste copied area.
  - **Ctrl + M**: Mirror selected area.
  - **Ctrl + R**: Rotate selected area.
  - **+/-**: Increase or decrease brush size.
  - **ESC**: Exit selection mode.

## ğŸ› ï¸ Development

### Building from Source
```bash
git clone https://github.com/yourusername/pokeclone.git
cd pokeclone
pip install -r requirements.txt
python battle_simulator.py
```

### Contributing
1. **Fork the repository**
2. **Create a feature branch**
    ```bash
    git checkout -b feature/AmazingFeature
    ```
3. **Commit your changes**
    ```bash
    git commit -m 'Add AmazingFeature'
    ```
4. **Push to the branch**
    ```bash
    git push origin feature/AmazingFeature
    ```
5. **Open a Pull Request**

## ğŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ¤ Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

## ğŸ› Bug Reports

Please use the GitHub Issues tab to report bugs. Include:
- Expected behavior
- Actual behavior
- Steps to reproduce
- Python/Pygame versions
- Operating system

## âœ¨ Acknowledgments

- All monster and move names are original creations.
- Inspired by classic monster-battling games.
- Thanks to Anthropic and OpenAI for their excellent assistants.

## ğŸ“š Documentation

Coming Soon 

---

Made with â¤ï¸ by Thomas Kolarik, Claude, ChatGPTo1-mini


================================================
File: ToDo.md
================================================
# PokeClone Project KANBAN Board (Detailed - 2025-04-06 v6)

---

## To Do

### Highest Priority

* **[OVERWORLD-1] Implement Basic Overworld Functionality (Completed)**
    * **Type:** Feature
    * **Priority:** Highest
    * **Description:** Establish the foundational overworld gameplay loop and architecture. This milestone introduces a new "Overworld" game mode, distinct from the battle simulator and pixel art editor, and accessible via a main menu. The overworld will serve as the player's primary navigation and exploration interface, laying the groundwork for future features such as encounters, NPCs, and map-based events.
    * **Scope:**
        * **Game Loop & State Management:**  
          - Create a dedicated overworld state within the main application, with clear transitions to/from other modes (battle, editor, main menu).
          - Implement a basic game loop for the overworld, handling input, updates, and rendering.
        * **Player Character:**  
          - Define a player avatar (sprite or placeholder) that can be moved around the map using keyboard input (e.g., arrow keys or WASD).
          - Track player position and direction.
        * **Map Structure:**  
          - Design a simple tile-based map system (e.g., 2D grid of tiles, loaded from a JSON or CSV file).
          - Support for at least one sample map with walkable and non-walkable tiles (e.g., walls, grass, water).
          - Render the map and player character to the screen.
        * **Movement & Collision:**  
          - Implement basic movement logic, including collision detection with impassable tiles.
          - Smooth or grid-based movement (choose one for initial implementation).
        * **Interactions:**  
          - Allow the player to interact with the environment (e.g., pressing a key to trigger an action or display a message when facing an interactive tile).
          - Placeholder for future NPC or object interactions.
        * **Mode Switching:**  
          - Add a main menu option to enter the overworld mode.
          - Provide a way to exit back to the main menu.
    * **Acceptance Criteria:**
        * The player can enter the overworld mode from the main menu.
        * The overworld displays a map and a controllable player character.
        * Player movement is responsive and respects map boundaries/collisions.
        * At least one type of interactive tile or object is present (even if only as a placeholder).
        * The player can return to the main menu from the overworld.
        * The code is organized to allow future expansion (e.g., adding NPCs, wild encounters, map transitions).
    * **Testing:**
        * Manual testing confirms all acceptance criteria.
        * Unit tests cover overworld state movement, collision, and interaction logic.
    * **Implementation Notes (Completed):**
        * Added a dedicated overworld state module (map, player, movement, interactions).
        * Implemented a pygame overworld runner with a tile map, player movement, and message prompts.
        * Added a main menu entrypoint that can launch overworld, battle simulator, or pixel art editor.
        * Added a basic message box for interactive tiles and ESC to return to the main menu.
    * **Labels:** `feature`, `overworld`, `gameplay`, `architecture`, `core`, `map`, `player`, `input`

* **[OVERWORLD-6] Implement Overworld Runtime (per design doc)**
    * **Type:** Feature
    * **Priority:** Highest
    * **Description:** Implement/align the overworld runtime systems according to `docs/overworld-system-design.md` so the game has a stable, testable contract that tooling (map editor, tile manager, audio) can target.
    * **Acceptance Criteria:**
        * The runtime behavior matches `docs/overworld-system-design.md` for movement, collision, interactions, triggers/actions, connections/portals, and per-map audio.
        * The overworld consumes the map schema defined in `docs/map-editor-design.md` without manual data edits.
        * **Testing:** Unit/integration tests cover collision, trigger ordering, connection transitions, and music switching as described in the design doc.
    * **Labels:** `feature`, `overworld`, `runtime`, `architecture`, `gameplay`


### High Priority

* **[OVERWORLD-3] Implement Map Editor (per design doc)**
    * **Type:** Feature
    * **Priority:** High
    * **Description:** Build the overworld map editor according to `docs/map-editor-design.md`, enabling creation, editing, saving, and loading of maps that the overworld runtime can consume.
    * **Acceptance Criteria:**
        * The implementation follows `docs/map-editor-design.md` (UX, data model, validation, and integration points).
        * The editor can create, edit, save, and load maps that the overworld can render and navigate without errors.
        * **Testing:** Manual end-to-end test per the workflow described in `docs/map-editor-design.md`.
    * **Labels:** `feature`, `overworld`, `map`, `editor`, `tools`

* ~~**[OVERWORLD-4] Extend Pixel Art Editor for Tiles + Tile Manager**~~ **(Completed)**
    * Added tile edit mode with animated multi-frame support, tileset save/load, and tile browser.
    * Added tileset-backed overworld rendering and sample data.
    * Added NPC sprite editing (states/angles/frames) alongside tilesets.

* **[OVERWORLD-5] Add Overworld Music Per Map**
    * **Type:** Feature
    * **Priority:** High
    * **Description:** Add overworld music support with per-map soundtrack assignment so each map can define its own background music.
    * **Acceptance Criteria:**
        * Each map definition can reference a music track (by filename or ID).
        * Entering a map plays its assigned track and stops or fades out the previous map's track.
        * A default overworld track is used when a map does not specify one.
        * **Testing:** Manual testing confirms music switches correctly when changing maps and the default plays when no track is assigned.
    * **Labels:** `audio`, `overworld`, `feature`, `music`, `maps`

### Medium Priority

* **[POKE-11] Improve Pixel Editor UI/UX Feedback**
    * **Type:** Improvement
    * **Priority:** Medium
    * **Description:** The pixel art editor currently lacks some key visual feedback... (previous description remains) ...Review and correct the panning logic to use standard mouse wheel events (`event.y` for vertical) and potentially implement panning via middle-mouse drag or keyboard modifiers + mouse drag for more control.
    * **Acceptance Criteria:**
        * The currently selected drawing/editing tool is clearly indicated visually.
        * Zooming feels intuitive, potentially centering on the cursor.
        * Panning works predictably using standard controls.
        * **Testing:** Manual testing confirms that the visual indicator for the active tool is present and updates correctly.
        * **Testing:** Manual testing confirms that zoom behavior is intuitive and centers correctly (either on view or cursor, as implemented).
        * **Testing:** Manual testing confirms that panning controls work as expected and feel natural.
    * **Labels:** `ui`, `ux`, `editor`, `improvement`, `input`

* **[POKE-12] Enhance Opponent Battle AI**
    * **Type:** Improvement
    * **Priority:** Medium
    * **Description:** The current AI for the opponent in `battle_simulator.py` (`opponent_choose_move` function) is extremely basic... (previous description remains) ...Start by implementing basic type effectiveness considerations and perhaps HP awareness.
    * **Acceptance Criteria:**
        * The `opponent_choose_move` function uses game state information (e.g., types, HP) to make move decisions.
        * The opponent's behavior is noticeably more strategic than pure random selection.
        * The complexity can be increased incrementally.
        * **Testing:** Manual playtesting across several battles confirms the AI makes decisions that are more strategic than random.
        * **Testing:** Unit/integration tests (if applicable to the AI logic modules) are *written and pass*, verifying correct processing of game state.
    * **Labels:** `battle-system`, `ai`, `improvement`, `gameplay`

* **[POKE-13] Implement Battle Sound Effects**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** While the game has background music functionality (`battle_simulator.py` `play_random_song`), it lacks sound effects... (previous description remains) ...Ensure multiple sounds can play without cutting each other off abruptly (Pygame's mixer handles channels automatically to some extent).
    * **Acceptance Criteria:**
        * Sound effect files are present in the `sounds/` directory.
        * Sounds are loaded using `pygame.mixer.Sound`.
        * Key battle events (attacks, damage, faints, stat changes, win/loss) trigger corresponding sound effects.
        * Sound effects enhance the battle experience.
        * **Testing:** Manual testing confirms that appropriate sounds play at the correct times during battle sequences and that sounds do not excessively overlap or cut each other off.
    * **Labels:** `audio`, `battle-system`, `feature`, `immersion`, `ux`

* **[POKE-14] Refine Editor Tool State Management (Select/Paste/Mirror/Rotate)**
    * **Type:** Improvement / Bug
    * **Priority:** Medium
    * **Description:** Managing the editor's current mode (e.g., 'draw', 'select', 'paste') and how tools interact with these modes seems complex... (previous description remains) ...Refactor the `handle_event` and related functions to adhere to this explicit state management logic. This might be done as part of POKE-10.
    * **Acceptance Criteria:**
        * Editor modes (Draw, Select, Fill, Paste) and tool activations follow clear, predictable rules.
        * State transition logic is centralized or clearly managed.
        * Interactions like selecting colors or clicking buttons have consistent effects on the current mode.
        * Paste mode allows multiple placements until explicitly cancelled.
        * Using Copy, Mirror, Rotate behaves logically with respect to the active selection and mode.
        * **Testing:** Manual testing confirms that switching between tools and modes behaves predictably according to the defined rules.
        * **Testing:** Unit tests for the state machine/manager logic are *written and pass*.
    * **Labels:** `editor`, `state-management`, `refactoring`, `ux`, `bug`, `architecture`
    * **Depends On:** POKE-10 (potentially)

* **[POKE-23] Add Clipboard History + Persistent Favorite Paste Patterns**
    * **Type:** Feature
    * **Priority:** Medium
    * **Description:** Extend the existing copy/paste workflow in the pixel art editor with a clipboard history (multiple recently copied selections/patterns) and session-to-session persistent â€œfavoritesâ€ for frequently reused patterns.
    * **Acceptance Criteria:**
        * Copy operations add the current selection/pattern to a bounded clipboard history (most-recent-first).
        * Users can browse/select an item from clipboard history to paste (via UI and/or hotkeys).
        * Users can mark clipboard items as favorites; favorites persist across app restarts.
        * Pasting a history/favorite item behaves like the current paste tool (preview + placement + cancel), without breaking existing copy/paste behavior.
    * **Testing:**
        * **Manual:** Confirms history ordering, favorite persistence, and correct paste placement across editor restarts.
        * **Automated (Unit/Integration):**
          - Clipboard history behavior: capacity limit, MRU ordering, and immutability (stored items donâ€™t change when the canvas changes).
          - Favorites persistence: save â†’ reload roundtrip preserves IDs/metadata/pixel data; missing/corrupt favorites file does not crash (loads empty with warning).
          - Paste computation: given a stored pattern + cursor position, computed paste bounds and applied pixels match expected, including clipping at canvas edges.
          - Undo/redo integration: pasting from history/favorite creates the intended undo granularity and restores exact pixels on undo/redo.
          - (If separable) Hotkey/UI selection: selecting next/prev clipboard item updates active paste source state without mutating history.
    * **Labels:** `editor`, `feature`, `ux`, `clipboard`, `pasting`, `persistence`

* **[TEST-1] Set up Unit Testing Framework**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** The project currently lacks automated tests... (previous description remains) ...Ensure basic setup allows tests to be written and executed easily.
    * **Acceptance Criteria:**
        * A testing framework (`unittest` or `pytest`) is added as a development dependency.
        * Project structure includes a dedicated `tests/` directory.
        * A sample test runs successfully using the framework's runner (e.g., `python -m unittest discover` or `pytest`).
        * Instructions for running tests are added (e.g., to README or a CONTRIBUTING guide).
        * **Testing:** Running the test runner executes the sample test and reports success. (AC inherently covers testing).
    * **Labels:** `testing`, `infrastructure`, `code-quality`

* **[TEST-2] Write Unit Tests for Damage Calculation Logic**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** The `calculate_damage` function in `battle_simulator.py` contains critical game logic... (previous description remains) ...(Optional) Mocking `random.uniform` to test the damage range calculation deterministically.
    * **Acceptance Criteria:**
        * A test suite exists for `calculate_damage`.
        * Tests cover various type effectiveness scenarios.
        * Tests cover stat-changing moves (0 power).
        * Tests pass reliably.
        * **Testing:** Running the test suite executes all *written* damage calculation tests and reports success. (AC inherently covers testing).
    * **Labels:** `testing`, `battle-system`, `code-quality`
    * **Depends On:** TEST-1, POKE-5 (for effectiveness values)

* **[TEST-3] Write Unit Tests for Stat Modification Logic**
    * **Type:** Task
    * **Priority:** Medium
    * **Description:** The `apply_stat_change` function (and potentially the underlying formula if POKE-7 is done) in `battle_simulator.py` modifies creature stats... (previous description remains) ...Potential edge cases (e.g., hitting max/min stat stages if implemented).
    * **Acceptance Criteria:**
        * A test suite exists for stat modification logic.
        * Tests cover buffs and debuffs for relevant stats.
        * Tests validate the calculated stat values against expected outcomes based on the implemented formula/stage system.
        * Tests pass reliably.
        * **Testing:** Running the test suite executes all *written* stat modification tests and reports success. (AC inherently covers testing).
    * **Labels:** `testing`, `battle-system`, `code-quality`
    * **Depends On:** TEST-1

* **[TEST-4] Add Integration Test for Editor Startup**
    * **Type:** Task / Testing
    * **Priority:** Medium
    * **Description:** The current unit tests mock dependencies heavily and didn't catch an `AttributeError` related to `config.monsters` not being set during application startup via the root entry point script (`pixle_art_editor.py`). Create an integration test that attempts to launch the editor application (e.g., by running the entry script or using `python -m src.editor.pixle_art_editor`) and verifies that it initializes completely without crashing, including loading necessary data like monsters.
    * **Acceptance Criteria:**
        * An integration test exists that simulates application startup for the pixel art editor.
        * The test verifies that the editor initializes without critical errors (like the `AttributeError` for `config.monsters`).
        * The test uses minimal mocking, focusing on the integration of components during startup.
        * The test passes reliably.
    * **Labels:** `testing`, `integration-test`, `code-quality`, `editor`, `startup`

* **[REFACTOR-1] Inject Dependencies into Editor Class**
    * **Type:** Refactoring / Improvement
    * **Priority:** Medium
    * **Description:** The `Editor` class in `src/editor/pixle_art_editor.py` currently relies on globally loaded monster data (`config.monsters`) set by the entry point script. This makes the class harder to test in isolation and couples it to the startup sequence. Refactor the `Editor` class to accept dependencies like the loaded monster data via its constructor (`__init__`) instead of relying on global state. Update the entry point script (`pixle_art_editor.py`) to load the data and pass it to the `Editor` instance.
    * **Acceptance Criteria:**
        * `Editor.__init__` accepts necessary data (like loaded monster list) as arguments.
        * The `Editor` class uses the passed-in data instead of relying on `config.monsters`.
        * The root entry point script (`pixle_art_editor.py`) loads the data and passes it correctly during `Editor` instantiation.
        * Existing functionality remains unchanged.
        * Unit tests for `Editor` are potentially easier to write/maintain.
    * **Labels:** `refactoring`, `architecture`, `code-quality`, `maintainability`, `editor`, `dependency-injection`, `testing`

### Low Priority

* **[POKE-15] Remove Magic Numbers from Codebase**
    * **Type:** Task / Improvement
    * **Priority:** Low
    * **Description:** Throughout the codebase (especially in UI layout calculations...) ... (previous description remains) ...The goal is to improve code readability and make future adjustments easier.
    * **Acceptance Criteria:**
        * Hardcoded numerical literals with unclear meaning are replaced by named constants.
        * Code readability is improved.
        * **Testing:** Code review confirms removal of magic numbers.
        * **Testing:** Manual regression testing confirms the changes haven't introduced functional bugs.
    * **Labels:** `code-quality`, `refactoring`, `maintainability`

* **[POKE-16] Add Robust Error Handling**
    * **Type:** Task / Improvement
    * **Priority:** Low
    * **Description:** While some basic error handling exists... (previous description remains) ...Ensure user actions like cancelling dialogs don't cause errors.
    * **Acceptance Criteria:**
        * Common file I/O errors are caught and handled gracefully.
        * Potential Pygame errors in critical sections are handled.
        * The application provides user feedback on errors where appropriate, rather than just crashing.
        * **Testing:** Manual testing involves attempting to trigger expected errors (e.g., deleting a required file, read-only permissions, cancelling save dialogs) and verifying the application handles them gracefully without crashing.
        * **Testing:** Code review confirms appropriate `try...except` blocks are added.
    * **Labels:** `code-quality`, `robustness`, `error-handling`, `ux`

* **[POKE-17] Add Missing README Screenshot and Documentation**
    * **Type:** Task
    * **Priority:** Low
    * **Description:** The project's `README.md` file currently has placeholders... (previous description remains) ...Either add relevant developer/user documentation under the "Documentation" section or remove the section if no additional documentation is planned beyond the README itself.
    * **Acceptance Criteria:**
        * The screenshot path in `README.md` points to an actual, relevant image file committed to the repository.
        * The "Documentation" section is either populated or removed.
        * The README accurately reflects the project's current state.
        * **Testing:** Manual visual inspection of the rendered `README.md` confirms the screenshot displays correctly and the documentation section is appropriately handled.
    * **Labels:** `documentation`, `readme`, `assets`

* **[POKE-18] Optimize Editor Undo/Redo Memory Usage**
    * **Type:** Improvement
    * **Priority:** Low
    * **Description:** The pixel editor's undo/redo system (`pixle_art_editor.py` `save_state`, `undo`, `redo` methods) currently works by saving complete copies... (previous description remains) ...This is likely a significant refactoring effort and should only be undertaken if memory usage proves problematic.
    * **Acceptance Criteria:**
        * (If implemented) The undo/redo system consumes measurably less memory per step, especially for large canvases.
        * Undo/Redo functionality remains correct and reliable for all editing operations.
        * **Testing:** Performance testing compares memory usage before and after optimization under heavy editing scenarios.
        * **Testing:** Manual regression testing confirms undo/redo still works correctly for all tools and actions after optimization. Relevant unit tests (if applicable to the optimization logic) are *written/updated and pass*.
    * **Labels:** `editor`, `performance`, `memory`, `optimization`, `improvement`, `refactoring`

* **[POKE-19] Adjust Creature Sprite Positioning in Battle View**
    * **Type:** Improvement
    * **Priority:** Low
    * **Description:** In the battle screen (`battle_simulator.py` `draw_battle` function), the creature sprites are drawn using coordinates calculated relative to the bottom of the screen... (previous description remains) ...Experiment with different positioning strategies or offsets for the creature sprites...
    * **Acceptance Criteria:**
        * Creature sprite positions in the battle view are visually appealing and well-integrated with other UI elements.
        * Positioning logic is clear and potentially uses constants from POKE-1 (Done).
        * **Testing:** Manual visual inspection confirms the new layout looks good across different potential sprite sizes (if applicable) and screen resolutions (if relevant).
    * **Labels:** `ui`, `ux`, `battle-system`, `visuals`, `improvement`

* **[POKE-20] Perform Balance Pass on Stat Changes and Damage**
    * **Type:** Task / Improvement
    * **Priority:** Low
    * **Description:** After implementing changes to the stat modification formula (POKE-7 - Done) and completing the type chart (POKE-5), the overall balance of combat needs review... (previous description remains) ...Adjust base stats (`monsters.json`), move powers (`moves.json`), stat change magnitudes (POKE-7 logic - Done), or type effectiveness multipliers (POKE-5 data) as needed...
    * **Acceptance Criteria:**
        * Combat feels relatively balanced â€“ no single type or strategy is overwhelmingly dominant without counterplay.
        * Stat changes have a noticeable but not game-breaking impact.
        * Battles last a reasonable number of turns on average.
        * Adjustments to data files (`monsters.json`, `moves.json`, `type_chart.json`) or formulas are documented.
        * **Testing:** Extensive playtesting by one or more individuals confirms the subjective feel of balance and identifies any remaining dominant strategies or frustrating mechanics. Playtest results are summarized.
    * **Labels:** `balancing`, `gameplay`, `battle-system`, `improvement`, `testing`
    * **Depends On:** POKE-5

---

## In Progress

* **[POKE-10] Refactor Pixel Art Editor for Modularity**
    * **Type:** Task / Improvement
    * **Priority:** Medium
    * **Description:** The main file for the pixel art editor, `pixle_art_editor.py`, has grown very large... (previous description remains) ...Refactor the `Editor` class and `handle_event` method to delegate responsibilities to these new components.
    * **Acceptance Criteria:**
        * The codebase for the pixel editor is organized into multiple smaller, well-defined modules/classes.
        * The main editor file (`pixle_art_editor.py` or its replacement) is significantly shorter and less complex.
        * Responsibilities are clearly separated (e.g., tool logic is separate from UI drawing).
        * The editor's functionality remains intact or is improved.
        * Code is more readable and maintainable.
        * **Testing:** Integration tests are *written and pass*, confirming that the refactored modules work together correctly within the main application loop.
        * **Testing:** Manual regression testing confirms all previous editor functionalities work as expected after refactoring.
    * **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`

***
##### POKE-10 Sub-Tasks:

*   **[POKE-10.4] Refactor UI Drawing (`draw_ui`)**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium
    *   **Description:** Simplify the `Editor.draw_ui` method by extracting UI drawing responsibilities. Move drawing logic for specific components (sprite editors view, background canvas view, palette, sliders, info text) into separate functions or methods, potentially within an `UIManager` or `EditorUI` class (using `ui_manager.py` or `editor_ui.py`). `Editor.draw_ui` should become primarily an orchestrator.
    *   **Acceptance Criteria:**
        *   The `Editor.draw_ui` method is significantly shorter and delegates drawing tasks.
        *   Drawing logic for distinct UI areas is encapsulated in separate functions/methods/classes.
        *   The overall UI appearance and layout remain unchanged.
        *   Relevant integration tests are **written and pass** to verify that `draw_ui` invokes sub-drawing routines correctly (may require surface mocking).
        *   Manual regression testing confirms the UI renders correctly in all modes.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `ui`, `drawing`, `testing`

*   **[POKE-10.5] Refactor State Management**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium
    *   **Description:** Centralize or better encapsulate the editor's state management. Aspects like `current_color`, `mode`, `edit_mode`, `brush_size`, `editor_zoom`, `view_offset`, undo/redo stacks, etc., could be grouped into a dedicated state object/class. Access to and modification of state should be managed through clearer interfaces.
    *   **Acceptance Criteria:**
        *   Editor state variables are grouped logically (e.g., in a dedicated state class).
        *   Access and modification of state are handled through well-defined methods or properties.
        *   The `Editor` class and other components access state through the new mechanism.
        *   All editor functionality relying on this state continues to work correctly.
        *   Relevant unit tests are **written and pass** for the state management logic, verifying state transitions and access.
        *   Manual regression testing confirms no state-related regressions.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `state-management`, `testing`

*   **[POKE-10.6] Refactor File I/O and Dialogs**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium-Low
    *   **Description:** Extract file loading/saving logic (monsters, sprites, backgrounds, reference images) and dialog interactions (including the Pygame-based dialog system and any remaining Tkinter calls) from the `Editor` class. This logic could reside in dedicated file I/O modules and a `DialogManager` (using `dialog_manager.py`).
    *   **Acceptance Criteria:**
        *   File loading/saving logic is moved out of the `Editor` class.
        *   Dialog presentation and handling logic are managed by a dedicated system (e.g., `DialogManager`).
        *   The `Editor` class calls the appropriate I/O or dialog functions.
        *   All file operations and dialog interactions work correctly.
        *   Relevant unit/integration tests are **written and pass** for file I/O functions (mocking FS access) and dialog management logic (testing state transitions/callbacks).
        *   Manual regression testing confirms all file and dialog operations work correctly.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `file-io`, `dialogs`, `ui`, `testing`
    *   **Depends On:** Potentially `POKE-9`

---

## On Hold

* **[POKE-9] Fix Tkinter Initialization Conflicts**
    * **Type:** Bug / Task
    * **Priority:** Medium
    * **Description:** The pixel art editor (`pixle_art_editor.py`) relies on Python's built-in Tkinter library for the color picker and file dialogs (e.g., loading reference images), and removing it is currently blocked ([See ToDo](#on-hold)). However, initializing Tkinter (`tk.Tk()`) *after* Pygame (`pygame.init()`) can cause crashes on some systems (especially macOS) due to conflicts between SDL and Tkinter interacting with the windowing system (e.g., `-[SDLApplication macOSVersion]: unrecognized selector`). The goal is to fix this crash by ensuring Tkinter is initialized safely before Pygame, allowing its dialogs to function correctly.
    * **Acceptance Criteria:**
        * Tkinter initialization (`tk.Tk()`) does not crash the application when called.
        * Tkinter-dependent features (Color Picker, Load Ref Img) open their respective dialogs without crashing the main application.
        * The Tkinter root window remains hidden.
        * Pygame functionality is unaffected.
        * **Testing:** Unit tests confirm `_ensure_tkinter_root` (or equivalent logic) executes without error after Pygame init. Manual testing confirms Color Picker and Load Ref Img buttons successfully open dialogs without crashes.
    * **Labels:** `ui`, `ux`, `editor`, `dependencies`, `bug`, `blocked`, `macos`

---

## Done

* **[OVERWORLD-2] Add Map Editor Functionality (Design Doc Complete)**
    * **Type:** Feature
    * **Priority:** High
    * **Description:** Authored the map editor design and requirements in a dedicated design doc for future implementation.
    * **Outcome:** Design doc created at `docs/map-editor-design.md` covering UX/tools, data model, file format, validation, and runtime integration; ticket requirements relocated to the doc.
    * **Labels:** `feature`, `overworld`, `map`, `editor`, `tools`

* **[FEAT-REFIMG-PANZOOM] Implement Reference Image Panning and Scaling**
    * **Type:** Feature
    * **Priority:** Medium
    * **Description:** Currently, the reference image loaded in the monster editor (`[FEAT-REFIMG]`) is displayed at a fixed position and scale (aspect-fit). This can make it difficult to precisely align with the pixel grid, especially if the desired tracing area is small or off-center in the original image. Implement controls to allow the user to pan (move horizontally/vertically) and scale (zoom in/out) the reference image layer independently of the main pixel grid zoom/pan. This could involve dedicated UI buttons/sliders or keyboard modifiers + mouse interactions.
    * **Acceptance Criteria:**
        * Controls (UI elements or keyboard/mouse shortcuts) are available to pan the reference image horizontally and vertically.
        * Controls are available to scale the reference image up and down.
        * Panning and scaling operations affect only the reference image layer, not the pixel grid or other UI elements.
        * The transparency setting (`[FEAT-REFIMG]`) still functions correctly with the panned/scaled image.
        * The "Clear Ref Img" function resets any panning and scaling applied.
        * The editor remains performant even with panning/scaling applied.
        * **Testing:** Manual testing confirms panning and scaling controls work intuitively and independently of the main canvas controls.
        * **Testing:** Manual testing confirms transparency and clearing functions work correctly with the transformed image.
        * **Testing:** Unit/integration tests are *written and pass* for the panning/scaling logic, verifying correct transformation calculations and state updates (potentially mocking user input/GUI elements).
    * **Labels:** `feature`, `editor`, `ui`, `ux`, `reference-image`, `input`, `enhancement`, `testing`

*   **[POKE-10.3] Refactor Core Drawing/Tool Logic**
    *   **Type:** Refactoring Task
    *   **Priority:** Medium-High
    *   **Description:** Extract the logic for different editing tools (Draw, Erase, Fill, Paste) currently residing within the `Editor` class (e.g., in `_handle_canvas_click`, `flood_fill`, `apply_paste`) into separate classes or functions, potentially managed by a `ToolManager` using `tool_manager.py`. The `EventHandler` and `Editor` should delegate actions to the appropriate tool handler based on the current mode/tool.
    *   **Acceptance Criteria:**
        *   Logic for Draw, Erase, Fill, and Paste tools is encapsulated outside the main `Editor` class (e.g., in `tool_manager.py` or individual tool modules).
        *   The `Editor` class delegates canvas interactions (clicks/drags) to the active tool handler.
        *   The `EventHandler` correctly facilitates this delegation.
        *   All tools function correctly in both monster and background edit modes.
        *   Relevant unit/integration tests are **written and pass** for each extracted tool's logic, verifying correct pixel manipulation on a mock canvas or `SpriteEditor` frame.
        *   Manual regression testing confirms all tools work as expected.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `tools`, `event-handling`, `testing`

*   **[POKE-10.1] Extract `SpriteEditor` Class**
    *   **Type:** Refactoring Task
    *   **Priority:** High
    *   **Description:** Move the `SpriteEditor` class definition from `pixle_art_editor.py` into its own dedicated module (e.g., `sprite_editor.py`). Update `pixle_art_editor.py` to import and use the class from the new module. Ensure all functionality related to sprite data handling (loading, saving, drawing pixels, getting grid positions) remains intact.
    *   **Acceptance Criteria:**
        *   The `SpriteEditor` class is defined in a separate file (e.g., `sprite_editor.py`).
        *   `pixle_art_editor.py` imports and instantiates `SpriteEditor` from the new module.
        *   All existing sprite editing functionality works as before.
        *   Relevant unit/integration tests are **written and pass** for the `SpriteEditor` class, verifying its core methods (e.g., `load_sprite`, `save_sprite`, `draw_pixel`, `get_grid_position`) in isolation or minimal integration.
        *   Manual regression testing confirms sprite editing remains fully functional.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `sprite-editor`, `testing`

*   **[POKE-10.2] Extract `Palette` Class**
    *   **Type:** Refactoring Task
    *   **Priority:** High
    *   **Description:** Move the `Palette` class definition from `pixle_art_editor.py` into the `editor_ui.py` module. Update `pixle_art_editor.py` to import and use the class from its new location. Ensure color selection and palette scrolling functionality remain intact.
    *   **Acceptance Criteria:**
        *   The `Palette` class is defined in `editor_ui.py`.
        *   `pixle_art_editor.py` imports and instantiates `Palette` from `editor_ui.py`.
        *   Color selection using the palette works correctly.
        *   Palette scrolling functions as expected.
        *   Relevant unit/integration tests are **written and pass** for the `Palette` class, verifying its drawing and click handling logic (potentially mocking `editor.select_color`).
        *   Manual regression testing confirms palette interaction remains fully functional.
    *   **Labels:** `refactoring`, `editor`, `code-quality`, `maintainability`, `architecture`, `ui`, `palette`, `testing`

* **[FEAT-REFIMG] Add Reference Image Layer to Pixel Editor**
    * **Type:** Feature
    * **Priority:** Medium (Adjust as needed)
    * **Description:** Implement functionality to load, display (with aspect-fit scaling), adjust transparency (alpha slider), and clear a background reference/tracing image within the pixel art editor's monster editing mode. The image should appear behind the interactive pixel grid.
    * **Acceptance Criteria:**
        * A "Load Ref Img" button/option allows selecting PNG/JPG/etc. files.
        * The loaded image displays behind the *active* sprite editor grid, scaled to fit while maintaining aspect ratio.
        * An alpha slider controls the reference image's transparency (0-100% or 0-255).
        * A "Clear Ref Img" button/option removes the reference image.
        * Loading, clearing, and alpha adjustment work correctly without breaking other editor functions.
        * Drawing/erasing on the main grid is unaffected by the reference image.
        * **Testing:** Manual testing confirms loading various image types, correct display/scaling, functional alpha slider, and clearing functionality.
        * **Testing:** Manual testing confirms drawing on the main canvas is not blocked.
        * **Testing:** Unit tests pass (mocking GUI interactions).
    * **Labels:** `feature`, `editor`, `ui`, `ux`, `reference-image`

* **[POKE-1] Define and Centralize Core Configuration Constants** (Type: Task, Priority: Highest)
* **[POKE-2] Refactor Sprite Creation to Use Native Resolution** (Type: Bug / Improvement, Priority: Highest)
* **[POKE-3] Refactor Editor Sprite Loading/Saving to Native Resolution** (Type: Bug / Improvement, Priority: Highest)
* **[POKE-4] Refactor Battle Sim Sprite Loading/Scaling** (Type: Bug / Improvement, Priority: Highest)
* **[POKE-5] Complete `type_chart.json` Data** (Type: Bug / Data, Priority: High)
* **[POKE-6] Implement Stat Reset Between Battles** (Type: Bug, Priority: High)
* **[POKE-7] Review and Simplify Stat Change Formula** (Type: Improvement / Bug, Priority: High)
* **[POKE-8] Fix Creature Selection Keyboard Navigation** (Type: Bug, Priority: High)
* **[POKE-21] Editor: Eraser/Fill modes deactivate immediately upon button click** (Type: Bug, Priority: High)
* **[UI-BATTLESIM-NAVHINT] Add Page Navigation Key Hints in Battle Sim Character Select**
    * **Type:** Improvement / UI
    * **Priority:** Medium
    * **Description:** In the battle simulator's character selection screen, when the user attempts to navigate left off the first item on a page or right off the last item on a page using arrow keys, display a temporary visual hint (e.g., "Press [ for Prev Page" or "Press ] for Next Page") to guide them on how to change pages.
    * **Acceptance Criteria:**
        * Pressing Left Arrow on the first selectable item displays the previous page hint (if applicable).
        * Pressing Right Arrow on the last selectable item displays the next page hint (if applicable).
        * The hint is displayed clearly on the screen (e.g., near page number or center).
        * The hint disappears after a short duration (e.g., 1-2 seconds) or on the next user input.
        * The core navigation logic remains unchanged.
        * **Testing:** Manual testing confirms hints appear correctly at page edges and disappear appropriately.
    * **Labels:** `ui`, `ux`, `battle-system`, `improvement`, `input`

* **[POKE-22] Reorganize Project Folder Structure**
    * **Type:** Task / Improvement
    * **Priority:** Medium
    * **Description:** The current project structure has most Python modules (`pixle_art_editor.py`, `tool_manager.py`, `battle_simulator.py`, etc.) directly in the root directory. This can become hard to manage as the project grows. Reorganize the codebase into a more standard structure, likely involving a main `src/` directory with subdirectories for different components (e.g., `src/editor`, `src/battle`, `src/core`, `src/ui`, `src/utils`). Update all necessary imports and ensure the application and tests still run correctly after the reorganization.
    * **Acceptance Criteria:**
        * Python source files are moved into a logical directory structure (e.g., under `src/`).
        * All internal imports within the codebase are updated to reflect the new structure.
        * The main application entry points (e.g., `pixle_art_editor.py`, `battle_simulator.py`, potentially moved/adjusted) still launch the application correctly.
        * All unit tests pass after the reorganization (adjusting imports in tests as needed).
        * Directory structure is cleaner and easier to navigate.
    * **Labels:** `refactoring`, `architecture`, `code-quality`, `maintainability`

---



================================================
File: battle_simulator.py
================================================
#!/usr/bin/env python3
import sys
import os

# Ensure the project root directory is in the Python path
project_root = os.path.dirname(os.path.abspath(__file__))
# src_path = os.path.join(project_root, 'src') # Old
if project_root not in sys.path:
    sys.path.insert(0, project_root) # Insert project root

# Import and run the main function using the full path from src
# from battle.battle_simulator import main # Old
from src.battle.battle_simulator import main # Import using src package

if __name__ == "__main__":
    main() 


================================================
File: main_menu.py
================================================
#!/usr/bin/env python3
import os
import sys

project_root = os.path.dirname(os.path.abspath(__file__))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from src.ui.main_menu import main


if __name__ == "__main__":
    main()



================================================
File: pixle_art_editor.py
================================================
#!/usr/bin/env python3
import sys
import os
import runpy

# Ensure the project root directory is in the Python path
project_root = os.path.dirname(os.path.abspath(__file__))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

if __name__ == "__main__":
    print("Running editor from root script...")
    # Use runpy to execute the main editor module correctly
    # This ensures its own __name__ == "__main__" block runs
    try:
        runpy.run_module("src.editor.pixle_art_editor", run_name="__main__", alter_sys=True)
    except ImportError as e:
        print(f"Error: Could not run the editor module. Make sure you are in the project root directory.")
        print(f"Details: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)


================================================
File: requirements-dev.txt
================================================
pytest 


================================================
File: requirements.txt
================================================
pygame>=2.0.0




================================================
File: data/monsters.json
================================================
[
    {
      "name": "Embercub",
      "type": "Fire",
      "max_hp": 100,
      "attack": 70,
      "defense": 60,
      "moves": ["Flame Burst", "Ember Strike", "Gale Force", "Power Up"]
    },
    {
      "name": "Aquafin",
      "type": "Water",
      "max_hp": 110,
      "attack": 65,
      "defense": 65,
      "moves": ["Tsunami Blast", "Water Rush", "Frost Spike", "Defend Up"]
    },
    {
      "name": "Terrapod",
      "type": "Earth",
      "max_hp": 130,
      "attack": 75,
      "defense": 80,
      "moves": ["Seismic Slam", "Stone Slide", "Steel Tail", "Break Guard"]
    },
    {
      "name": "Zephyrix",
      "type": "Wind",
      "max_hp": 90,
      "attack": 80,
      "defense": 55,
      "moves": ["Cyclone Slash", "Wind Ace", "Lightning Bolt", "Weaken"]
    },
    {
      "name": "Sparkitty",
      "type": "Electric",
      "max_hp": 95,
      "attack": 75,
      "defense": 60,
      "moves": ["Volt Charge", "Static Shock", "Chrome Claw", "Wind Cutter"]
    },
    {
      "name": "Frostbite",
      "type": "Ice",
      "max_hp": 105,
      "attack": 65,
      "defense": 70,
      "moves": ["Glacial Beam", "Frost Bite", "Water Rush", "Crystal Shard"]
    },
    {
      "name": "Leafeonix",
      "type": "Nature",
      "max_hp": 110,
      "attack": 70,
      "defense": 65,
      "moves": ["Solar Ray", "Nature Storm", "Venom Fang", "Quake Fist"]
    },
    {
      "name": "Psycat",
      "type": "Mind",
      "max_hp": 100,
      "attack": 75,
      "defense": 65,
      "moves": ["Psi Blast", "Mind Crush", "Spirit Claw", "Prism Strike"]
    },
    {
      "name": "Shadowpaw",
      "type": "Shadow",
      "max_hp": 95,
      "attack": 80,
      "defense": 55,
      "moves": ["Nightmare Strike", "Shadow Pulse", "Psychic Wave", "Venom Strike"]
    },
    {
      "name": "Lumina",
      "type": "Light",
      "max_hp": 100,
      "attack": 70,
      "defense": 70,
      "moves": ["Radiant Beam", "Aurora Blast", "Spark Blast", "Crystal Shard"]
    },
    {
      "name": "Steelex",
      "type": "Metal",
      "max_hp": 120,
      "attack": 65,
      "defense": 85,
      "moves": ["Chrome Crusher", "Metal Wing", "Stone Slide", "Lightning Bolt"]
    },
    {
      "name": "Toxifrog",
      "type": "Toxic",
      "max_hp": 95,
      "attack": 75,
      "defense": 60,
      "moves": ["Toxic Bomb", "Toxic Spray", "Water Rush", "Spirit Claw"]
    },
    {
      "name": "Decibelle",
      "type": "Sound",
      "max_hp": 90,
      "attack": 80,
      "defense": 50,
      "moves": ["Resonance Wave", "Echo Pulse", "Psychic Wave", "Wind Ace"]
    },
    {
      "name": "Crystaline",
      "type": "Crystal",
      "max_hp": 110,
      "attack": 65,
      "defense": 75,
      "moves": ["Diamond Storm", "Gem Blast", "Frost Spike", "Radiant Beam"]
    },
    {
      "name": "Novastar",
      "type": "Cosmic",
      "max_hp": 100,
      "attack": 75,
      "defense": 65,
      "moves": ["Meteor Strike", "Galactic Pulse", "Psi Blast", "Solar Flare"]
    },
    {
      "name": "Infernog",
      "type": "Fire",
      "max_hp": 115,
      "attack": 80,
      "defense": 65,
      "moves": ["Inferno Rush", "Magma Surge", "Terra Force", "Chrome Claw"]
    },
    {
      "name": "Tsunamidon",
      "type": "Water",
      "max_hp": 125,
      "attack": 70,
      "defense": 75,
      "moves": ["Tidal Crash", "Tsunami Blast", "Frost Spike", "Spirit Blast"]
    },
    {
      "name": "Boulderax",
      "type": "Earth",
      "max_hp": 140,
      "attack": 75,
      "defense": 85,
      "moves": ["Terra Force", "Quake Fist", "Steel Tail", "Venom Strike"]
    },
    {
      "name": "Tornadron",
      "type": "Wind",
      "max_hp": 95,
      "attack": 85,
      "defense": 55,
      "moves": ["Tornado Spin", "Gale Force", "Lightning Bolt", "Sound Wave"]
    },
    {
      "name": "Volteon",
      "type": "Electric",
      "max_hp": 100,
      "attack": 80,
      "defense": 60,
      "moves": ["Lightning Strike", "Spark Blast", "Metal Wing", "Wind Cutter"]
    },
    {
      "name": "Glacierox",
      "type": "Ice",
      "max_hp": 110,
      "attack": 70,
      "defense": 75,
      "moves": ["Cryo Blast", "Hail Storm", "Water Rush", "Crystal Shard"]
    },
    {
      "name": "Floravine",
      "type": "Nature",
      "max_hp": 105,
      "attack": 75,
      "defense": 70,
      "moves": ["Thorn Barrage", "Nature Dance", "Venom Fang", "Stone Slide"]
    },
    {
      "name": "Cerebron",
      "type": "Mind",
      "max_hp": 95,
      "attack": 85,
      "defense": 60,
      "moves": ["Telekinetic Throw", "Brain Shock", "Spirit Claw", "Gem Blast"]
    },
    {
      "name": "Umbragon",
      "type": "Shadow",
      "max_hp": 105,
      "attack": 85,
      "defense": 60,
      "moves": ["Void Blast", "Umbra Slash", "Psychic Wave", "Toxic Surge"]
    },
    {
      "name": "Solarix",
      "type": "Light",
      "max_hp": 100,
      "attack": 75,
      "defense": 75,
      "moves": ["Solar Flare", "Luminous Burst", "Spark Blast", "Psychic Wave"]
    },
    {
      "name": "Ironheart",
      "type": "Metal",
      "max_hp": 130,
      "attack": 70,
      "defense": 90,
      "moves": ["Steel Burst", "Chrome Claw", "Rock Pierce", "Volt Charge"]
    },
    {
      "name": "Venomusk",
      "type": "Toxic",
      "max_hp": 90,
      "attack": 80,
      "defense": 55,
      "moves": ["Toxic Surge", "Venom Fang", "Wind Cutter", "Spirit Claw"]
    },
    {
      "name": "Boombox",
      "type": "Sound",
      "max_hp": 95,
      "attack": 85,
      "defense": 55,
      "moves": ["Howl Cannon", "Screech Blast", "Spark Blast", "Psychic Wave"]
    },
    {
      "name": "Gemodite",
      "type": "Crystal",
      "max_hp": 115,
      "attack": 70,
      "defense": 80,
      "moves": ["Prism Beam", "Quartz Rush", "Frost Spike", "Radiant Beam"]
    },
    {
      "name": "Nebulox",
      "type": "Cosmic",
      "max_hp": 105,
      "attack": 80,
      "defense": 70,
      "moves": ["Nebula Burst", "Star Shower", "Psi Blast", "Intimidate"]
    }
]



================================================
File: data/moves.json
================================================
[
    {"name": "Flame Burst", "type": "Fire", "power": 95},
    {"name": "Inferno Rush", "type": "Fire", "power": 110},
    {"name": "Ember Strike", "type": "Fire", "power": 70},
    {"name": "Magma Surge", "type": "Fire", "power": 105},
    {"name": "Fire Strike", "type": "Fire", "power": 100},
    {"name": "Water Rush", "type": "Water", "power": 80},
    {"name": "Tsunami Blast", "type": "Water", "power": 120},
    {"name": "Tidal Crash", "type": "Water", "power": 105},
    {"name": "Water Stream", "type": "Water", "power": 85},
    {"name": "Whirlpool Spin", "type": "Water", "power": 90},
    {"name": "Rock Pierce", "type": "Earth", "power": 110},
    {"name": "Terra Force", "type": "Earth", "power": 100},
    {"name": "Stone Slide", "type": "Earth", "power": 95},
    {"name": "Seismic Slam", "type": "Earth", "power": 105},
    {"name": "Quake Fist", "type": "Earth", "power": 90},
    {"name": "Gale Force", "type": "Wind", "power": 95},
    {"name": "Cyclone Slash", "type": "Wind", "power": 105},
    {"name": "Wind Ace", "type": "Wind", "power": 85},
    {"name": "Tornado Spin", "type": "Wind", "power": 100},
    {"name": "Wind Cutter", "type": "Wind", "power": 90},
    {"name": "Lightning Bolt", "type": "Electric", "power": 105},
    {"name": "Volt Charge", "type": "Electric", "power": 115},
    {"name": "Spark Blast", "type": "Electric", "power": 90},
    {"name": "Lightning Strike", "type": "Electric", "power": 110},
    {"name": "Static Shock", "type": "Electric", "power": 80},
    {"name": "Frost Bite", "type": "Ice", "power": 95},
    {"name": "Glacial Beam", "type": "Ice", "power": 110},
    {"name": "Hail Storm", "type": "Ice", "power": 105},
    {"name": "Frost Spike", "type": "Ice", "power": 80},
    {"name": "Cryo Blast", "type": "Ice", "power": 100},
    {"name": "Vine Lash", "type": "Nature", "power": 85},
    {"name": "Nature Storm", "type": "Nature", "power": 100},
    {"name": "Solar Ray", "type": "Nature", "power": 120},
    {"name": "Thorn Barrage", "type": "Nature", "power": 90},
    {"name": "Nature Dance", "type": "Nature", "power": 105},
    {"name": "Psi Blast", "type": "Mind", "power": 105},
    {"name": "Telekinetic Throw", "type": "Mind", "power": 100},
    {"name": "Mind Crush", "type": "Mind", "power": 110},
    {"name": "Psychic Wave", "type": "Mind", "power": 95},
    {"name": "Brain Shock", "type": "Mind", "power": 90},
    {"name": "Spirit Claw", "type": "Shadow", "power": 100},
    {"name": "Shadow Pulse", "type": "Shadow", "power": 105},
    {"name": "Nightmare Strike", "type": "Shadow", "power": 110},
    {"name": "Void Blast", "type": "Shadow", "power": 95},
    {"name": "Umbra Slash", "type": "Shadow", "power": 90},
    {"name": "Radiant Beam", "type": "Light", "power": 105},
    {"name": "Solar Flare", "type": "Light", "power": 110},
    {"name": "Prism Strike", "type": "Light", "power": 100},
    {"name": "Luminous Burst", "type": "Light", "power": 95},
    {"name": "Aurora Blast", "type": "Light", "power": 115},
    {"name": "Steel Tail", "type": "Metal", "power": 100},
    {"name": "Metal Wing", "type": "Metal", "power": 95},
    {"name": "Chrome Claw", "type": "Metal", "power": 90},
    {"name": "Chrome Crusher", "type": "Metal", "power": 110},
    {"name": "Steel Burst", "type": "Metal", "power": 105},
    {"name": "Venom Strike", "type": "Toxic", "power": 95},
    {"name": "Toxic Spray", "type": "Toxic", "power": 85},
    {"name": "Venom Fang", "type": "Toxic", "power": 100},
    {"name": "Toxic Surge", "type": "Toxic", "power": 105},
    {"name": "Toxic Bomb", "type": "Toxic", "power": 110},
    {"name": "Sound Wave", "type": "Sound", "power": 100},
    {"name": "Screech Blast", "type": "Sound", "power": 105},
    {"name": "Echo Pulse", "type": "Sound", "power": 95},
    {"name": "Resonance Wave", "type": "Sound", "power": 110},
    {"name": "Howl Cannon", "type": "Sound", "power": 115},
    {"name": "Crystal Shard", "type": "Crystal", "power": 90},
    {"name": "Gem Blast", "type": "Crystal", "power": 105},
    {"name": "Diamond Storm", "type": "Crystal", "power": 115},
    {"name": "Prism Beam", "type": "Crystal", "power": 100},
    {"name": "Quartz Rush", "type": "Crystal", "power": 95},
    {"name": "Meteor Strike", "type": "Cosmic", "power": 115},
    {"name": "Galactic Pulse", "type": "Cosmic", "power": 110},
    {"name": "Nebula Burst", "type": "Cosmic", "power": 105},
    {"name": "Star Shower", "type": "Cosmic", "power": 100},
    {"name": "Cosmic Ray", "type": "Cosmic", "power": 95},
    {"name": "Spirit Blast", "type": "Cosmic","power": 115},
    {"name": "Power Up", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "attack", "change": 1}},
    {"name": "Defend Up", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "defense", "change": 1}},
    {"name": "Weaken", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "attack", "change": 1}},
    {"name": "Break Guard", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "defense", "change": 1}},
    {"name": "Battle Cry", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "attack", "change": 2}},
    {"name": "Steel Defense", "type": "Normal", "power": 0, "effect": {"target": "self", "stat": "defense", "change": 2}},
    {"name": "Intimidate", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "attack", "change": 2}},
    {"name": "Corrode", "type": "Normal", "power": 0, "effect": {"target": "opponent", "stat": "defense", "change": 2}}
]



================================================
File: data/type_chart.json
================================================
{
    "Fire": {
        "Fire": 0.5, "Water": 0.5, "Earth": 2.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 2.0, "Nature": 2.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Water": {
        "Fire": 2.0, "Water": 0.5, "Earth": 1.0, "Wind": 1.0, "Electric": 0.5, 
        "Ice": 0.5, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 1.0, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Earth": {
        "Fire": 0.5, "Water": 2.0, "Earth": 1.0, "Wind": 0.0, "Electric": 2.0, 
        "Ice": 1.0, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 2.0, "Toxic": 2.0, "Sound": 1.0, "Crystal": 0.5, "Cosmic": 1.0
    },
    "Wind": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 0.5, "Electric": 0.5, 
        "Ice": 1.0, "Nature": 2.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 0.5, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Electric": {
        "Fire": 1.0, "Water": 2.0, "Earth": 0.0, "Wind": 2.0, "Electric": 0.5, 
        "Ice": 1.0, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 1.0, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Ice": {
        "Fire": 0.5, "Water": 0.5, "Earth": 2.0, "Wind": 2.0, "Electric": 1.0, 
        "Ice": 0.5, "Nature": 2.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Nature": {
        "Fire": 0.5, "Water": 2.0, "Earth": 2.0, "Wind": 0.5, "Electric": 1.0, 
        "Ice": 0.5, "Nature": 0.5, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 0.5, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Mind": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 0.5, "Shadow": 0.0, "Light": 1.0, 
        "Metal": 1.0, "Toxic": 2.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Shadow": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 2.0, "Shadow": 2.0, "Light": 0.5, 
        "Metal": 1.0, "Toxic": 0.5, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 1.0
    },
    "Light": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 2.0, "Shadow": 2.0, "Light": 0.5, 
        "Metal": 0.5, "Toxic": 0.5, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 2.0
    },
    "Metal": {
        "Fire": 0.5, "Water": 0.5, "Earth": 1.0, "Wind": 0.5, "Electric": 0.5, 
        "Ice": 2.0, "Nature": 1.0, "Mind": 1.0, "Shadow": 1.0, "Light": 2.0, 
        "Metal": 0.5, "Toxic": 0.0, "Sound": 0.5, "Crystal": 2.0, "Cosmic": 1.0
    },
    "Toxic": {
        "Fire": 1.0, "Water": 1.0, "Earth": 0.5, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 2.0, "Mind": 1.0, "Shadow": 0.5, "Light": 2.0, 
        "Metal": 0.0, "Toxic": 0.5, "Sound": 1.0, "Crystal": 0.5, "Cosmic": 1.0
    },
    "Sound": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 0.5, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 1.0, "Shadow": 1.0, "Light": 1.0, 
        "Metal": 2.0, "Toxic": 1.0, "Sound": 0.5, "Crystal": 2.0, "Cosmic": 1.0
    },
    "Crystal": {
        "Fire": 1.0, "Water": 1.0, "Earth": 2.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 0.5, "Nature": 1.0, "Mind": 0.5, "Shadow": 0.5, "Light": 1.0, 
        "Metal": 0.5, "Toxic": 2.0, "Sound": 0.5, "Crystal": 0.5, "Cosmic": 1.0
    },
    "Cosmic": {
        "Fire": 1.0, "Water": 1.0, "Earth": 1.0, "Wind": 1.0, "Electric": 1.0, 
        "Ice": 1.0, "Nature": 1.0, "Mind": 2.0, "Shadow": 2.0, "Light": 0.0, 
        "Metal": 0.5, "Toxic": 1.0, "Sound": 1.0, "Crystal": 1.0, "Cosmic": 0.5
    }
}


================================================
File: data/maps/demo_tiles.json
================================================
{
  "id": "demo_tiles",
  "name": "Demo Tiles Map",
  "version": "1.0.0",
  "tileSize": 32,
  "dimensions": {
    "width": 20,
    "height": 15
  },
  "tilesetId": "basic_overworld",
  "layers": [
    {
      "name": "ground",
      "tiles": [
        [
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "path",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "water",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "path",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "path",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall"
        ],
        [
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall"
        ]
      ]
    },
    {
      "name": "overlay",
      "tiles": [
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ]
      ]
    }
  ],
  "connections": [
    {
      "id": "conn_1",
      "type": "edge",
      "from": "right",
      "to": {
        "mapId": "demo_tiles_new",
        "spawn": {
          "x": 0,
          "y": 20
        },
        "facing": "east"
      }
    },
    {
      "id": "auto_down_demo_tiles_new_8",
      "type": "edge",
      "from": "down",
      "to": {
        "mapId": "demo_tiles_new",
        "spawn": {
          "x": 30,
          "y": 0
        },
        "facing": "down"
      },
      "auto": "world"
    },
    {
      "id": "auto_down_demo_tiles_new_9",
      "type": "edge",
      "from": "down",
      "to": {
        "mapId": "demo_tiles_new",
        "spawn": {
          "x": 31,
          "y": 0
        },
        "facing": "down"
      },
      "auto": "world"
    },
    {
      "id": "auto_down_demo_tiles_new_10",
      "type": "edge",
      "from": "down",
      "to": {
        "mapId": "demo_tiles_new",
        "spawn": {
          "x": 32,
          "y": 0
        },
        "facing": "down"
      },
      "auto": "world"
    },
    {
      "id": "auto_down_demo_tiles_new_11",
      "type": "edge",
      "from": "down",
      "to": {
        "mapId": "demo_tiles_new",
        "spawn": {
          "x": 33,
          "y": 0
        },
        "facing": "down"
      },
      "auto": "world"
    }
  ],
  "entities": [
    {
      "id": "test",
      "type": "npc",
      "name": "test",
      "spriteId": "npc",
      "position": {
        "x": 14,
        "y": 3
      },
      "facing": "down",
      "collision": true,
      "dialog": [
        "Hello",
        " this is a test dialog",
        "And this is a second test dialog"
      ],
      "dialogId": null,
      "actions": [],
      "conditions": {},
      "properties": {},
      "hidden": false
    }
  ],
  "triggers": [],
  "overrides": {},
  "spawn": {
    "x": 2,
    "y": 2
  },
  "behaviors": {
    "wall": {
      "walkable": false,
      "interaction": "A sturdy wall blocks the way."
    },
    "water": {
      "walkable": false,
      "interaction": "The water looks too deep to cross."
    },
    "path": {
      "walkable": true
    },
    "grass": {
      "walkable": true
    }
  }
}


================================================
File: data/maps/demo_tiles_new.json
================================================
{
  "id": "demo_tiles_new",
  "name": "demo_tiles_new",
  "version": "1.0.0",
  "tileSize": 32,
  "dimensions": {
    "width": 40,
    "height": 25
  },
  "tilesetId": "basic_overworld",
  "layers": [
    {
      "name": "ground",
      "tiles": [
        [
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "wall",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ],
        [
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass",
          "grass"
        ]
      ]
    },
    {
      "name": "overlay",
      "tiles": [
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ]
      ]
    }
  ],
  "connections": [
    {
      "id": "west_to_demo_tiles",
      "type": "edge",
      "from": "west",
      "to": {
        "mapId": "demo_tiles",
        "spawn": {
          "x": 2,
          "y": 2
        },
        "facing": "east"
      }
    },
    {
      "id": "auto_up_demo_tiles_30",
      "type": "edge",
      "from": "up",
      "to": {
        "mapId": "demo_tiles",
        "spawn": {
          "x": 8,
          "y": 14
        },
        "facing": "up"
      },
      "auto": "world"
    },
    {
      "id": "auto_up_demo_tiles_31",
      "type": "edge",
      "from": "up",
      "to": {
        "mapId": "demo_tiles",
        "spawn": {
          "x": 9,
          "y": 14
        },
        "facing": "up"
      },
      "auto": "world"
    },
    {
      "id": "auto_up_demo_tiles_32",
      "type": "edge",
      "from": "up",
      "to": {
        "mapId": "demo_tiles",
        "spawn": {
          "x": 10,
          "y": 14
        },
        "facing": "up"
      },
      "auto": "world"
    },
    {
      "id": "auto_up_demo_tiles_33",
      "type": "edge",
      "from": "up",
      "to": {
        "mapId": "demo_tiles",
        "spawn": {
          "x": 11,
          "y": 14
        },
        "facing": "up"
      },
      "auto": "world"
    }
  ],
  "entities": [
    {
      "id": "npc_1",
      "type": "npc",
      "name": "npc_1",
      "spriteId": "npc_guide",
      "position": {
        "x": 3,
        "y": 5
      },
      "facing": "down",
      "collision": true,
      "dialog": null,
      "dialogId": null,
      "actions": [],
      "conditions": {},
      "properties": {},
      "hidden": false
    }
  ],
  "triggers": [],
  "overrides": {}
}


================================================
File: data/maps/map.json
================================================
{
  "id": "map",
  "name": "map",
  "version": "1.0.0",
  "tileSize": 32,
  "dimensions": {
    "width": 20,
    "height": 15
  },
  "tilesetId": "basic_overworld",
  "layers": [
    {
      "name": "overlay",
      "tiles": [
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ]
      ]
    }
  ],
  "connections": [],
  "entities": [],
  "triggers": [],
  "overrides": {},
  "maps": {
    "demo_tiles": {
      "x": 13,
      "y": 38
    },
    "demo_tiles_new": {
      "x": -9,
      "y": 53
    },
    "map_one": {
      "x": 57.75,
      "y": 50.0
    },
    "map_two": {
      "x": 57.75,
      "y": 39.75
    },
    "world_layout": {
      "x": 130.0,
      "y": 0.5
    },
    "map": {
      "x": 48,
      "y": 0
    }
  }
}


================================================
File: data/maps/map_one.json
================================================
{
  "id": "map_one",
  "name": "map_one",
  "version": "1.0.0",
  "tileSize": 32,
  "dimensions": {
    "width": 3,
    "height": 3
  },
  "tilesetId": "test",
  "layers": [
    {
      "name": "ground",
      "tiles": [
        [
          "floor",
          "floor",
          "floor"
        ],
        [
          "floor",
          "floor",
          "floor"
        ],
        [
          "floor",
          "floor",
          "floor"
        ]
      ]
    },
    {
      "name": "overlay",
      "tiles": [
        [
          null,
          null,
          null
        ],
        [
          null,
          null,
          null
        ],
        [
          null,
          null,
          null
        ]
      ]
    }
  ],
  "connections": [
    {
      "id": "north_exit",
      "type": "edge",
      "from": "up",
      "to": {
        "mapId": "map_two",
        "spawn": {
          "x": 1,
          "y": 2
        },
        "facing": "south"
      }
    }
  ],
  "entities": [],
  "triggers": [],
  "overrides": {},
  "musicId": "song1",
  "spawn": {
    "x": 1,
    "y": 1
  }
}


================================================
File: data/maps/map_two.json
================================================
{
  "id": "map_two",
  "name": "map_two",
  "version": "1.0.0",
  "tileSize": 32,
  "dimensions": {
    "width": 3,
    "height": 3
  },
  "tilesetId": "test",
  "layers": [
    {
      "name": "ground",
      "tiles": [
        [
          "floor",
          "floor",
          "floor"
        ],
        [
          "floor",
          "floor",
          "floor"
        ],
        [
          "floor",
          "floor",
          "floor"
        ]
      ]
    },
    {
      "name": "overlay",
      "tiles": [
        [
          null,
          null,
          null
        ],
        [
          null,
          null,
          null
        ],
        [
          null,
          null,
          null
        ]
      ]
    }
  ],
  "connections": [],
  "entities": [],
  "triggers": [],
  "overrides": {},
  "musicId": "song2",
  "spawn": {
    "x": 1,
    "y": 1
  }
}


================================================
File: data/maps/world_layout.json
================================================
{
  "maps": {
    "demo_tiles": {
      "x": 34,
      "y": 58
    },
    "demo_tiles_new": {
      "x": 12,
      "y": 73
    },
    "map_one": {
      "x": 57.75,
      "y": 50.0
    },
    "map_two": {
      "x": 57.75,
      "y": 39.75
    },
    "world_layout": {
      "x": 130.0,
      "y": 0.5
    },
    "map": {
      "x": 48,
      "y": 0
    }
  }
}


================================================
File: data/tilesets/basic_overworld.json
================================================
{
  "id": "basic_overworld",
  "name": "Basic Overworld Tiles",
  "version": "1.0.0",
  "tileSize": 32,
  "tiles": [
    {
      "id": "grass",
      "name": "Grass",
      "filename": "grass.png",
      "frames": [
        "grass.png"
      ],
      "frameDurationMs": 200,
      "properties": {
        "walkable": true,
        "color": [
          102,
          187,
          106,
          255
        ]
      }
    },
    {
      "id": "path",
      "name": "Path",
      "filename": "path.png",
      "frames": [
        "path.png"
      ],
      "frameDurationMs": 200,
      "properties": {
        "walkable": true,
        "color": [
          200,
          170,
          120,
          255
        ]
      }
    },
    {
      "id": "wall",
      "name": "Wall",
      "filename": "wall.png",
      "frames": [
        "wall.png"
      ],
      "frameDurationMs": 200,
      "properties": {
        "walkable": false,
        "interaction": "A sturdy wall blocks the way.",
        "color": [
          70,
          70,
          70,
          255
        ]
      }
    },
    {
      "id": "water",
      "name": "Water",
      "filename": "water.png",
      "frames": [
        "water.png",
        "water_wave.png"
      ],
      "frameDurationMs": 250,
      "properties": {
        "walkable": false,
        "interaction": "The water looks too deep to cross.",
        "color": [
          70,
          110,
          190,
          255
        ]
      }
    }
  ],
  "npcs": [
    {
      "id": "npc_guide",
      "name": "Guide",
      "frameDurationMs": 200,
      "states": {
        "standing": {
          "south": [
            "npc_guide_standing_south.png"
          ],
          "west": [
            "npc_guide_standing_west.png"
          ],
          "east": [
            "npc_guide_standing_east.png"
          ],
          "north": [
            "npc_guide_standing_north.png"
          ]
        },
        "walking": {
          "south": [
            "npc_guide_walking_south_01.png",
            "npc_guide_walking_south_02.png"
          ],
          "west": [
            "npc_guide_walking_west.png"
          ],
          "east": [
            "npc_guide_walking_east.png"
          ],
          "north": [
            "npc_guide_walking_north.png"
          ]
        }
      }
    },
    {
      "id": "test",
      "name": "test",
      "frameDurationMs": 200,
      "states": {
        "idle": {
          "down": [
            "test_idle_down.png"
          ]
        },
        "standing": {
          "south": [
            "test_standing_south.png"
          ],
          "west": [
            "test_standing_west.png"
          ],
          "east": [
            "test_standing_east.png"
          ],
          "north": [
            "test_standing_north.png"
          ]
        },
        "walking": {
          "south": [
            "test_walking_south.png"
          ],
          "west": [
            "test_walking_west.png"
          ],
          "east": [
            "test_walking_east.png"
          ],
          "north": [
            "test_walking_north.png"
          ]
        }
      }
    }
  ]
}


================================================
File: docs/map-editor-design.md
================================================
# Map Editor Design

## Purpose
- Provide a dedicated tool to author overworld maps (tiles, entities, triggers, connections) that can be loaded by the existing overworld runtime without hand-editing files.
- Establish stable formats and IDs so future features (tile manager, per-map music) plug in without data migrations.

## Goals
- Fast tile painting with common tools and a preview of the selected tile.
- Visible and editable connections between maps (edges and explicit portals) with spawn position and facing.
- Entity and trigger authoring with dialog/text support that the overworld can render.
- Per-cell property overrides (walkable, encounter flags, water/slow/warp, etc.).
- Save/load maps in a versioned, schema-validated format.
- undo/redo
- state based triggers conditional logic simple actions should allow for features on a similar level as pokemon crystal. check for flags to determine entity dialog, environmental puzzles to make parts of environment appear/disappear or lock and unlock.
- colision UI with capbility to add override 
- preview adjcent maps (helps with aligning paths for example)
- connection with tile editor (planned feature) launch pixle art editor with selected already active, ability to write placeholder single color tiles directly to tile path for later editing.
- NPCs can be battleable or non, with predefined teams, editable a team editor pop up which can be opened from map editor.
- Tiles can be rotated natively without requiring multiple images saved
- Tiles and entities support animations.
- Maps include NPC entities as special "tile" types
- Global Player spawn on new game - special tile

## Non-goals (for now)
- Scripting beyond dialog/text triggers (note in data model for future expansion).
- Multi-user collaboration or remote storage.

## UX / Workflow
- **Map canvas:** Grid-aligned view with zoom and pan. Cursor shows tile under edit. Optional grid toggle.
- **Tile palette:** Lists tiles from a selected tile set (from tile manager); shows tile ID/name. Supports eyedropper from canvas.
- **Layers:** At minimum `ground` and `overlay`. Layer picker shows which layer edits apply to. Optional hidden/lock toggles.
- **Tools:** Brush, fill, rectangle, line, erase (tile to empty), eyedropper. Keyboard shortcuts encouraged.
- **Connections overlay:** Edge markers for N/E/S/W connections plus portal icons rendered at specific cells. Selecting a marker opens connection properties.
- **Entity/trigger mode:** Placement cursor snaps to cells; selection opens property inspector.
- **Inspector panel:** Contextual detail editor for tiles (overrides), entities/NPCs, triggers, connections.
- **Validation:** Save button runs validation and reports blocking errors (missing references, invalid coordinates) plus warnings.

## Data Model (per map)
- **Metadata:** `id` (string, stable), `name`, `version`, `tileSize` (pixels), `dimensions` (`width`, `height`).
- **Tileset reference:** `tilesetId` and optional version/hash. Tiles referenced by stable `tileId`s provided by the tile manager (see OVERWORLD-4).
- **Layers:** Ordered list; each layer is a 2D array of `tileId` or `null`. Required: `ground`, `overlay`. Future layers allowed.
- **Connections:** Entries for edges and portals with: `type` (`edge`/`portal`), `from` (edge side or cell coords), `to` (`mapId`, `spawn` coords, optional `facing`), and optional `condition` stub for future scripting.
- **Entities/NPCs:** Objects with `id`, `type` (`npc`/`object`), `name`, `spriteId`, `position` (cell), `facing`, `collision` (bool), optional `dialogId` or inline `dialog` text, and custom properties.
- **Triggers:** Objects with `id`, `type` (`onEnter`/`onInteract`), `position` (cell or area), `actions` (e.g., `showText`, `startBattle`, `playSound` placeholder), `repeatable` flag.
- **Cell overrides:** Sparse map keyed by cell coords (`"x,y"`): `{ walkable: bool, flags: [string] }` where flags cover encounter zones, water, slow, warp, etc.
- **Music (OVERWORLD-5):** Optional `musicId` per map.

### Example (trimmed JSON)
```json
{
  "id": "town_square",
  "name": "Town Square",
  "version": "1.0.0",
  "tileSize": 16,
  "dimensions": { "width": 64, "height": 64 },
  "tilesetId": "town_tiles_v1",
  "layers": [
    { "name": "ground", "tiles": [[ "grass", "path" ], [ "grass", "path" ]] },
    { "name": "overlay", "tiles": [[ null, "lamp_post" ], [ null, null ]] }
  ],
  "connections": [
    { "id": "north_exit", "type": "edge", "from": "north", "to": { "mapId": "route_1", "spawn": { "x": 10, "y": 63 }, "facing": "south" } },
    { "id": "house_portal", "type": "portal", "from": { "x": 20, "y": 30 }, "to": { "mapId": "house_interior", "spawn": { "x": 5, "y": 8 }, "facing": "north" } }
  ],
  "entities": [
    { "id": "npc_1", "type": "npc", "name": "Guide", "spriteId": "guide_npc", "position": { "x": 12, "y": 14 }, "facing": "south", "collision": true, "dialog": [ "Welcome!", "Stay on the path." ] }
  ],
  "triggers": [
    { "id": "enter_tutorial", "type": "onEnter", "position": { "x": 12, "y": 14 }, "actions": [ { "kind": "showText", "text": "You stepped on a tutorial tile." } ], "repeatable": false }
  ],
  "overrides": {
    "15,22": { "walkable": false, "flags": [ "water" ] },
    "10,63": { "walkable": true, "flags": [ "spawn" ] }
  },
  "musicId": "town_theme"
}
```

## Validation Rules
- Dimensions must match layer array sizes; tile IDs must exist in the referenced tileset.
- Connections: `to.mapId` must exist; spawn coords within target map bounds; facing in `north/east/south/west`.
- Entities/triggers positions within bounds; referenced sprites/dialog IDs must resolve.
- Overrides only on valid cells; flags must be from a known set.
- Version field required; editor should refuse to save with blocking errors.

## Integration Points
- **File format:** JSON saved to `maps/{mapId}.json` (or configurable directory). Include `version` for migrations.
- **Runtime load:** Overworld loader reads the same schema; missing layers default to empty overlay.
- **Tile manager dependency:** Palette populated from tile manager output; tiles referenced by stable IDs.
- **Music linkage:** `musicId` consumed by overworld audio system (OVERWORLD-5).
- **Export/import:** Editor can open existing map files, edit, and re-save without losing unknown fields (preserve extras).



================================================
File: docs/overworld-system-design.md
================================================
# Overworld System Design

## Purpose
- Define how the overworld runtime loads, renders, and executes maps authored by the map editor (`docs/map-editor-design.md`) without hand-editing data.
- Provide stable behaviors for movement, collision, interactions, triggers, map transitions, and audio so tooling can target a consistent contract.

## Scope
- Runtime systems: map loading, rendering, player control/movement, collision, interactions, triggers/actions, connections/portals, per-map audio, and save/load of map state (not player progress).
- Data contract: consumes the map JSON schema defined in `docs/map-editor-design.md`; extends it only with runtime-only state (e.g., transient flags, active music handle).
- Integration: battle simulator for NPC/team encounters, dialog/text box UI, and tile manager outputs for rendering.

## Non-goals (for now)
- Long-running scripting engine; keep to a limited action set (show text, start battle, set flags, play sound/music).
- World persistence (player save files, quest state); only ephemeral session flags are covered here.
- Networking or multiplayer.

## Architecture Overview
- **Map Loader:** Reads `maps/{mapId}.json` (see map editor doc for schema), validates required fields, and normalizes defaults (missing overlay layer â†’ empty; missing overrides â†’ empty map).
- **Renderer:** Draws ordered tile layers (`ground`, `overlay`, optional future layers) and entities/NPCs. Supports camera follow for the player with configurable margins.
- **Player Controller:** Handles input (WASD/arrow), movement, facing, and interaction button. Supports grid-stepped or smooth movement; collisions gate movement decisions.
- **Collision & Navigation:** Combines base tile walkability with per-cell overrides and entity collisions. Encounter flags are exposed to the trigger/action system.
- **Interaction System:** On interaction input, checks the facing cell for entities/triggers and dispatches actions (dialog, battle, etc.).
- **Trigger/Action Pipeline:** Evaluates `onEnter` and `onInteract` triggers, conditionally executes an ordered list of actions. Actions include `showText`, `startBattle`, `playSound`, `setFlag`, `clearFlag`, `warp`, and `runConnection` (reuse connection logic). Extensible with a registry.
- **Connections Manager:** Executes edge and portal transitions with spawn placement and facing rules; handles fade/transition effects.
- **Audio Manager:** Plays per-map music (`musicId`) and stops/fades when changing maps; exposes `playSound` for trigger actions.
- **State & Flags:** Maintains transient session flags (bool key/value) to gate dialogs, events, and visibility (e.g., environmental puzzles). Flags are in-memory; persistence is out-of-scope.

## Data Contract (summary)
- Full schema lives in `docs/map-editor-design.md`. The runtime consumes the same fields: metadata, dimensions, `tileSize`, `tilesetId`, ordered `layers`, `connections`, `entities`, `triggers`, `overrides`, optional `musicId`.
- Tilesets: referenced by stable IDs provided by the tile manager (OVERWORLD-4).
- Unknown fields: loader preserves unknown fields when saving back (round-trip friendly).

## Runtime Behavior
- **Movement Model:** Grid-stepped (one tile per move) with optional tweened animation; movement blocked by collisions before committing step. Facing updates even when blocked.
- **Camera:** Center on player with clamp to map bounds; optional dead-zone/margin to reduce jitter.
- **Collision Rules:**
  - Base walkability from tile data (default walkable unless tile property says otherwise per tileset definition).
  - Overrides (`overrides["x,y"].walkable`) take precedence.
  - Entities with `collision: true` block movement.
  - Edge cells remain walkable; transitions are handled by connections manager.
- **Interactions:**
  - Interaction key targets the cell in front of the player; if an entity with dialog/actions exists, dispatches its actions (from `dialog`/`dialogId` or `actions`).
  - If multiple triggers overlap, deterministic priority: entity-specific actions first, then cell triggers (`onInteract`), then default tile action (none).
- **Triggers:**
  - `onEnter` fires after a successful move into the cell.
  - `onInteract` fires when the interaction key is pressed toward the cell.
  - Trigger conditions can read flags; repeatability per trigger (`repeatable`).
- **Actions (minimal set):**
  - `showText` (blocking text box UI; supports sequences)
  - `startBattle` (launch battle simulator with referenced team/NPC)
  - `setFlag` / `clearFlag` (affects future dialogs/visibility)
  - `playSound`
  - `playMusic` / `stopMusic` (usually managed by map transitions)
  - `warp` / `runConnection` (teleport or invoke connection definition)
  - `toggleEntity` / `toggleTileOverride` (optional for environmental puzzles)
- **Connections:**
  - **Edge:** When stepping off-map on an edge with a connection, load target map and place player at target spawn; set facing to targetâ€™s `facing` (if provided) or opposite the entry edge.
  - **Portal:** When entering a portal cell, load target map and spawn at provided coords; facing uses specified `facing` or preserves player facing.
  - Validations align with the map editor doc (spawn within bounds, known map IDs).
- **Audio:**
  - On map load, resolve `musicId` to an audio asset; fade out current track and fade in new track.
  - Fallback to default overworld track if `musicId` missing.

## Rendering Details
- Tile drawing order: ground â†’ entities (with simple depth-sort by `y`) â†’ overlay â†’ UI (text box, prompts).
- Support basic animations via tileset frame definitions if provided by tile manager (future-friendly).
- Optional debug overlays: collision mask, trigger markers, connection markers (toggled via debug key).

## File/Directory Conventions
- Maps: `maps/{mapId}.json` (as authored by the map editor).
- Tilesets: resolved via tile manager output directory/config (OVERWORLD-4).
- Music: resolved via audio asset path/id (OVERWORLD-5).

## Testing Strategy
- Unit: collision checks, trigger evaluation ordering, connection resolution (edge/portal), flag mutations, audio switching logic.
- Integration: load map â†’ move â†’ trigger dialog â†’ change map â†’ verify music swap; load/save round-trip preserves unknown fields.
- Manual: match the acceptance flow from OVERWORLD-3 (create map in editor â†’ play in overworld and verify connections/dialog/collision).

## Open Questions
- Should triggers support parameterized conditions beyond flags (e.g., inventory checks) - lets backlog it for now
- Do we need persistence for flags across map loads, and if so, where to store it - broader question about save and load system. For now lets keep an eye towards allowing it in the future but not implement it yet.




================================================
File: scripts/convert_sprites.py
================================================
#!/usr/bin/env python
import pygame
import os
import shutil

# --- Configuration ---
SPRITES_DIR = "sprites"
BACKUP_DIR = "sprites_backup"
NATIVE_SPRITE_RESOLUTION = (32, 32)
# --- End Configuration ---

def convert_sprites():
    """ 
    Converts sprites in SPRITES_DIR to NATIVE_SPRITE_RESOLUTION,
    backing up originals to BACKUP_DIR first.
    """
    pygame.init() # Need Pygame for loading and scaling
    print("Starting sprite conversion...")
    
    if not os.path.isdir(SPRITES_DIR):
        print(f"Error: Sprites directory '{SPRITES_DIR}' not found. Aborting.")
        return
        
    # Create backup directory if it doesn't exist
    if not os.path.exists(BACKUP_DIR):
        try:
            os.makedirs(BACKUP_DIR)
            print(f"Created backup directory: {BACKUP_DIR}")
        except OSError as e:
            print(f"Error creating backup directory '{BACKUP_DIR}': {e}. Aborting.")
            return
    else:
         print(f"Backup directory '{BACKUP_DIR}' already exists.")

    converted_count = 0
    skipped_count = 0
    backup_count = 0
    error_count = 0

    # Iterate through files in the sprites directory
    print(f"Scanning directory: {SPRITES_DIR}")
    for filename in os.listdir(SPRITES_DIR):
        if filename.lower().endswith('.png'):
            original_path = os.path.join(SPRITES_DIR, filename)
            backup_path = os.path.join(BACKUP_DIR, filename)
            
            # 1. Backup the original file
            try:
                if not os.path.exists(backup_path):
                     shutil.copy2(original_path, backup_path) # copy2 preserves metadata
                     print(f"  Backed up: {filename} -> {BACKUP_DIR}/")
                     backup_count += 1
                # else: Skip backup if already exists in backup folder
                     
            except Exception as e:
                print(f"  Error backing up {filename}: {e}")
                error_count += 1
                continue # Skip processing this file if backup failed

            # 2. Load, Check Size, Scale if needed, and Overwrite
            try:
                img = pygame.image.load(original_path).convert_alpha()
                
                if img.get_size() != NATIVE_SPRITE_RESOLUTION:
                    print(f"  Converting: {filename} from {img.get_size()} to {NATIVE_SPRITE_RESOLUTION}")
                    scaled_img = pygame.transform.scale(img, NATIVE_SPRITE_RESOLUTION)
                    
                    # Create a new surface and blit the scaled image onto it
                    final_surface = pygame.Surface(NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
                    final_surface.fill((0,0,0,0)) # Ensure transparent background
                    final_surface.blit(scaled_img, (0,0))
                    
                    # Overwrite the original file with the new surface
                    pygame.image.save(final_surface, original_path)
                    converted_count += 1
                else:
                    # If already correct size, no need to re-save
                    skipped_count += 1
                    
            except pygame.error as e:
                print(f"  Error processing {filename}: {e}")
                error_count += 1
            except Exception as e:
                 print(f"  Unexpected error processing {filename}: {e}")
                 error_count += 1
                 
    print("\nConversion Summary:")
    print(f"  Files backed up: {backup_count}")
    print(f"  Files converted (resized): {converted_count}")
    print(f"  Files skipped (already correct size): {skipped_count}")
    print(f"  Errors encountered: {error_count}")
    print("Sprite conversion process complete.")
    pygame.quit()

if __name__ == "__main__":
    convert_sprites() 


================================================
File: scripts/create_empty_sprites.py
================================================
import pygame
import json
import os
import sys # Added sys import

# Add project root to path to allow importing from src
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import the centralized config
# import config # Original
from src.core import config # Updated import

# Initialize Pygame (required for surface creation)
pygame.init()

# Constants from config
# NATIVE_SPRITE_RESOLUTION = (32, 32) # Reverted to 32x32
# BACKGROUND_WIDTH, BACKGROUND_HEIGHT = 1200, 600

# Load monster data using config path
monsters_file = os.path.join(config.DATA_DIR, "monsters.json")
try:
    with open(monsters_file, "r") as f:
        monsters = json.load(f)
except (FileNotFoundError, json.JSONDecodeError) as e:
     print(f"Error loading {monsters_file}: {e}. Cannot proceed.")
     pygame.quit()
     exit() # Use exit() instead of sys.exit() if sys not imported

# Get the names of all monsters in the JSON file
monster_names = {monster['name'] for monster in monsters}

# Directory existence checks are now handled in config.py upon import
# # Ensure the sprites directory exists
# if not os.path.exists(config.SPRITE_DIR):
#     os.makedirs(config.SPRITE_DIR)
# 
# # Ensure the backgrounds directory exists
# if not os.path.exists(config.BACKGROUND_DIR):
#     os.makedirs(config.BACKGROUND_DIR)

# Remove sprites that don't match any monsters in monsters.json
# Use config path
print(f"Checking sprites in: {config.SPRITE_DIR}")
try:
    for filename in os.listdir(config.SPRITE_DIR):
        if filename.endswith(".png"):
            parts = filename.split('_')
            if len(parts) >= 2:
                sprite_name = parts[0]
                if sprite_name not in monster_names:
                    try:
                        file_path = os.path.join(config.SPRITE_DIR, filename)
                        os.remove(file_path)
                        print(f"Removed orphaned sprite: {filename}")
                    except OSError as e:
                        print(f"Error removing sprite {filename}: {e}")
            else:
                print(f"Skipping unusually named file in sprites folder: {filename}")
except FileNotFoundError:
     print(f"Warning: Sprite directory {config.SPRITE_DIR} not found during cleanup check.")

# Create empty transparent sprites for all monsters if they don't exist
print("Ensuring sprites exist for all monsters...")
for monster in monsters:
    for sprite_type in ['front', 'back']:
        # Use config path
        filename = os.path.join(config.SPRITE_DIR, f"{monster['name']}_{sprite_type}.png")
        if not os.path.exists(filename):
            # Create surface at native resolution from config
            surface = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
            surface.fill((*config.BLACK[:3], 0)) # Ensure it's transparent using config color
            try:
                 pygame.image.save(surface, filename)
                 print(f"Created empty sprite: {filename} at {config.NATIVE_SPRITE_RESOLUTION}")
            except pygame.error as e:
                 print(f"Error saving empty sprite {filename}: {e}")
        # else: # Don't print anything if it exists, reduces noise
        #     print(f"Sprite already exists: {filename}")

# Create an empty background if none exists
# Use config path
print(f"Checking backgrounds in: {config.BACKGROUND_DIR}")
try:
    background_files = [f for f in os.listdir(config.BACKGROUND_DIR) if f.endswith('.png')]
    if not background_files:
        print("No backgrounds found, creating a default one.")
        # Use default dimensions from config
        empty_background = pygame.Surface((config.DEFAULT_BACKGROUND_WIDTH, config.DEFAULT_BACKGROUND_HEIGHT))
        empty_background.fill(config.WHITE)  # Use config color
        
        background_filename = os.path.join(config.BACKGROUND_DIR, "default_background.png")
        try:
            pygame.image.save(empty_background, background_filename)
            print(f"Created empty background: {background_filename}")
        except pygame.error as e:
             print(f"Error saving empty background {background_filename}: {e}")
    else:
        print("Background(s) already exist.")
except FileNotFoundError:
     print(f"Warning: Background directory {config.BACKGROUND_DIR} not found.")

print("Sprite check and creation process complete.")

# Quit Pygame
pygame.quit()



================================================
File: scripts/create_test_ref_image.py
================================================
import pygame
import os

# Initialize Pygame (required for surface creation)
pygame.init()

# Define image properties
width, height = 16, 16
filename = "test_ref_image.png"
assets_dir = os.path.join("tests", "assets")
filepath = os.path.join(assets_dir, filename)

# Create the surface
surface = pygame.Surface((width, height), pygame.SRCALPHA)

# Fill with distinct colors (e.g., quadrants)
red = (255, 0, 0, 255)
green = (0, 255, 0, 255)
blue = (0, 0, 255, 255)
yellow = (255, 255, 0, 255)
half_w, half_h = width // 2, height // 2

surface.fill(red, (0, 0, half_w, half_h))
surface.fill(green, (half_w, 0, width - half_w, half_h))
surface.fill(blue, (0, half_h, half_w, height - half_h))
surface.fill(yellow, (half_w, half_h, width - half_w, height - half_h))

# Save the image
try:
    pygame.image.save(surface, filepath)
    print(f"Successfully created test image: {filepath}")
except pygame.error as e:
    print(f"Error saving test image {filepath}: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
finally:
    # Quit Pygame
    pygame.quit() 



================================================
File: sounds/.DS_Store
================================================
[Non-text file]




================================================
File: sprites/.DS_Store
================================================
[Non-text file]



================================================
File: src/__init__.py
================================================
 




================================================
File: src/battle/__init__.py
================================================
 


================================================
File: src/battle/battle_simulator.py
================================================
import pygame
import sys
import random
import os
import json
import copy

# Import the centralized config
# from ..core import config # Relative import
from src.core import config # Absolute import from src

# Initialize Pygame
pygame.init()
pygame.mixer.init()

# Screen dimensions from config
# WIDTH, HEIGHT = 1200, 600
SCREEN = pygame.display.set_mode((config.BATTLE_WIDTH, config.BATTLE_HEIGHT))
pygame.display.set_caption("Battle Simulator")

# Font from config
FONT = pygame.font.Font(config.DEFAULT_FONT, config.BATTLE_FONT_SIZE)

# Constants from config
# STAT_CHANGE_MULTIPLIER = 0.66 # Defined constant for stat changes
# NATIVE_SPRITE_RESOLUTION = (32, 32)

class Move:
    def __init__(self, name, type_, power, effect=None):
        self.name = name
        self.type = type_
        self.power = power
        self.effect = effect

class Creature:
    def __init__(self, name, type_, max_hp, attack, defense, moves, sprite):
        self.name = name
        self.type = type_
        self.max_hp = max_hp
        self.current_hp = max_hp
        self.attack = attack
        self.defense = defense
        self.moves = moves
        # Sprite is expected to be native resolution here
        # Scaling happens in draw_battle
        self.sprite = sprite

    def is_alive(self):
        return self.current_hp > 0

# Load type effectiveness chart
# Use path from config
with open(os.path.join(config.DATA_DIR, 'type_chart.json'), 'r') as f:
    type_chart = json.load(f)

def apply_stat_change(creature, stat, change):
    """Applies a stat change multiplier to a creature's specified stat."""
    if hasattr(creature, stat):
        current_stat_value = getattr(creature, stat)
        if change > 0:
            # Formula for increasing stat stage
            multiplier = 1 + config.STAT_CHANGE_MULTIPLIER / (2 ** (change - 1))
            new_stat_value = int(current_stat_value * multiplier)
        elif change < 0: # Check for negative change explicitly
            # Formula for decreasing stat stage
            # Use abs(change) for the exponent
            divider = 1 + config.STAT_CHANGE_MULTIPLIER / (2 ** (abs(change) - 1))
            # Avoid division by zero if divider somehow becomes 0 (unlikely with current formula)
            if divider == 0:
                print(f"Warning: Stat change divider became zero for stat {stat}, change {change}. Stat unchanged.")
                new_stat_value = current_stat_value
            else:
                 new_stat_value = int(current_stat_value / divider)
        else: # change == 0
            # No change if change is zero
            new_stat_value = current_stat_value

        setattr(creature, stat, new_stat_value)
        # print(f"Debug: Applied change {change} to {stat}. Old: {current_stat_value}, New: {new_stat_value}") # Optional debug print
    else:
        print(f"Warning: Stat '{stat}' not found on creature {creature.name}.")

def calculate_damage(attacker, defender, move):
    if move.power == 0:  # Stat-changing move
        if move.effect['target'] == 'self':
            apply_stat_change(attacker, move.effect['stat'], move.effect['change'])
        else:  # 'opponent'
            apply_stat_change(defender, move.effect['stat'], -move.effect['change'])
        return 0, 1  # No damage, normal effectiveness

    effectiveness = type_chart.get(move.type, {}).get(defender.type, 1)
    base_damage = (10 * attacker.attack * move.power) / (30 * defender.defense)
    damage = int((base_damage + 2) * effectiveness * random.uniform(0.85, 1.0))
    
    
    return damage, effectiveness

def create_default_sprite():
    """Creates a default sprite at native resolution."""
    sprite = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
    # Simple placeholder: gray square with border
    sprite.fill(config.GRAY_LIGHT)
    pygame.draw.rect(sprite, config.GRAY_DARK, sprite.get_rect(), 2)
    # Draw a simple question mark or symbol if desired
    # font = pygame.font.Font(config.DEFAULT_FONT, config.NATIVE_SPRITE_RESOLUTION[1] // 2)
    # text = font.render("?", True, config.BLACK)
    # text_rect = text.get_rect(center=sprite.get_rect().center)
    # sprite.blit(text, text_rect)
    return sprite

def create_sprite_from_file(filename):
    """Loads sprite at native resolution, scales down if necessary."""
    try:
        sprite = pygame.image.load(filename).convert_alpha()
        # Check if loaded image matches native resolution
        if sprite.get_size() != config.NATIVE_SPRITE_RESOLUTION:
            print(f"Warning: Loaded sprite {filename} size {sprite.get_size()} does not match native {config.NATIVE_SPRITE_RESOLUTION}. Scaling down.")
            sprite = pygame.transform.smoothscale(sprite, config.NATIVE_SPRITE_RESOLUTION)
        return sprite
    except pygame.error:
        print(f"Sprite file not found: {filename}")
        # Return a default native size sprite if file not found
        return create_default_sprite() 
    
def load_creatures():
    creatures = []
    # Use paths from config
    monsters_file = os.path.join(config.DATA_DIR, 'monsters.json')
    moves_file = os.path.join(config.DATA_DIR, 'moves.json')
    
    try:
        with open(monsters_file, 'r') as f:
            monsters_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"Error loading {monsters_file}: {e}")
        return [] # Return empty list if core data fails

    try:
        with open(moves_file, 'r') as f:
            moves_data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
         print(f"Error loading {moves_file}: {e}")
         return []
    
    moves_dict = {move['name']: Move(move['name'], move['type'], move['power'], move.get('effect')) for move in moves_data}
    
    for monster in monsters_data:
        # Use path from config
        sprite_path = os.path.join(config.SPRITE_DIR, f"{monster['name']}_front.png")
        sprite = create_sprite_from_file(sprite_path)
        moves = [moves_dict.get(move_name, Move(move_name, 'Normal', 50)) for move_name in monster['moves']]
        creature = Creature(monster['name'], monster['type'], monster['max_hp'], 
                            monster['attack'], monster['defense'], moves, sprite)
        creatures.append(creature)
    
    return creatures

class Button:
    def __init__(self, rect, text, action=None):
        self.rect = pygame.Rect(rect)
        self.text = text
        self.action = action
        self.color = config.BUTTON_COLOR
        self.hover_color = config.BUTTON_HOVER_COLOR
        self.font = pygame.font.Font(config.DEFAULT_FONT, config.BUTTON_FONT_SIZE)

    def draw(self, surface):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, config.BLACK, self.rect, 2)
        text_surf = self.font.render(self.text, True, config.BLACK)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

    def is_clicked(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                return True
        return False

def draw_battle(creature1, creature2, buttons, background):
    SCREEN.blit(background, (0, 0))

    # Sprites are stored at native resolution in creature.sprite
    # Scale them ONCE here for display
    display_size = config.BATTLE_SPRITE_DISPLAY_SIZE
    
    # Use nearest-neighbor scaling (scale) for pixel art feel
    creature1_display_sprite = pygame.transform.scale(creature1.sprite, display_size)
    creature2_display_sprite = pygame.transform.scale(creature2.sprite, display_size)

    # Draw creatures higher up, adjusting position based on new display size
    SCREEN.blit(creature1_display_sprite, (100, config.BATTLE_HEIGHT - display_size[1] - 200))
    SCREEN.blit(creature2_display_sprite, (config.BATTLE_WIDTH - display_size[0] - 100, config.BATTLE_HEIGHT - display_size[1] - 200))

    # Draw HP bars
    hp_bar_width = 200
    hp_bar_height = 20
    pygame.draw.rect(SCREEN, config.BLACK, (100, 100, hp_bar_width, hp_bar_height))
    pygame.draw.rect(SCREEN, config.HP_BAR_COLOR, (100, 100, hp_bar_width * (creature1.current_hp / creature1.max_hp), hp_bar_height))
    pygame.draw.rect(SCREEN, config.BLACK, (config.BATTLE_WIDTH - 100 - hp_bar_width, 100, hp_bar_width, hp_bar_height))
    pygame.draw.rect(SCREEN, config.HP_BAR_COLOR, (config.BATTLE_WIDTH - 100 - hp_bar_width, 100, hp_bar_width * (creature2.current_hp / creature2.max_hp), hp_bar_height))

    # Draw names and HP
    name1 = FONT.render(f"{creature1.name} HP: {creature1.current_hp}/{creature1.max_hp}", True, config.BLACK)
    name2 = FONT.render(f"{creature2.name} HP: {creature2.current_hp}/{creature2.max_hp}", True, config.BLACK)
    SCREEN.blit(name1, (100, 80))
    SCREEN.blit(name2, (config.BATTLE_WIDTH - 100 - hp_bar_width, 80))

    # Draw attack and defense stats
    attack1 = FONT.render(f"ATK: {creature1.attack}", True, config.BLACK)
    defense1 = FONT.render(f"DEF: {creature1.defense}", True, config.BLACK)
    attack2 = FONT.render(f"ATK: {creature2.attack}", True, config.BLACK)
    defense2 = FONT.render(f"DEF: {creature2.defense}", True, config.BLACK)
    
    SCREEN.blit(attack1, (100, 130))
    SCREEN.blit(defense1, (100, 160))
    SCREEN.blit(attack2, (config.BATTLE_WIDTH - 100 - hp_bar_width, 130))
    SCREEN.blit(defense2, (config.BATTLE_WIDTH - 100 - hp_bar_width, 160))

    # Draw move buttons (smaller and at the bottom)
    button_width = 150
    button_height = 40
    button_spacing = 10
    total_width = len(buttons) * (button_width + button_spacing) - button_spacing
    start_x = (config.BATTLE_WIDTH - total_width) // 2
    start_y = config.BATTLE_HEIGHT - button_height - 20

    for i, button in enumerate(buttons):
        button.rect.x = start_x + i * (button_width + button_spacing)
        button.rect.y = start_y
        button.rect.width = button_width
        button.rect.height = button_height
        button.draw(SCREEN)

    pygame.display.flip()

def opponent_choose_move(creature):
    return random.choice(creature.moves)

def play_random_song():
    # Use path from config
    songs_dir = config.SONGS_DIR
    try:
        songs = [f for f in os.listdir(songs_dir) if f.endswith('.mp3') or f.endswith('.wav')]
        if songs:
            random_song = random.choice(songs)
            pygame.mixer.music.load(os.path.join(songs_dir, random_song))
            pygame.mixer.music.play(-1)  # -1 means loop indefinitely
        else:
             print(f"No songs found in {songs_dir}")
    except FileNotFoundError:
         print(f"Songs directory not found: {songs_dir}")
    except pygame.error as e:
         print(f"Error loading or playing song: {e}")

def stop_music():
    pygame.mixer.music.stop()

def load_random_background():
    # Use path from config
    backgrounds_dir = config.BACKGROUND_DIR
    try:
        backgrounds = [f for f in os.listdir(backgrounds_dir) if f.endswith('.png')]
        if backgrounds:
            background_path = os.path.join(backgrounds_dir, random.choice(backgrounds))
            background = pygame.image.load(background_path).convert_alpha()
            # Scale background to fit battle screen size
            return pygame.transform.scale(background, (config.BATTLE_WIDTH, config.BATTLE_HEIGHT))
        else:
             print(f"No backgrounds found in {backgrounds_dir}. Using default.")
    except FileNotFoundError:
         print(f"Backgrounds directory not found: {backgrounds_dir}. Using default.")
    except pygame.error as e:
         print(f"Error loading background: {e}. Using default.")
         
    # Default fallback background
    default_bg = pygame.Surface((config.BATTLE_WIDTH, config.BATTLE_HEIGHT), pygame.SRCALPHA)
    default_bg.fill((*config.BATTLE_BG_COLOR, 255))  # Ensure full opacity
    return default_bg

def battle(creature1, creature2):
    clock = pygame.time.Clock()
    running = True
    turn = 0  # 0 for player's turn, 1 for opponent's turn

    play_random_song()

    # Create buttons for player's moves
    buttons = []
    button_width = 150
    button_height = 40
    button_spacing = 10
    total_width = len(creature1.moves) * (button_width + button_spacing) - button_spacing
    start_x = (config.BATTLE_WIDTH - total_width) // 2
    start_y = config.BATTLE_HEIGHT - button_height - 20
    for i, move in enumerate(creature1.moves):
        rect = (start_x + i * (button_width + button_spacing), start_y, button_width, button_height)
        button = Button(rect, move.name, action=move)
        buttons.append(button)

    background = load_random_background()

    while running:
        # Clear the screen using config color
        SCREEN.fill(config.BATTLE_BG_COLOR)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                stop_music()
                pygame.quit()
                sys.exit()

            if turn == 0 and creature1.is_alive() and creature2.is_alive():
                for button in buttons:
                    if button.is_clicked(event):
                        move = button.action
                        damage, effectiveness = calculate_damage(creature1, creature2, move)
                        creature2.current_hp -= damage
                        if creature2.current_hp < 0:
                            creature2.current_hp = 0
                        if move.power == 0:
                            print(f"{creature1.name} used {move.name}!")
                            if move.effect['target'] == 'self':
                                print(f"{creature1.name}'s {move.effect['stat']} {'increased' if move.effect['change'] > 0 else 'decreased'}!")
                            else:
                                print(f"{creature2.name}'s {move.effect['stat']} {'decreased' if move.effect['change'] > 0 else 'increased'}!")
                        else:
                            print(f"{creature1.name} used {move.name}! It dealt {damage} damage.")
                        turn = 1  # Switch turn

        if turn == 1 and creature2.is_alive() and creature1.is_alive():
            pygame.time.delay(1000)  # Pause before opponent's move
            move = opponent_choose_move(creature2)
            damage, effectiveness = calculate_damage(creature2, creature1, move)
            creature1.current_hp -= damage
            if creature1.current_hp < 0:
                creature1.current_hp = 0
            if move.power == 0:
                print(f"{creature2.name} used {move.name}!")
                if move.effect['target'] == 'self':
                    print(f"{creature2.name}'s {move.effect['stat']} {'increased' if move.effect['change'] > 0 else 'decreased'}!")
                else:
                    print(f"{creature1.name}'s {move.effect['stat']} {'decreased' if move.effect['change'] > 0 else 'increased'}!")
            else:
                print(f"{creature2.name} used {move.name}! It dealt {damage} damage.")
            turn = 0  # Switch turn

        draw_battle(creature1, creature2, buttons, background)

        # Check for win condition
        if not creature1.is_alive() or not creature2.is_alive():
            winner = creature1.name if creature1.is_alive() else creature2.name
            message = FONT.render(f"{winner} wins!", True, config.BLACK)
            SCREEN.blit(message, (config.BATTLE_WIDTH // 2 - message.get_width() // 2, config.BATTLE_HEIGHT // 2 - message.get_height() // 2))
            pygame.display.flip()
            pygame.time.delay(3000)
            stop_music()
            return show_end_options()

        clock.tick(config.FPS) # Use FPS from config

def show_end_options():
    # Center buttons on battle screen dimensions
    new_battle_button = Button((config.BATTLE_WIDTH // 2 - 150, config.BATTLE_HEIGHT // 2 - 60, 300, 50), "New Battle")
    quit_button = Button((config.BATTLE_WIDTH // 2 - 150, config.BATTLE_HEIGHT // 2 + 10, 300, 50), "Quit")

    while True:
        SCREEN.fill(config.BATTLE_BG_COLOR)
        new_battle_button.draw(SCREEN)
        quit_button.draw(SCREEN)
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if new_battle_button.is_clicked(event):
                    return True
                if quit_button.is_clicked(event):
                    return False

def main():
    creatures = load_creatures()
    if len(creatures) < 2:
        print("Not enough creatures to battle. Please add more creature data.")
        return

    # Font for hints (can reuse FONT or create a specific one)
    hint_font = pygame.font.Font(config.DEFAULT_FONT, config.BATTLE_FONT_SIZE - 2) # Slightly smaller

    while True:
        # Constants for grid layout
        GRID_COLS = 3
        GRID_ROWS = 2
        CREATURES_PER_PAGE = GRID_COLS * GRID_ROWS
        BUTTON_WIDTH = 350
        BUTTON_HEIGHT = 80
        BUTTON_SPACING = 20
        
        # Calculate grid positions based on battle screen size
        start_x = (config.BATTLE_WIDTH - (BUTTON_WIDTH * GRID_COLS + BUTTON_SPACING * (GRID_COLS - 1))) // 2
        start_y = (config.BATTLE_HEIGHT - (BUTTON_HEIGHT * GRID_ROWS + BUTTON_SPACING * (GRID_ROWS - 1))) // 2

        # Pagination variables
        current_page = 0
        total_pages = (len(creatures) + CREATURES_PER_PAGE - 1) // CREATURES_PER_PAGE

        player_creature = None
        selected_index = 0
        selected_player_creature = None

        # Hint variables
        nav_hint_text = ""
        hint_display_start_time = 0
        HINT_DURATION_MS = 1500 # Display hint for 1.5 seconds

        while selected_player_creature is None:
            current_time = pygame.time.get_ticks() # Get current time for hint timer
            SCREEN.fill(config.BATTLE_BG_COLOR)
            title = FONT.render("Choose your monster:", True, config.BLACK)
            SCREEN.blit(title, (config.BATTLE_WIDTH // 2 - title.get_width() // 2, 20))

            # Display page number
            page_info = FONT.render(f"Page {current_page + 1}/{total_pages}", True, config.BLACK)
            SCREEN.blit(page_info, (config.BATTLE_WIDTH // 2 - page_info.get_width() // 2, config.BATTLE_HEIGHT - 30))

            # Create and draw buttons for the current page
            buttons = []
            start_creature_index = current_page * CREATURES_PER_PAGE
            end_creature_index = min(start_creature_index + CREATURES_PER_PAGE, len(creatures))
            num_buttons_on_page = end_creature_index - start_creature_index

            for i in range(num_buttons_on_page):
                creature_index = start_creature_index + i
                creature = creatures[creature_index]
                row = i // GRID_COLS
                col = i % GRID_COLS
                x = start_x + col * (BUTTON_WIDTH + BUTTON_SPACING)
                y = start_y + row * (BUTTON_HEIGHT + BUTTON_SPACING)

                button = Button((x, y, BUTTON_WIDTH, BUTTON_HEIGHT), creature.name, action=creature)
                buttons.append(button)
                button.draw(SCREEN)

                # Highlight the selected button
                if i == selected_index:
                    pygame.draw.rect(SCREEN, config.GREEN, button.rect, 3)  # Green border

                # Display the creature's sprite next to the button
                creature_sprite = pygame.transform.scale(creature.sprite, (64, 64))
                SCREEN.blit(creature_sprite, (x + 5 , y + (BUTTON_HEIGHT - 64) // 2))

            # --- Display Navigation Hint ---
            if nav_hint_text and (current_time - hint_display_start_time < HINT_DURATION_MS):
                hint_surf = hint_font.render(nav_hint_text, True, config.RED) # Use a noticeable color
                # Position hint near the bottom page number
                hint_rect = hint_surf.get_rect(center=(config.BATTLE_WIDTH // 2, config.BATTLE_HEIGHT - 60))
                SCREEN.blit(hint_surf, hint_rect)
            else:
                nav_hint_text = "" # Clear hint if time expired
            # -------------------------------

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                # Check KEYDOWN first
                elif event.type == pygame.KEYDOWN:
                    # Clear previous hint on NEW key press
                    nav_hint_text = ""
                    # num_buttons_on_page calculated above
                    if num_buttons_on_page == 0: continue

                    # --- Intra-page Navigation --- 
                    if event.key == pygame.K_DOWN:
                        # Move down, wrapping around columns
                        if selected_index + GRID_COLS < num_buttons_on_page:
                            selected_index += GRID_COLS
                        else:
                            # Wrap to top row if possible, otherwise stay in last row
                            new_index = selected_index % GRID_COLS
                            if new_index < num_buttons_on_page:
                                selected_index = new_index
                            # else: stay at current index if wrapping leads nowhere valid
                    elif event.key == pygame.K_UP:
                        # Move up, wrapping around columns
                        if selected_index - GRID_COLS >= 0:
                            selected_index -= GRID_COLS
                        else:
                            # Wrap to bottom-most item in the same column
                            col = selected_index % GRID_COLS
                            last_row_items = num_buttons_on_page % GRID_COLS
                            last_full_row_index = num_buttons_on_page - last_row_items if last_row_items != 0 else num_buttons_on_page - GRID_COLS
                            target_index = last_full_row_index + col
                            if target_index >= num_buttons_on_page:
                                # If the target in the last row doesn't exist, go to the row above it
                                target_index -= GRID_COLS 
                            if target_index >= 0:
                                selected_index = target_index
                            # else: stay at current index if wrapping leads nowhere valid
                    elif event.key == pygame.K_RIGHT:
                        # Check if already at the last item on the page
                        if selected_index == num_buttons_on_page - 1:
                            if current_page < total_pages - 1:
                                nav_hint_text = "Press ] for Next Page"
                                hint_display_start_time = current_time
                            # Don't wrap around selection index if at edge and hint shown
                        elif selected_index + 1 < num_buttons_on_page:
                            selected_index += 1
                        # else: # Original wrap logic removed, hint handles the edge case
                        #     selected_index = 0 
                    elif event.key == pygame.K_LEFT:
                        # Check if already at the first item on the page
                        if selected_index == 0:
                            if current_page > 0:
                                nav_hint_text = "Press [ for Prev Page"
                                hint_display_start_time = current_time
                            # Don't wrap around selection index if at edge and hint shown
                        elif selected_index - 1 >= 0:
                            selected_index -= 1
                        # else: # Original wrap logic removed, hint handles the edge case
                        #      selected_index = num_buttons_on_page - 1
                    
                    # --- Page Navigation (Existing) --- 
                    elif event.key == pygame.K_RIGHTBRACKET: # Use ] for next page
                        if current_page < total_pages - 1:
                            current_page += 1
                            selected_index = 0 # Reset index on page change
                    elif event.key == pygame.K_LEFTBRACKET: # Use [ for previous page
                        if current_page > 0:
                            current_page -= 1
                            selected_index = 0 # Reset index on page change

                    # --- Selection (Existing) --- 
                    elif event.key == pygame.K_RETURN or event.key == pygame.K_SPACE:
                        if 0 <= selected_index < num_buttons_on_page:
                            # Check if buttons list is valid for the index
                            if selected_index < len(buttons):
                                selected_player_creature = buttons[selected_index].action
                            else:
                                print(f"Error: selected_index {selected_index} out of range for buttons list (len {len(buttons)}).")

                # Check MOUSEBUTTONDOWN next
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    # Clear previous hint on mouse click
                    nav_hint_text = ""
                    if event.button == 1:  # Left mouse button
                        for i, button in enumerate(buttons):
                            if button.rect.collidepoint(event.pos):
                                selected_player_creature = button.action
                                break
                
                # Can add other elif event checks here if needed

            pygame.display.flip()

        # Create NEW instances for the battle to avoid deepcopy issues with Surface
        # and ensure stats/HP are reset.
        player_sprite_path = os.path.join(config.SPRITE_DIR, f"{selected_player_creature.name}_front.png")
        player_sprite = create_sprite_from_file(player_sprite_path)
        player_for_battle = Creature(
            name=selected_player_creature.name,
            type_=selected_player_creature.type,
            max_hp=selected_player_creature.max_hp,
            attack=selected_player_creature.attack,
            defense=selected_player_creature.defense,
            moves=selected_player_creature.moves, # Moves are simple objects, ok to reuse reference
            sprite=player_sprite
        )

        # Choose a random opponent that isn't the player's creature
        selected_opponent_creature = random.choice([c for c in creatures if c.name != selected_player_creature.name])
        opponent_sprite_path = os.path.join(config.SPRITE_DIR, f"{selected_opponent_creature.name}_front.png")
        opponent_sprite = create_sprite_from_file(opponent_sprite_path)
        opponent_for_battle = Creature(
            name=selected_opponent_creature.name,
            type_=selected_opponent_creature.type,
            max_hp=selected_opponent_creature.max_hp,
            attack=selected_opponent_creature.attack,
            defense=selected_opponent_creature.defense,
            moves=selected_opponent_creature.moves,
            sprite=opponent_sprite
        )
        
        # Pass the new instances to the battle function
        continue_game = battle(player_for_battle, opponent_for_battle)
        
        if not continue_game:
            break

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()



================================================
File: src/core/__init__.py
================================================
 


================================================
File: src/core/config.py
================================================
# config.py
import os

# General
FPS = 60

# Screen Dimensions
EDITOR_WIDTH = 1300
EDITOR_HEIGHT = 800
BATTLE_WIDTH = 1200
BATTLE_HEIGHT = 600
MENU_WIDTH = 800
MENU_HEIGHT = 600

# Sprite Configuration
NATIVE_SPRITE_RESOLUTION = (32, 32)
# Overworld Configuration
OVERWORLD_TILE_SIZE = NATIVE_SPRITE_RESOLUTION[0]
OVERWORLD_GRID_WIDTH = 20
OVERWORLD_GRID_HEIGHT = 15
OVERWORLD_WIDTH = OVERWORLD_TILE_SIZE * OVERWORLD_GRID_WIDTH
OVERWORLD_HEIGHT = OVERWORLD_TILE_SIZE * OVERWORLD_GRID_HEIGHT
# Default tileset to fall back on for overworld/tile editor
DEFAULT_TILESET_ID = "basic_overworld"
# Factor to scale native sprites for battle display
BATTLE_SPRITE_SCALE_FACTOR = 6
BATTLE_SPRITE_DISPLAY_SIZE = (
    NATIVE_SPRITE_RESOLUTION[0] * BATTLE_SPRITE_SCALE_FACTOR,
    NATIVE_SPRITE_RESOLUTION[1] * BATTLE_SPRITE_SCALE_FACTOR
)

# Editor Specific Configuration
# Visual grid matches native width
EDITOR_GRID_SIZE = NATIVE_SPRITE_RESOLUTION[0]
# Magnification factor for display in editor
EDITOR_PIXEL_SIZE = 15
MAX_BRUSH_SIZE = 20
PALETTE_COLS = 20
PALETTE_ROWS = 8

# Background Configuration
# Default size used by editor if creating new or no background exists
DEFAULT_BACKGROUND_WIDTH = 1600
DEFAULT_BACKGROUND_HEIGHT = 800
# Note: Battle sim scales loaded backgrounds to BATTLE_WIDTH, BATTLE_HEIGHT

# Directory Paths (relative to project root)
# Use absolute paths based on this file's location for robustness
# Go up two levels: src/core -> src -> project_root
# PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Previous attempt

# Calculate paths based on this file's location
CONFIG_DIR = os.path.dirname(os.path.abspath(__file__)) # .../pokeclone/src/core
SRC_DIR = os.path.dirname(CONFIG_DIR) # .../pokeclone/src
PROJECT_ROOT = os.path.dirname(SRC_DIR) # .../pokeclone

DATA_DIR = os.path.join(PROJECT_ROOT, "data")
MAP_DIR = os.path.join(DATA_DIR, "maps")
TILESET_DIR = os.path.join(DATA_DIR, "tilesets")
TILE_IMAGE_DIR = os.path.join(PROJECT_ROOT, "tiles")
SPRITE_DIR = os.path.join(PROJECT_ROOT, "sprites")
BACKGROUND_DIR = os.path.join(PROJECT_ROOT, "backgrounds")
SOUNDS_DIR = os.path.join(PROJECT_ROOT, "sounds") # For POKE-13
SONGS_DIR = os.path.join(PROJECT_ROOT, "songs")
REFERENCE_IMAGE_DIR = os.path.join(PROJECT_ROOT, "references")

# Battle Mechanics
STAT_CHANGE_MULTIPLIER = 0.66

# UI Elements Fonts (Using None uses default pygame font)
DEFAULT_FONT = None # Pygame default
BATTLE_FONT_SIZE = 30
EDITOR_INFO_FONT_SIZE = 16
PALETTE_FONT_SIZE = 14
BUTTON_FONT_SIZE = 14
MENU_TITLE_FONT_SIZE = 48
MENU_OPTION_FONT_SIZE = 28
OVERWORLD_FONT_SIZE = 20

# Colors (Define common colors here)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
GRAY_LIGHT = (200, 200, 200)
GRAY_MEDIUM = (170, 170, 170)
GRAY_DARK = (100, 100, 100)

EDITOR_BG_COLOR = GRAY_LIGHT
BATTLE_BG_COLOR = WHITE
OVERWORLD_BG_COLOR = (90, 140, 90)
HP_BAR_COLOR = GREEN
BUTTON_COLOR = GRAY_LIGHT
BUTTON_HOVER_COLOR = GRAY_MEDIUM
SELECTION_HIGHLIGHT_COLOR = RED
SELECTION_FILL_COLOR = (*BLUE, 50) # Semi-transparent blue
GRID_COLOR_1 = GRAY_LIGHT
GRID_COLOR_2 = WHITE
TRANSPARENT_INDICATOR_COLOR = RED # For palette
MENU_BG_COLOR = GRAY_LIGHT
MENU_TEXT_COLOR = BLACK
MENU_HIGHLIGHT_COLOR = GREEN

# Panning Speed
PAN_SPEED_PIXELS = 20 # Pixels to shift per pan action

# Ensure data directory exists (optional nice-to-have)
if not os.path.exists(DATA_DIR):
    print(f"Warning: Data directory '{DATA_DIR}' not found. Creating it.")
    os.makedirs(DATA_DIR)

# Ensure asset directories exist
for dir_path in [SPRITE_DIR, BACKGROUND_DIR, SOUNDS_DIR, SONGS_DIR, REFERENCE_IMAGE_DIR, MAP_DIR, TILESET_DIR, TILE_IMAGE_DIR]:
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)
        print(f"Created missing directory: {dir_path}")

print("Configuration loaded.") 



================================================
File: src/core/event_handler.py
================================================
#!/usr/bin/env python3
import pygame
from pygame.locals import MOUSEBUTTONDOWN, MOUSEMOTION, MOUSEBUTTONUP, KEYDOWN, QUIT, KMOD_META, KMOD_CTRL, KMOD_ALT, K_z, K_y, K_c, K_v, K_RETURN, K_BACKSPACE, K_ESCAPE, K_UP, K_DOWN, MOUSEWHEEL
from src.core import config
# Import the Button class from editor_ui
# from ..editor.editor_ui import Button, Palette # Relative import
from src.editor.editor_ui import Button, Palette # Absolute import

# <<< Import Editor for type hint if needed, or remove if mock is sufficient
# from ..editor.pixle_art_editor import Editor # Relative import (Commented out)
# from src.editor.pixle_art_editor import Editor # Absolute import (Commented out)

class EventHandler:
    def __init__(self, editor):
        """
        Initializes the event handler.

        Args:
            editor: The main editor instance, used to access state and call methods.
        """
        self.editor = editor
        self.left_mouse_button_down = False # <<< Add flag to track mouse state
        self.ref_img_panning = False # <<< Flag for panning reference image

    def process_event(self, event):
        """
        Process a single Pygame event.
        Delegates event handling to specific methods based on event type and editor state.

        Args:
            event: The Pygame event to process.

        Returns:
            bool: True if the event was handled, False otherwise. 
                  Returning False for QUIT allows the main loop to catch it.
        """
        # Handle dialog events first if a dialog is active
        if self.editor.dialog_mode:
            return self._handle_dialog_event(event)

        # --- Normal Event Handling (No Dialog Active) ---
        if event.type == QUIT:
             return False # Let main loop handle closing

        if event.type == MOUSEBUTTONDOWN:
            # Store the fact that the mouse button is down
            # Needed for handle_drag logic
            self.left_mouse_button_down = (event.button == 1) 
            return self._handle_mouse_button_down(event)
        elif event.type == MOUSEMOTION:
            return self._handle_mouse_motion(event)
        elif event.type == MOUSEBUTTONUP:
            if event.button == 1:
                self.left_mouse_button_down = False # Reset flag
            return self._handle_mouse_button_up(event)
        elif event.type == KEYDOWN:
            return self._handle_key_down(event)
        
        # --- Handle Mouse Wheel for Zoom/Scroll ---
        elif event.type == pygame.MOUSEWHEEL:
             # --- Reference Image Scaling --- 
             mods = pygame.key.get_mods()
             if self.editor.edit_mode == 'monster' and (mods & KMOD_ALT):
                 active_sprite_editor = self.editor.sprites.get(self.editor.current_sprite)
                 if active_sprite_editor:
                     editor_rect = pygame.Rect(active_sprite_editor.position, 
                                                (active_sprite_editor.display_width, active_sprite_editor.display_height))
                     if editor_rect.collidepoint(pygame.mouse.get_pos()): # Check if mouse is over editor
                         scale_factor = 1.1 if event.y > 0 else (1 / 1.1)
                         self.editor.ref_img_scale *= scale_factor
                         # Clamp scale
                         self.editor.ref_img_scale = max(0.1, min(self.editor.ref_img_scale, 10.0))
                         print(f"Reference image scale: {self.editor.ref_img_scale:.2f}")
                         self.editor._scale_reference_image() # Rescale after zoom
                         return True # Consumed event
             # --- End Reference Image Scaling ---
             
             # TODO: Implement background zoom/scroll or palette scroll here if needed
             pass # Pass if not handled by ref img scaling

        return False # Event not handled by this function

    def _handle_dialog_event(self, event):
        """Handles events when a dialog is active."""
        editor = self.editor # Alias for convenience
        # print(f"DEBUG: Handling dialog event: {event.type}, Mode: {editor.dialog_mode}") # REMOVED

        # Handle clicks on dialog buttons
        if event.type == MOUSEBUTTONDOWN and event.button == 1:
             # print(f"DEBUG: Dialog MOUSEBUTTONDOWN at {event.pos}") # REMOVED
             # print(f"DEBUG: Checking editor.dialog_options (len={len(editor.dialog_options)}): {editor.dialog_options}") # REMOVED
             for i, option in enumerate(editor.dialog_options):
                  # Check if it's a button AND it was clicked
                  if isinstance(option, Button): # Use imported Button
                       # print(f"DEBUG: Checking Button {i}: '{option.text}' at {option.rect}") # REMOVED
                       if option.rect.collidepoint(event.pos): # Use imported Button
                           # print(f"DEBUG: Collision DETECTED with Button '{option.text}'!") # REMOVED
                           # Use button's stored value to call the dialog choice handler
                           if hasattr(option, 'value') and option.value is not None:
                                # print(f"DEBUG: Button has value '{option.value}', calling _handle_dialog_choice...") # REMOVED
                                editor._handle_dialog_choice(option.value)
                                return True # Handled by dialog button click
                           # Handle direct action buttons if necessary
                           elif hasattr(option, 'action') and callable(option.action):
                                # print(f"DEBUG: Button has action '{option.action.__name__}', calling action...") # REMOVED
                                option.action()
                                return True
             if editor.dialog_mode in ['load_bg', 'load_ref', 'load_tileset'] and isinstance(getattr(editor, 'dialog_file_list_rect', None), pygame.Rect):
                  if editor.dialog_file_list_rect.collidepoint(event.pos):
                       line_height = editor.font.get_linesize()
                       relative_y = event.pos[1] - editor.dialog_file_list_rect.y
                       clicked_index = editor.dialog_file_scroll_offset + (relative_y // line_height)
                       if 0 <= clicked_index < len(editor.dialog_file_list):
                            editor.dialog_selected_file_index = clicked_index
                            if hasattr(editor, '_ensure_dialog_scroll'):
                                editor._ensure_dialog_scroll()
                       return True
                  if isinstance(getattr(editor, 'dialog_file_scrollbar_rect', None), pygame.Rect):
                       if editor.dialog_file_scrollbar_rect.collidepoint(event.pos):
                            editor.dialog_file_dragging_scrollbar = True
                            if hasattr(editor, '_set_scroll_offset_from_thumb'):
                                editor._set_scroll_offset_from_thumb(event.pos[1])
                            return True
             if editor.dialog_mode in ['load_bg', 'load_ref', 'load_tileset']:
                  for rect, path in getattr(editor, 'dialog_quick_dir_rects', []):
                       if rect.collidepoint(event.pos):
                            if hasattr(editor, '_set_dialog_directory'):
                                editor._set_dialog_directory(path)
                            return True
             # TODO: Handle clicks/drags within specific dialog types (color picker, file list scroll)
            # e.g., if editor.dialog_mode == 'color_picker': handle_color_picker_click/drag
            # e.g., if editor.dialog_mode == 'load_bg': handle_file_list_click/scroll

        # Handle KEYDOWN specifically for dialogs that need it
        elif event.type == KEYDOWN:
             if editor.dialog_mode == 'input_text' and editor.dialog_input_active:
                  if event.key == K_RETURN:
                       # Find the 'Save' or confirm button's value/action if possible,
                       # otherwise assume current input text is the value
                       confirm_value = editor.dialog_input_text
                       for btn in editor.dialog_options:
                           if isinstance(btn, Button) and btn.text.lower() == "save": # Use imported Button
                               confirm_value = btn.value if hasattr(btn, 'value') else confirm_value
                               break
                       editor._handle_dialog_choice(confirm_value)
                  elif event.key == K_BACKSPACE:
                       editor.dialog_input_text = editor.dialog_input_text[:-1]
                  elif event.key == K_ESCAPE:
                       # Find the 'Cancel' button's value/action if possible
                       cancel_value = None
                       for btn in editor.dialog_options:
                           if isinstance(btn, Button) and btn.text.lower() == "cancel": # Use imported Button
                               cancel_value = btn.value if hasattr(btn, 'value') else None
                               break
                       editor._handle_dialog_choice(cancel_value)
                  elif len(editor.dialog_input_text) < editor.dialog_input_max_length:
                       # Filter unwanted characters? For now, allow most printable chars
                       if event.unicode.isprintable():
                            editor.dialog_input_text += event.unicode
                  return True # Consume key event for text input

             # Handle key navigation for file list dialog
             elif editor.dialog_mode in ['load_bg', 'load_ref', 'load_tileset']:
                  if event.key == K_UP:
                       if editor.dialog_selected_file_index > 0:
                            editor.dialog_selected_file_index -= 1
                            if hasattr(editor, '_ensure_dialog_scroll'):
                                editor._ensure_dialog_scroll()
                       # TODO: Add scroll logic if file list exceeds display area
                       return True
                  elif event.key == K_DOWN:
                       if editor.dialog_selected_file_index < len(editor.dialog_file_list) - 1:
                            editor.dialog_selected_file_index += 1
                            if hasattr(editor, '_ensure_dialog_scroll'):
                                editor._ensure_dialog_scroll()
                       # TODO: Add scroll logic
                       return True
                  elif event.key == K_RETURN:
                       if 0 <= editor.dialog_selected_file_index < len(editor.dialog_file_list):
                            # Find the 'Load' button's value/action if possible,
                            # otherwise assume selected file index implies load action
                            load_value = editor.dialog_file_list[editor.dialog_selected_file_index]
                            for btn in editor.dialog_options:
                                if isinstance(btn, Button) and btn.text.lower() == "load": # Use imported Button
                                    load_value = btn.value if hasattr(btn, 'value') else load_value
                                    break
                            editor._handle_dialog_choice(load_value)
                       return True
                  elif event.key == K_ESCAPE:
                       # Find the 'Cancel' button's value/action
                       cancel_value = None
                       for btn in editor.dialog_options:
                           if isinstance(btn, Button) and btn.text.lower() == "cancel": # Use imported Button
                               cancel_value = btn.value if hasattr(btn, 'value') else None
                               break
                       editor._handle_dialog_choice(cancel_value)
                       return True

             # Generic Escape to cancel other simple choice dialogs
             elif event.key == K_ESCAPE:
                 if editor.dialog_mode in ['choose_edit_mode', 'choose_bg_action']:
                      editor._handle_dialog_choice(None) # Assuming None means cancel
                 return True
        elif event.type == MOUSEMOTION:
             if editor.dialog_mode in ['load_bg', 'load_ref', 'load_tileset'] and getattr(editor, 'dialog_file_dragging_scrollbar', False):
                  if hasattr(editor, '_set_scroll_offset_from_thumb'):
                       editor._set_scroll_offset_from_thumb(event.pos[1])
                  return True
        elif event.type == MOUSEBUTTONUP and event.button == 1:
             if editor.dialog_mode in ['load_bg', 'load_ref', 'load_tileset']:
                  editor.dialog_file_dragging_scrollbar = False
        elif event.type == pygame.MOUSEWHEEL:
             if editor.dialog_mode in ['load_bg', 'load_ref', 'load_tileset']:
                  if len(editor.dialog_file_list) > editor.dialog_file_page_size:
                       editor.dialog_file_scroll_offset = max(
                            0,
                            min(
                                editor.dialog_file_scroll_offset - event.y,
                                len(editor.dialog_file_list) - editor.dialog_file_page_size,
                            ),
                       )
                  return True

        return True # Consume other unhandled events while dialog is open

    def _handle_mouse_button_down(self, event):
        """Handles mouse button down events when no dialog is active."""
        editor = self.editor

        if event.button == 1: # Left click
            # 0a. Check Subject Alpha Slider Click/Drag Start
            if self.editor.edit_mode == 'monster' and self.editor.subj_alpha_slider_rect.collidepoint(event.pos):
                self.editor.adjusting_subject_alpha = True
                self._update_subject_alpha_slider(event.pos) # Update alpha and knob position
                return True # Event handled
                
            # 0b. Check Reference Alpha Slider Click/Drag Start
            if self.editor.ref_alpha_slider_rect.collidepoint(event.pos):
                self.editor.adjusting_alpha = True
                self._update_alpha_slider(event.pos) # Update alpha and knob position
                return True # Event handled

            # 0c. Check Reference Image Pan Start (Alt + Click on active editor)
            mods = pygame.key.get_mods()
            if self.editor.edit_mode == 'monster' and (mods & KMOD_ALT):
                active_sprite_editor = self.editor.sprites.get(self.editor.current_sprite)
                if active_sprite_editor:
                    editor_rect = pygame.Rect(active_sprite_editor.position, 
                                               (active_sprite_editor.display_width, active_sprite_editor.display_height))
                    if editor_rect.collidepoint(event.pos):
                        self.ref_img_panning = True
                        # Maybe change cursor?
                        # pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_SIZEALL)
                        print("Reference image panning started.")
                        return True # Event handled by starting ref image pan

            # 1. Check UI Buttons
            for button in editor.buttons:
                if button.is_clicked(event):
                    if button.action:
                        button.action() # Call the button's assigned method
                    return True # <<< CRITICAL: Ensure button click consumes the event

            # 2. Check Palette Click
            palette_rect = pygame.Rect(editor.palette.position[0], editor.palette.position[1],
                                     config.PALETTE_COLS * (editor.palette.block_size + editor.palette.padding),
                                     config.PALETTE_ROWS * (editor.palette.block_size + editor.palette.padding) + 40) # Include scroll area roughly
            if palette_rect.collidepoint(event.pos):
                editor.palette.handle_click(event.pos, editor) # <<< Pass editor instance
                return True # <<< CRITICAL: Ensure palette click consumes the event

            # 2b. Tile/NPC panel click
            if editor.edit_mode == 'tile':
                if editor.asset_edit_target == 'tile':
                    if editor.handle_tile_panel_click(event.pos):
                        return True
                else:
                    if editor.handle_npc_panel_click(event.pos):
                        return True

            # 3. Check Canvas Click (Sprite or Background)
            clicked_sprite_editor = editor._get_sprite_editor_at_pos(event.pos)
            is_bg_click = editor.edit_mode == 'background' and editor.canvas_rect.collidepoint(event.pos)

            if clicked_sprite_editor or is_bg_click:
                # Save state BEFORE the action starts (important for undo)
                # Only save state if not already dragging a selection
                if not (editor.mode == 'select' and editor.selection.selecting):
                     editor.save_state()

                if editor.mode == 'select':
                    if clicked_sprite_editor:
                         # If in select mode, a click on a sprite canvas ALWAYS starts the process.
                         # The SelectionTool.start method should handle the state.
                         editor.selection.start(event.pos, clicked_sprite_editor)
                         # Set selecting flag AFTER calling start
                         editor.selection.selecting = True 
                else: # Draw, erase, fill, paste modes
                    editor.tool_manager.handle_click(event.pos) # <<< Use ToolManager
                return True # Event handled by canvas click
            else:
                 # Click outside canvas areas
                 if editor.mode == 'select' and editor.selection.selecting:
                      # If currently selecting, clicking outside cancels it
                      print("Selection cancelled (clicked outside grid).")
                      editor.selection.selecting = False
                      editor.selection.active = False
                 # Reset drawing flag if click was outside canvas
                 # editor.drawing = False # REMOVED
                 return True # Consume click outside relevant areas

        elif event.button == 4: # Mouse wheel up
             # Handle palette scroll if mouse is over it
             palette_rect = pygame.Rect(editor.palette.position[0], editor.palette.position[1],
                                         config.PALETTE_COLS * (editor.palette.block_size + editor.palette.padding) + 30, # Rough width including scroll
                                         config.PALETTE_ROWS * (editor.palette.block_size + editor.palette.padding))
             if palette_rect.collidepoint(event.pos):
                 editor.palette.scroll_offset = max(0, editor.palette.scroll_offset - 1)
                 return True
             # TODO: Add zoom or other scroll behavior here if needed

        elif event.button == 5: # Mouse wheel down
              # Handle palette scroll if mouse is over it
             palette_rect = pygame.Rect(editor.palette.position[0], editor.palette.position[1],
                                         config.PALETTE_COLS * (editor.palette.block_size + editor.palette.padding) + 30, # Rough width
                                         config.PALETTE_ROWS * (editor.palette.block_size + editor.palette.padding))
             if palette_rect.collidepoint(event.pos):
                 editor.palette.scroll_offset = min(editor.palette.total_pages - 1, editor.palette.scroll_offset + 1)
                 return True
             # TODO: Add zoom or other scroll behavior here if needed

        # Handle Middle Mouse Button for Panning Start
        elif event.button == 2: # Middle mouse button
            if self.editor.edit_mode == 'background' and self.editor.canvas_rect and self.editor.canvas_rect.collidepoint(event.pos):
                self.editor.panning = True
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND) # Change cursor to hand
                return True # Panning started
                
        # Handle Right-click, Middle-click, etc. if needed
        # elif event.button == 3: # Right click
        #     # Example: Eyedropper tool?
        #     sprite_at_pos = editor._get_sprite_editor_at_pos(event.pos)
        #     if sprite_at_pos:
        #         grid_pos = sprite_at_pos.get_grid_position(event.pos)
        #         if grid_pos:
        #             color = sprite_at_pos.get_pixel_color(grid_pos)
        #             if color: editor.select_color(color)
        #             return True
        #     pass

        return False # Event not handled

    def _handle_mouse_motion(self, event):
        """Handles mouse motion events when no dialog is active."""
        editor = self.editor

        # Handle Subject Alpha Slider Drag
        if editor.adjusting_subject_alpha and (event.buttons[0] == 1):
            self._update_subject_alpha_slider(event.pos)
            return True

        # Handle Reference Image Panning Drag (Alt + Drag)
        if self.ref_img_panning and (event.buttons[0] == 1):
            mods = pygame.key.get_mods() # Re-check mods in case Alt released mid-drag? Maybe not needed if start requires Alt.
            if mods & KMOD_ALT: # Continue panning only if Alt is still held?
                 dx, dy = event.rel
                 self.editor.ref_img_offset.x += dx
                 self.editor.ref_img_offset.y += dy
                 self.editor._scale_reference_image() # Rescale needed after offset change
                 return True # Consumed event
            else: # If Alt released, stop panning
                 self.ref_img_panning = False
                 # Maybe change cursor back?
                 # pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                 print("Reference image panning stopped (Alt released).")
                 return True

        # Handle Panning Drag
        if editor.panning and (event.buttons[1] == 1): # Check if middle button is held
            dx, dy = event.rel # Get relative motion
            editor.view_offset_x -= dx # Adjust view offset (inverse of mouse motion)
            editor.view_offset_y -= dy
            
            # Clamp view offset (ensure this logic matches draw_ui clamping)
            if editor.current_background:
                scaled_width = int(editor.current_background.get_width() * editor.editor_zoom)
                scaled_height = int(editor.current_background.get_height() * editor.editor_zoom)
                max_offset_x = max(0, scaled_width - editor.canvas_rect.width)
                max_offset_y = max(0, scaled_height - editor.canvas_rect.height)
                editor.view_offset_x = max(0, min(editor.view_offset_x, max_offset_x))
                editor.view_offset_y = max(0, min(editor.view_offset_y, max_offset_y))
            return True # Panning motion handled

        # Handle Reference alpha slider drag
        if editor.adjusting_alpha and (event.buttons[0] == 1): # Check if left button is held
            self._update_alpha_slider(event.pos) # Update alpha and knob position
            return True # Event handled

        # Handle drawing/erase/tool drag via ToolManager
        # Check if left button is down (using our flag) AND not in select mode
        if self.left_mouse_button_down and editor.mode != 'select':
             editor.tool_manager.handle_drag(event.pos) # <<< Use ToolManager
             return True

        # Handle selection drag
        elif editor.mode == 'select' and editor.selection.selecting and (event.buttons[0] == 1):
             clicked_sprite_editor = editor._get_sprite_editor_at_pos(event.pos)
             # Update selection only if dragging over the *same* editor? Or any? For now, any.
             if clicked_sprite_editor:
                  editor.selection.update(event.pos, clicked_sprite_editor) # Pass sprite editor
             # Allow drag outside the initial sprite editor? Yes for now.
             # Might need refinement if dragging over the *other* sprite editor.
             return True
        
        # TODO: Handle panning drag (e.g., middle mouse button held)

        return False # Event not handled

    def _handle_mouse_button_up(self, event):
        """Handles mouse button up events when no dialog is active."""
        editor = self.editor

        if event.button == 1: # Left button release
             # Stop adjusting subject alpha slider
            if editor.adjusting_subject_alpha:
                editor.adjusting_subject_alpha = False
                return True # Event handled
                
             # Stop adjusting reference alpha slider
            if editor.adjusting_alpha:
                editor.adjusting_alpha = False
                return True # Event handled

            # Handle drawing end - NO LONGER NEEDED HERE
            # if editor.drawing:
            #     editor.drawing = False
            #     return True

            # Handle selection end
            elif editor.mode == 'select' and editor.selection.selecting:
                # End selection regardless of where mouse is released? Or only if over canvas?
                # Current logic uses position from event. Let's assume release anywhere ends it.
                clicked_sprite_editor = editor._get_sprite_editor_at_pos(event.pos)
                # Need the sprite editor instance where selection *started* potentially,
                # but for now, just use the current one if available. If released outside,
                # end_selection might use the last known end_pos. This needs selection_manager logic check.
                # For now, assume end_selection handles release position correctly.
                # We might need to store which editor the selection started on if it matters.
                target_editor = clicked_sprite_editor if clicked_sprite_editor else editor.get_active_canvas()
                if target_editor:
                    editor.selection.end_selection(event.pos, target_editor) # Pass editor instance, fallback to current if released outside
                editor.selection.selecting = False # Turn off selecting flag
                # Keep editor.selection.active True
                return True

            # Stop Reference Image Panning
            elif self.ref_img_panning:
                 self.ref_img_panning = False
                 # Maybe change cursor back?
                 # pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                 print("Reference image panning stopped.")
                 return True

        elif event.button == 2: # Middle button release
            if editor.panning:
                editor.panning = False
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW) # Change cursor back
                return True # Panning stopped

        return False # Event not handled

    def _handle_key_down(self, event):
        """Handles key down events when no dialog is active."""
        editor = self.editor

        # Modifier keys (Ctrl/Cmd) for shortcuts
        modifier_pressed = event.mod & KMOD_META or event.mod & KMOD_CTRL

        if modifier_pressed:
            if event.key == K_z:
                editor.undo()
                return True
            if event.key == K_y:
                editor.redo()
                return True
            if event.key == K_c and editor.mode == 'select':
                 editor.copy_selection()
                 return True
            if event.key == K_v:
                 editor.paste_selection()
                 return True
            # Add other Ctrl/Cmd shortcuts (e.g., Save - K_s?)
            # if event.key == K_s:
            #     editor.save_current() # Assuming a generic save method exists
            #     return True

        # Non-modifier key actions
        else:
            # --- Background Panning with Arrow Keys --- 
            if editor.edit_mode == 'background':
                panned = False
                if event.key == pygame.K_LEFT:
                    editor.view_offset_x -= config.PAN_SPEED_PIXELS
                    panned = True
                elif event.key == pygame.K_RIGHT:
                    editor.view_offset_x += config.PAN_SPEED_PIXELS
                    panned = True
                elif event.key == pygame.K_UP:
                    editor.view_offset_y -= config.PAN_SPEED_PIXELS
                    panned = True
                elif event.key == pygame.K_DOWN:
                    editor.view_offset_y += config.PAN_SPEED_PIXELS
                    panned = True
                
                if panned:
                    # Clamp view offset after panning
                    if editor.current_background:
                        scaled_width = int(editor.current_background.get_width() * editor.editor_zoom)
                        scaled_height = int(editor.current_background.get_height() * editor.editor_zoom)
                        max_offset_x = max(0, scaled_width - editor.canvas_rect.width)
                        max_offset_y = max(0, scaled_height - editor.canvas_rect.height)
                        editor.view_offset_x = max(0, min(editor.view_offset_x, max_offset_x))
                        editor.view_offset_y = max(0, min(editor.view_offset_y, max_offset_y))
                    return True # Arrow key handled for panning
            # --- End Background Panning ---
            
            # Add other non-modifier key actions here (e.g., tool switching)
            # if event.key == K_d: editor.set_tool('draw')
            # ...
            pass

        return False # Event not handled

    def _update_alpha_slider(self, mouse_pos):
        """Helper to update REFERENCE alpha value and knob position based on mouse click/drag."""
        editor = self.editor
        # Calculate relative x position within the slider track
        click_x_relative = mouse_pos[0] - editor.ref_alpha_slider_rect.x
        # Clamp relative position to bounds [0, slider_width]
        click_x_relative = max(0, min(editor.ref_alpha_slider_rect.width, click_x_relative))

        # Calculate effective width for ratio (slider width minus knob width for better feel?)
        # Or just use full slider width? Let's try full width first.
        slider_width_effective = editor.ref_alpha_slider_rect.width
        if slider_width_effective <= 0: slider_width_effective = 1 # Avoid division by zero

        # Calculate new alpha value (0-255)
        new_alpha = (click_x_relative / slider_width_effective) * 255
        editor.set_reference_alpha(new_alpha) # This clamps and applies alpha

        # Update knob position visually based on the relative click/drag position
        # Adjust the knob's center based on the relative click pos within the slider track
        # Ensure knob stays within bounds
        knob_center_x = editor.ref_alpha_slider_rect.x + click_x_relative
        editor.ref_alpha_knob_rect.centerx = knob_center_x
        # Clamp knob position fully within slider track bounds
        editor.ref_alpha_knob_rect.left = max(editor.ref_alpha_slider_rect.left, editor.ref_alpha_knob_rect.left)
        editor.ref_alpha_knob_rect.right = min(editor.ref_alpha_slider_rect.right, editor.ref_alpha_knob_rect.right)

    def _update_subject_alpha_slider(self, mouse_pos):
        """Helper to update SUBJECT alpha value and knob position based on mouse click/drag."""
        editor = self.editor
        # Calculate relative x position within the subject slider track
        click_x_relative = mouse_pos[0] - editor.subj_alpha_slider_rect.x
        click_x_relative = max(0, min(editor.subj_alpha_slider_rect.width, click_x_relative))

        slider_width_effective = editor.subj_alpha_slider_rect.width
        if slider_width_effective <= 0: slider_width_effective = 1

        # Calculate new alpha value (0-255)
        new_alpha = (click_x_relative / slider_width_effective) * 255
        editor.set_subject_alpha(new_alpha) # This clamps, updates alpha, and moves knob

# Note: This EventHandler assumes it receives the main Editor instance.
# Dependencies like editor.Button need to be handled (either import Button here or access via editor.Button).
# Methods like editor._handle_canvas_click, editor._get_sprite_editor_at_pos, editor.save_state, etc.,
# are called directly on the editor instance for now. These might be further refactored later.



================================================
File: src/core/tileset.py
================================================
import json
import os
import struct
import zlib
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from src.core import config


@dataclass
class TileDefinition:
    """Metadata for a single tile in a tileset."""
    id: str
    name: str
    filename: str
    frames: List[str] = field(default_factory=list)
    frame_duration_ms: int = 200
    properties: Dict[str, object] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: Dict[str, object]) -> "TileDefinition":
        filename = data.get("filename", f"{data.get('id', 'tile')}.png")
        frames = data.get("frames") or []
        if not frames:
            frames = [filename]
        return cls(
            id=data.get("id", ""),
            name=data.get("name", "") or data.get("id", ""),
            filename=filename,
            frames=frames,
            frame_duration_ms=data.get("frameDurationMs", 200),
            properties=data.get("properties", {}) or {},
        )

    def to_dict(self) -> Dict[str, object]:
        return {
            "id": self.id,
            "name": self.name,
            "filename": self.filename,
            "frames": self.frames,
            "frameDurationMs": self.frame_duration_ms,
            "properties": self.properties,
        }


@dataclass
class NPCSprite:
    """NPC sprite set with multiple states and angles."""
    id: str
    name: str
    frame_duration_ms: int = 200
    # states[state][angle] = [frame filenames]
    states: Dict[str, Dict[str, List[str]]] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: Dict[str, object]) -> "NPCSprite":
        return cls(
            id=data.get("id", ""),
            name=data.get("name", "") or data.get("id", ""),
            frame_duration_ms=data.get("frameDurationMs", 200),
            states=data.get("states", {}) or {},
        )

    def to_dict(self) -> Dict[str, object]:
        return {
            "id": self.id,
            "name": self.name,
            "frameDurationMs": self.frame_duration_ms,
            "states": self.states,
        }


def _write_solid_color_png(path: str, size: int, rgba: List[int]) -> None:
    """Write a minimal RGBA PNG using only the standard library."""
    width = height = size
    r, g, b, a = rgba
    # Each row starts with filter byte 0
    row = bytes([0] + [r, g, b, a] * width)
    raw_data = row * height

    def _chunk(tag: bytes, data: bytes) -> bytes:
        return (
            struct.pack("!I", len(data))
            + tag
            + data
            + struct.pack("!I", zlib.crc32(tag + data) & 0xFFFFFFFF)
        )

    header = b"\x89PNG\r\n\x1a\n"
    ihdr = _chunk(
        b"IHDR",
        struct.pack("!IIBBBBB", width, height, 8, 6, 0, 0, 0),
    )
    idat = _chunk(b"IDAT", zlib.compress(raw_data))
    iend = _chunk(b"IEND", b"")

    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "wb") as f:
        f.write(header + ihdr + idat + iend)


class TileSet:
    """Represents a collection of tiles plus metadata and persistence helpers."""

    def __init__(self, tileset_id: str, name: str, tile_size: int = None, version: str = "1.0.0"):
        self.id = tileset_id
        self.name = name
        self.tile_size = tile_size or config.OVERWORLD_TILE_SIZE
        self.version = version
        self.tiles: List[TileDefinition] = []
        self.npcs: List[NPCSprite] = []

    @property
    def image_dir(self) -> str:
        return os.path.join(config.TILE_IMAGE_DIR, self.id)

    @property
    def npc_image_dir(self) -> str:
        return os.path.join(self.image_dir, "npcs")

    def get_tile(self, tile_id: str) -> Optional[TileDefinition]:
        for tile in self.tiles:
            if tile.id == tile_id:
                return tile
        return None

    def add_or_update_tile(self, tile: TileDefinition) -> None:
        existing = self.get_tile(tile.id)
        if existing:
            existing.name = tile.name
            existing.filename = tile.filename
            existing.frames = tile.frames or [tile.filename]
            existing.frame_duration_ms = tile.frame_duration_ms
            existing.properties = tile.properties
        else:
            self.tiles.append(tile)

    def add_or_update_npc(self, npc: NPCSprite) -> None:
        for existing in self.npcs:
            if existing.id == npc.id:
                existing.name = npc.name
                existing.frame_duration_ms = npc.frame_duration_ms
                existing.states = npc.states
                return
        self.npcs.append(npc)

    def to_dict(self) -> Dict[str, object]:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "tileSize": self.tile_size,
            "tiles": [t.to_dict() for t in self.tiles],
            "npcs": [n.to_dict() for n in self.npcs],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, object]) -> "TileSet":
        tileset = cls(
            tileset_id=data.get("id", "tileset"),
            name=data.get("name", "Tileset"),
            tile_size=data.get("tileSize") or config.OVERWORLD_TILE_SIZE,
            version=data.get("version", "1.0.0"),
        )
        for tile_data in data.get("tiles", []):
            tileset.tiles.append(TileDefinition.from_dict(tile_data))
        for npc_data in data.get("npcs", []):
            tileset.npcs.append(NPCSprite.from_dict(npc_data))
        return tileset

    @classmethod
    def load(cls, path: str) -> "TileSet":
        with open(path, "r") as f:
            data = json.load(f)
        tileset = cls.from_dict(data)
        tileset.ensure_assets()
        return tileset

    def save(self, path: Optional[str] = None) -> str:
        target_path = path or os.path.join(config.TILESET_DIR, f"{self.id}.json")
        os.makedirs(os.path.dirname(target_path), exist_ok=True)
        with open(target_path, "w") as f:
            json.dump(self.to_dict(), f, indent=2)
        return target_path

    def tile_image_path(self, tile: TileDefinition, frame_index: int = 0) -> str:
        if not tile.frames:
            tile.frames = [tile.filename]
        frame_index = max(0, min(frame_index, len(tile.frames) - 1))
        filename = tile.frames[frame_index]
        return os.path.join(self.image_dir, filename)

    def npc_image_path(self, npc: NPCSprite, state: str, angle: str, frame_index: int = 0) -> str:
        frames = npc.states.get(state, {}).get(angle, [])
        if not frames:
            frames = [f"{npc.id}_{state}_{angle}.png"]
            npc.states.setdefault(state, {})[angle] = frames
        frame_index = max(0, min(frame_index, len(frames) - 1))
        filename = frames[frame_index]
        return os.path.join(self.npc_image_dir, npc.id, filename)

    def ensure_assets(self) -> None:
        """Ensure image directory exists and missing tiles get placeholders."""
        os.makedirs(self.image_dir, exist_ok=True)
        for idx, tile in enumerate(self.tiles):
            if not tile.frames:
                tile.frames = [tile.filename]
            for frame_name in tile.frames:
                img_path = os.path.join(self.image_dir, frame_name)
                if not os.path.exists(img_path):
                    color = tile.properties.get("color")
                    if not color or len(color) != 4:
                        # Derive a deterministic color from the tile id and frame
                        seed = hash(f"{tile.id}:{frame_name}") & 0xFFFFFF
                        color = [
                            (seed >> 16) & 0xFF,
                            (seed >> 8) & 0xFF,
                            seed & 0xFF,
                            255,
                        ]
                    _write_solid_color_png(img_path, self.tile_size, color)

        for npc in self.npcs:
            for state, angles in npc.states.items():
                for angle, frames in angles.items():
                    if not frames:
                        frames[:] = [f"{npc.id}_{state}_{angle}.png"]
                    for frame_name in frames:
                        npc_dir = os.path.join(self.npc_image_dir, npc.id)
                        os.makedirs(npc_dir, exist_ok=True)
                        img_path = os.path.join(npc_dir, frame_name)
                        if not os.path.exists(img_path):
                            seed = hash(f"{npc.id}:{state}:{angle}:{frame_name}") & 0xFFFFFF
                            color = [
                                (seed >> 16) & 0xFF,
                                (seed >> 8) & 0xFF,
                                seed & 0xFF,
                                255,
                            ]
                            _write_solid_color_png(img_path, self.tile_size, color)


def list_tileset_files() -> List[str]:
    """Return a sorted list of available tileset JSON files."""
    if not os.path.isdir(config.TILESET_DIR):
        return []
    return sorted(
        [
            os.path.join(config.TILESET_DIR, name)
            for name in os.listdir(config.TILESET_DIR)
            if name.lower().endswith(".json")
        ]
    )





================================================
File: src/editor/__init__.py
================================================
 


================================================
File: src/editor/dialog_manager.py
================================================



================================================
File: src/editor/editor_ui.py
================================================
import pygame
# from ..core import config # Relative import
from src.core import config # Absolute import
import colorsys # <<< Add import for palette generation
# <<< Add forward type hint for Editor to avoid circular import
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .pixle_art_editor import Editor # Use relative import for type checking

class Button:
    """
    A simple button class for the pixel art editor.

    This class represents a clickable button with a text label. It handles drawing
    the button on a surface, checking for mouse clicks, and executing an associated
    action when clicked.

    Attributes:
        rect (pygame.Rect): The rectangle defining the button's position and size.
        text (str): The text label displayed on the button.
        action (callable): The function to be executed when the button is clicked.
        color (tuple): The background color of the button (R, G, B).
        hover_color (tuple): The background color of the button when the mouse is hovering over it (R, G, B).
        font (pygame.font.Font): The font used for rendering the button text.

    Methods:
        draw(surface: pygame.Surface) -> None
        is_clicked(event: pygame.event.Event) -> bool
    """

    def __init__(self, rect, text, action=None, value=None):
        """
        Initialize a new Button instance.

        Args:
            rect (tuple): A tuple representing the button's rectangle (x, y, width, height).
            text (str): The text label to display on the button.
            action (callable, optional): The function to be executed when the button is clicked.
            value (any, optional): The value to be stored with the button.
        """
        self.rect = pygame.Rect(rect)
        self.text = text
        self.action = action
        self.value = value
        self.color = config.BUTTON_COLOR
        self.hover_color = config.BUTTON_HOVER_COLOR
        self.font = pygame.font.Font(config.DEFAULT_FONT, config.BUTTON_FONT_SIZE)

    def draw(self, surface):
        """
        Draw the button on a given surface.

        Args:
            surface (pygame.Surface): The surface on which to draw the button.
        """
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, config.BLACK, self.rect, 2)
        text_surf = self.font.render(self.text, True, config.BLACK)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

    def is_clicked(self, event):
        """
        Check if the button was clicked based on a mouse event.

        Args:
            event (pygame.event.Event): The mouse event to check for a click.

        Returns:
            bool: True if the button was clicked, False otherwise.
        """
        return event.type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(event.pos)

# Add other UI classes here later (Palette, SpriteEditor visualization part, etc.)

# --- Palette Generation --- 
def generate_palette():
    """
    Generate an enhanced color palette for the pixel art editor.

    This function creates a wide range of colors, including a variety of hues,
    saturations, and values, as well as grayscale colors. The resulting palette
    is used for painting and color selection in the editor.

    Returns:
        list: A list of RGBA color tuples representing the generated palette.
    """
    # Use constants from config if available, otherwise use defaults
    palette_hues_step = getattr(config, 'PALETTE_HUES_STEP', 30)
    palette_saturations = getattr(config, 'PALETTE_SATURATIONS', [50, 100])
    palette_values = getattr(config, 'PALETTE_VALUES', [50, 100])
    palette_grayscale_steps = getattr(config, 'PALETTE_GRAYSCALE_STEPS', 10)

    _PALETTE = [(0, 0, 0, 255)]  # Start with black
    # Generate a wide range of colors
    for h in range(0, 360, palette_hues_step):
        for s in palette_saturations:
            for v in palette_values:
                r, g, b = colorsys.hsv_to_rgb(h/360, s/100, v/100)
                _PALETTE.append((int(r*255), int(g*255), int(b*255), 255))
    # Add grayscale
    # Ensure at least 2 steps for division
    grayscale_denom = max(1, palette_grayscale_steps -1) 
    for i in range(palette_grayscale_steps):
        gray = int(255 * i / grayscale_denom)
        _PALETTE.append((gray, gray, gray, 255))
    return _PALETTE

PALETTE = generate_palette()

# --- Palette Class --- 
class Palette:
    """
    A scrollable color palette for the pixel art editor.

    This class represents a scrollable color palette that allows users to select
    colors for painting and drawing in the editor. It supports scrolling through
    a large number of colors and provides a visual representation of each color.

    Attributes:
        position (tuple): The (x, y) position of the palette on the screen.
        block_size (int): The size of each color block in the palette.
        padding (int): The padding between color blocks.
        gap (int): The gap between the palette and other UI elements.
        font (pygame.font.Font): The font used for rendering the palette label.
        scroll_offset (int): The current scroll offset within the palette.
        colors_per_page (int): The number of colors displayed per page.
        total_pages (int): The total number of pages in the palette.

    Methods:
        draw(surface: pygame.Surface, current_color: tuple) -> None
        handle_click(pos: tuple, editor: Editor) -> None # Need editor reference for select_color
    """

    def __init__(self, position):
        """
        Initialize a new Palette instance.

        Args:
            position (tuple): The (x, y) position of the palette on the screen.
        """
        self.position = position  # (x, y) starting position on screen
        # Use constants from config for layout
        self.block_size = getattr(config, 'PALETTE_BLOCK_SIZE', 15)
        self.padding = getattr(config, 'PALETTE_PADDING', 2)
        self.gap = getattr(config, 'PALETTE_GAP', 5)
        self.font = pygame.font.Font(config.DEFAULT_FONT, config.PALETTE_FONT_SIZE)
        self.scroll_offset = 0
        self.colors_per_page = config.PALETTE_COLS * config.PALETTE_ROWS
        # Reference the PALETTE defined in this module
        self.total_pages = (len(PALETTE) + self.colors_per_page - 1) // self.colors_per_page 

    def draw(self, surface, current_color):
        """
        Draw the palette on a given surface.

        Args:
            surface (pygame.Surface): The surface on which to draw the palette.
            current_color (tuple): The currently selected color in the editor for highlighting.
        """
        x0, y0 = self.position
        current_page = self.scroll_offset
        start_index = current_page * self.colors_per_page
        end_index = start_index + self.colors_per_page
        # Reference the PALETTE defined in this module
        visible_palette = PALETTE[start_index:end_index] 

        for index, color in enumerate(visible_palette):
            col = index % config.PALETTE_COLS
            row = index // config.PALETTE_COLS
            rect = pygame.Rect(
                x0 + col * (self.block_size + self.padding),
                y0 + row * (self.block_size + self.padding),
                self.block_size,
                self.block_size
            )

            if color[3] == 0:  # Transparent color
                # Use constants from config for colors
                gray_light = getattr(config, 'GRAY_LIGHT', (211, 211, 211))
                indicator_color = getattr(config, 'TRANSPARENT_INDICATOR_COLOR', (255, 0, 0))
                pygame.draw.rect(surface, gray_light, rect)
                pygame.draw.line(surface, indicator_color, rect.topleft, rect.bottomright, 2)
                pygame.draw.line(surface, indicator_color, rect.topright, rect.bottomleft, 2)
            else:
                pygame.draw.rect(surface, color[:3], rect)

            # Use the passed current_color for comparison
            if color == current_color:
                 highlight_color = getattr(config, 'SELECTION_HIGHLIGHT_COLOR', (0, 255, 0))
                 pygame.draw.rect(surface, highlight_color, rect.inflate(4, 4), 2)

        # Palette label
        label_color = getattr(config, 'BLACK', (0,0,0))
        label = self.font.render("Palette", True, label_color)
        surface.blit(label, (x0, y0 - 30))

        # Scroll indicators
        if self.total_pages > 1:
            up_arrow = self.font.render("â†‘", True, label_color)
            down_arrow = self.font.render("â†“", True, label_color)
            surface.blit(up_arrow, (x0 + config.PALETTE_COLS * (self.block_size + self.padding) + 10, y0))
            surface.blit(down_arrow, (x0 + config.PALETTE_COLS * (self.block_size + self.padding) + 10, y0 + config.PALETTE_ROWS * (self.block_size + self.padding) - 20))

    def handle_click(self, pos, editor):
        """
        Handle a mouse click event on the palette.

        This method checks if a color block was clicked and selects the corresponding
        color in the editor. It also handles scrolling through the palette using
        the scroll indicators.

        Args:
            pos (tuple): The (x, y) position of the mouse click.
            editor (Editor): The main editor instance to call select_color on.
        """
        x0, y0 = self.position
        x, y = pos
        # Check for scroll buttons
        scroll_area_x = x0 + config.PALETTE_COLS * (self.block_size + self.padding) + 10
        if x >= scroll_area_x and x <= scroll_area_x + 20:
            scroll_area_y_top = self.position[1]
            # Calculate approx height of scroll area - bit imprecise but should work
            scroll_area_height = config.PALETTE_ROWS * (self.block_size + self.padding)
            scroll_area_y_bottom = scroll_area_y_top + scroll_area_height

            if scroll_area_y_top <= y < scroll_area_y_top + scroll_area_height / 2: # Approx top half for UP
                # Up arrow
                if self.scroll_offset > 0:
                    self.scroll_offset -= 1
            elif scroll_area_y_top + scroll_area_height / 2 <= y < scroll_area_y_bottom: # Approx bottom half for DOWN
                # Down arrow
                if self.scroll_offset < self.total_pages - 1:
                    self.scroll_offset += 1
            return

        # Determine which color was clicked
        # Reference the PALETTE defined in this module
        start_index = self.scroll_offset * self.colors_per_page
        end_index = start_index + self.colors_per_page
        visible_palette = PALETTE[start_index:end_index]

        for index, color in enumerate(visible_palette):
            col = index % config.PALETTE_COLS
            row = index // config.PALETTE_COLS
            rect = pygame.Rect(
                x0 + col * (self.block_size + self.padding),
                y0 + row * (self.block_size + self.padding),
                self.block_size,
                self.block_size
            )
            if rect.collidepoint(x, y):
                # Call the select_color method on the passed editor instance
                editor.select_color(color) 
                editor.paste_mode = False 
                if editor.mode == 'select':
                    editor.mode = 'draw'
                    editor.selection.selecting = False
                    editor.selection.active = False
                return 



================================================
File: src/editor/pixle_art_editor.py
================================================
import pygame
from pygame.locals import *
import tkinter as tk
from tkinter import filedialog, colorchooser
import sys
import os
import json
import copy
import colorsys

# Import the centralized config
from src.core import config
from src.core.tileset import TileDefinition, TileSet, list_tileset_files, NPCSprite

# Import newly created modules
from src.core.event_handler import EventHandler
from src.editor.editor_ui import Button, Palette, PALETTE
from src.editor.selection_manager import SelectionTool
from src.editor.sprite_editor import SpriteEditor
from src.editor.tool_manager import ToolManager

NPC_STATES = ["standing", "walking"]
NPC_ANGLES = ["south", "west", "east", "north"]

# Tkinter root is initialized lazily to avoid crashes on launch in some setups.
_tk_root_instance = None
_tk_init_error = None


def _get_tk_root():
    global _tk_root_instance, _tk_init_error
    if _tk_root_instance:
        return _tk_root_instance
    if _tk_init_error is not None:
        return None
    if sys.platform == "darwin":
        _tk_init_error = RuntimeError("Tk dialogs are disabled on macOS for stability.")
        return None
    try:
        _tk_root_instance = tk.Tk()
        _tk_root_instance.withdraw()
        return _tk_root_instance
    except Exception as e:
        print(f"ERROR: Tkinter initialization failed: {e}")
        _tk_init_error = e
        _tk_root_instance = None
        return None

# Initialize Pygame Globally
pygame.init()

# Constants are now in config.py
# WIDTH, HEIGHT = 1300, 800
# EDITOR_GRID_SIZE = 32 # Visual grid size for editing
# PIXEL_SIZE = 15  # Visual size of each 'pixel' in the editor grid
# NATIVE_SPRITE_RESOLUTION = (32, 32) # Actual resolution of the sprite data
# FPS = 60
# BACKGROUND_WIDTH, BACKGROUND_HEIGHT = 1600, 800
# MAX_BRUSH_SIZE = 20
# PALETTE_COLS = 20
# PALETTE_ROWS = 8

# Setup
screen = pygame.display.set_mode((config.EDITOR_WIDTH, config.EDITOR_HEIGHT))
pygame.display.set_caption("Advanced Pixel Art Sprite Editor with Enhanced Features")
clock = pygame.time.Clock()

# Load monster data
def load_monsters():
    """
    Load monster data from the 'monsters.json' file.

    This function reads the 'monsters.json' file, which contains information about
    various monsters, including their names, types, max HP, and moves. The data
    is used to populate the editor with monster sprites and their attributes.

    Returns:
        list: A list of dictionaries, each representing a monster with its attributes.
    """
    # Use path from config
    monsters_file = os.path.join(config.DATA_DIR, "monsters.json")

    try:
        with open(monsters_file, "r") as f:
            monsters = json.load(f)
        if not isinstance(monsters, list):
            raise ValueError("monsters.json should contain a list of monsters.")
        return monsters
    except FileNotFoundError:
        print(f"Error: Could not find monsters.json in {os.path.dirname(monsters_file)}")
        print("Make sure you've created the data directory and added the monsters.json file.")
        pygame.quit()
        sys.exit(1)
    except (json.JSONDecodeError, ValueError) as e:
        print(f"Error: {e}")
        pygame.quit()
        sys.exit(1)

monsters = load_monsters()

# Editor Class with Enhanced Features
class Editor:
    """
    The main controller class for the pixel art editor application.

    This class orchestrates the entire pixel art editing experience, managing
    sprite editors, color palettes, tool selection, and user interactions. It
    handles both monster sprite editing and background editing modes.

    Attributes:
        current_color (tuple): The currently selected color (R, G, B, A).
        current_monster_index (int): Index of the currently edited monster.
        drawing (bool): Flag indicating if drawing is currently active.
        eraser_mode (bool): Flag for eraser tool activation.
        fill_mode (bool): Flag for fill tool activation.
        current_sprite (str): Identifier of the currently active sprite ('front' or 'back').
        sprites (dict): Dictionary of SpriteEditor instances for each sprite type.
        palette (Palette): The color palette instance.
        brush_size (int): Current brush size for drawing.
        selection (SelectionTool): The selection tool instance.
        copy_buffer (dict): Buffer for copied pixel data.
        mode (str): Current editing mode ('draw' or 'select').
        backgrounds (list): List of available background images.
        edit_mode (str): Current editing mode ('monster' or 'background').
        editor_zoom (float): Current zoom level of the editor.

    Methods:
        handle_event(event: pygame.event.Event) -> bool
        draw_ui() -> None
        save_current() -> None
        load_session() -> None
        undo() -> None
        redo() -> None
        # ... (other methods)
    """

    def __init__(self):
        """
        Initialize a new Editor instance.
        """
        self.current_color = PALETTE[0] # <<< Uses imported PALETTE
        self.current_monster_index = 0
        self.eraser_mode = False # Keep temporarily? DrawTool uses it.
        self.fill_mode = False # Keep temporarily? Needed for FillTool logic later.
        self.paste_mode = False # Keep temporarily? Needed for PasteTool logic later.
        self.current_sprite = 'front'
        self.sprites = {
            'front': SpriteEditor((50, 110), 'front', config.SPRITE_DIR),
            'back': SpriteEditor((575, 110), 'back', config.SPRITE_DIR) 
        }
        self.palette = Palette((50, config.EDITOR_HEIGHT - 180))
        self.brush_size = 1
        self.adjusting_brush = False
        self.selection = SelectionTool(self) # SelectionTool might become a tool in ToolManager later
        self.copy_buffer = None
        self.mode = 'draw'  # Keep? Or manage via ToolManager? Keep for 'select' vs other tools for now.
        self.backgrounds = self.load_backgrounds()
        self.current_background_index = 0 if self.backgrounds else -1
        self.edit_mode = None
        self.editor_zoom = 1.0
        self.view_offset_x = 0 
        self.view_offset_y = 0
        self.panning = False

        # --- Tile Mode State ---
        self.tile_set = None
        self.tile_canvas = SpriteEditor((50, 110), 'tile', config.TILE_IMAGE_DIR)
        self.current_tile_index = -1
        self.selected_tile_id = None
        self.tile_preview_cache = {}
        self.tile_list_scroll = 0
        panel_width = 180
        panel_x = config.EDITOR_WIDTH - (100 + 5) - panel_width - 20 # leave space for the buttons column
        self.tile_panel_rect = pygame.Rect(panel_x, 50, panel_width, config.EDITOR_HEIGHT - 100)
        self.tile_button_rects = []
        self.current_tile_frame_index = 0
        self.asset_edit_target = 'tile'  # 'tile' or 'npc'
        self.tile_anim_last_tick = 0

        # NPC editing state
        self.npc_list_scroll = 0
        self.npc_button_rects = []
        self.selected_npc_id = None
        self.current_npc_state = "standing"
        self.current_npc_angle = "south"
        self.current_npc_frame_index = 0

        # Instantiate the EventHandler
        self.event_handler = EventHandler(self)

        # Instantiate the ToolManager <<< NEW
        self.tool_manager = ToolManager(self)

        self.current_background = None
        self.canvas_rect = None

        # Undo/Redo stacks
        self.undo_stack = []
        self.redo_stack = []

        self.buttons = [] # Start with empty buttons

        self.font = pygame.font.Font(config.DEFAULT_FONT, config.EDITOR_INFO_FONT_SIZE)

        self.brush_slider = pygame.Rect(50, config.EDITOR_HEIGHT - 40, 200, 20)

        # --- Reference Image Attributes ---
        self.reference_image_path = None
        self.reference_image = None # Original loaded surface
        self.scaled_reference_image = None # Scaled and alpha-applied surface for display
        self.reference_alpha = 128 # Default alpha (50% opaque)
        self.adjusting_alpha = False # Flag for slider interaction
        self.subject_alpha = 255 # << Add subject alpha (fully opaque default)
        self.adjusting_subject_alpha = False # << Add flag for subject slider

        # --- Reference Image Panning/Scaling State ---
        self.ref_img_offset = pygame.Vector2(0, 0) # Pan offset (x, y)
        self.ref_img_scale = 1.0 # Scale factor

        # Define slider rect (adjust position/size as needed)
        # Reference Alpha Slider
        ref_slider_x = 300 # Position next to brush slider for now
        ref_slider_y = config.EDITOR_HEIGHT - 40
        ref_slider_width = 150
        ref_slider_height = 20
        self.ref_alpha_slider_rect = pygame.Rect(ref_slider_x, ref_slider_y, ref_slider_width, ref_slider_height)
        ref_knob_slider_width = self.ref_alpha_slider_rect.width - 10 # Available track width
        initial_ref_knob_x = self.ref_alpha_slider_rect.x + int((self.reference_alpha / 255) * ref_knob_slider_width)
        self.ref_alpha_knob_rect = pygame.Rect(initial_ref_knob_x, ref_slider_y, 10, ref_slider_height)

        # Subject Alpha Slider (Position below reference slider)
        subj_slider_x = ref_slider_x 
        subj_slider_y = ref_slider_y + ref_slider_height + 10 # Place below ref slider
        subj_slider_width = ref_slider_width
        subj_slider_height = ref_slider_height
        self.subj_alpha_slider_rect = pygame.Rect(subj_slider_x, subj_slider_y, subj_slider_width, subj_slider_height)
        subj_knob_slider_width = self.subj_alpha_slider_rect.width - 10
        initial_subj_knob_x = self.subj_alpha_slider_rect.x + int((self.subject_alpha / 255) * subj_knob_slider_width)
        self.subj_alpha_knob_rect = pygame.Rect(initial_subj_knob_x, subj_slider_y, 10, subj_slider_height)

        # --- Dialog State ---
        self.dialog_mode = None # e.g., 'choose_edit_mode', 'choose_bg_action', 'save_bg', 'load_bg', 'color_picker', 'input_text'
        self.dialog_prompt = ""
        self.dialog_options = [] # List of tuples: (text, value) or Button objects
        self.dialog_callback = None # Function to call with the chosen value
        self.dialog_input_text = "" # For text input dialogs
        self.dialog_input_active = False # Is the text input active?
        self.dialog_input_rect = None # Rect for the input field
        self.dialog_input_max_length = 50 # Max chars for filename
        self.dialog_file_list = [] # List of files for file browser dialog
        self.dialog_file_scroll_offset = 0 # Scroll offset for file list
        self.dialog_selected_file_index = -1 # Index of selected file in list
        self.dialog_file_labels = [] # Display labels for file list
        self.dialog_file_list_rect = None # Rect for file list area
        self.dialog_file_page_size = 0 # Visible rows in file list
        self.dialog_file_scrollbar_rect = None
        self.dialog_file_scroll_thumb_rect = None
        self.dialog_file_dragging_scrollbar = False
        self.dialog_quick_dirs = []
        self.dialog_quick_dir_rects = []
        self.dialog_current_dir = ""
        self.dialog_sort_recent = True
        self.dialog_color_picker_hue = 0 # Hue for HSV color picker
        self.dialog_color_picker_sat = 1 # Saturation for HSV
        self.dialog_color_picker_val = 1 # Value for HSV
        self.dialog_color_picker_rects = {} # Rects for color picker elements
        # --- End Dialog State ---

        self.tk_root = None # Initialize instance variable for Tkinter root

        # <<< --- ADD THE CALL HERE --- >>>
        self.choose_edit_mode() # Setup the initial dialog state AFTER resetting dialog attrs

    def _ensure_tkinter_root(self):
        """Return a Tkinter root if available, otherwise None."""
        tk_root = _get_tk_root()
        if tk_root is None and _tk_init_error is not None:
            print(f"Tkinter root unavailable. Init error: {_tk_init_error}")
        return tk_root

    def choose_edit_mode(self):
        """
        Set up the dialog state to choose the editing mode (monster or background).
        The actual choice will be handled in the main loop via dialog state.
    
        Returns:
            None: Sets the initial dialog state instead of returning the mode directly.
        """
        self.dialog_mode = 'choose_edit_mode'
        self.dialog_prompt = "Choose Edit Mode:"

        # Calculate positions for vertically stacked buttons centered
        dialog_center_x = config.EDITOR_WIDTH // 2
        dialog_center_y = config.EDITOR_HEIGHT // 2
        button_width = 150
        button_height = 40
        button_padding = 10
        monster_button_y = dialog_center_y - button_height - button_padding
        tile_button_y = dialog_center_y
        background_button_y = dialog_center_y + button_height + button_padding
        button_x = dialog_center_x - button_width // 2

        self.dialog_options = [
            Button(pygame.Rect(button_x, monster_button_y, button_width, button_height), "Monster", value="monster"), # No action, store value
            Button(pygame.Rect(button_x, tile_button_y, button_width, button_height), "Tiles", value="tile"),
            Button(pygame.Rect(button_x, background_button_y, button_width, button_height), "Background", value="background"), # No action, store value
        ]
        self.dialog_callback = self._set_edit_mode_and_continue
        # print(f"DEBUG: choose_edit_mode finished. self.dialog_mode = {self.dialog_mode}") # DEBUG

        # <<< --- REMOVE THIS RETURN --- >>>
        # return "monster" # Default to monster initially

    def _set_edit_mode_and_continue(self, mode):
        """Callback after choosing edit mode."""
        # print(f"DEBUG: Start _set_edit_mode_and_continue(mode='{mode}')") # DEBUG 4 - REMOVE
        self.edit_mode = mode # Set mode FIRST
        if mode == 'background':
            # --- Setup for Background Mode --- 
            self.canvas_rect = pygame.Rect(50, 100, config.DEFAULT_BACKGROUND_WIDTH, config.DEFAULT_BACKGROUND_HEIGHT)
            self.current_background = pygame.Surface(self.canvas_rect.size, pygame.SRCALPHA)
            self.current_background.fill(config.WHITE) # Default to white
            # --- End Setup ---
            # Now trigger the background action choice (new/edit)
            # print(f"DEBUG: Before calling choose_background_action()") # DEBUG 5 - REMOVE
            self.choose_background_action()
        elif mode == 'tile':
            self.setup_tile_mode()
        else: # Monster mode
            # If monster mode, initialization is complete
            # Clear potential background canvas rect
            self.canvas_rect = None
            self.current_background = None
            self.load_monster() # Ensure monster is loaded if chosen
            self.buttons = self.create_buttons() # Recreate buttons for the correct mode
            # --- ADD CLEARING LOGIC FOR MONSTER MODE --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        # print(f"DEBUG: End _set_edit_mode_and_continue. dialog_mode={self.dialog_mode}") # DEBUG 6 - REMOVE

    def setup_tile_mode(self):
        """Initialize tile editing state and load a tileset."""
        default_path = os.path.join(config.TILESET_DIR, f"{config.DEFAULT_TILESET_ID}.json")
        self.load_tileset(default_path if os.path.exists(default_path) else None)
        self.asset_edit_target = 'tile'
        self.buttons = self.create_buttons()
        self.dialog_mode = None
        self.dialog_prompt = ""
        self.dialog_options = []
        self.dialog_callback = None

    def load_tileset(self, path=None):
        """Load a tileset from disk or create a new one if none are found."""
        chosen_path = path
        if not chosen_path:
            files = list_tileset_files()
            if files:
                chosen_path = files[0]
        if chosen_path and os.path.exists(chosen_path):
            try:
                self.tile_set = TileSet.load(chosen_path)
                print(f"Loaded tileset: {os.path.basename(chosen_path)}")
            except Exception as e:
                print(f"Failed to load tileset {chosen_path}: {e}")
                self.tile_set = None
        if not self.tile_set:
            tileset_id = config.DEFAULT_TILESET_ID
            self.tile_set = TileSet(tileset_id, "New Tileset", config.OVERWORLD_TILE_SIZE)
            default_tile = TileDefinition(id="tile_01", name="Tile 01", filename="tile_01.png", frames=["tile_01.png"], properties={"walkable": True, "color": [180, 180, 180, 255]})
            self.tile_set.add_or_update_tile(default_tile)
            self.tile_set.ensure_assets()
            self.tile_set.save(os.path.join(config.TILESET_DIR, f"{tileset_id}.json"))
            print(f"Created default tileset at {os.path.join(config.TILESET_DIR, f'{tileset_id}.json')}")

        # Ensure we have at least one tile selected
        self.current_tile_index = 0 if self.tile_set.tiles else -1
        self.selected_tile_id = self.tile_set.tiles[0].id if self.tile_set.tiles else None
        self.current_tile_frame_index = 0
        self.selected_npc_id = self.tile_set.npcs[0].id if self.tile_set.npcs else None
        self.current_npc_state = NPC_STATES[0]
        self.current_npc_angle = NPC_ANGLES[0]
        self.current_npc_frame_index = 0
        self.tile_preview_cache = {}
        self.tile_list_scroll = 0
        self.npc_list_scroll = 0
        self.npc_button_rects = []
        self._load_current_tile_to_canvas()

    def _load_current_tile_to_canvas(self):
        """Load the currently selected tile image into the editing canvas."""
        self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
        tile = self.current_tile()
        if not tile:
            return
        self.tile_set.ensure_assets()
        if not tile.frames:
            tile.frames = [tile.filename]
        if self.current_tile_frame_index >= len(tile.frames):
            self.current_tile_frame_index = 0
        path = self.tile_set.tile_image_path(tile, self.current_tile_frame_index)
        try:
            loaded = pygame.image.load(path).convert_alpha()
            if loaded.get_size() != config.NATIVE_SPRITE_RESOLUTION:
                loaded = pygame.transform.smoothscale(loaded, config.NATIVE_SPRITE_RESOLUTION)
            self.tile_canvas.frame.blit(loaded, (0, 0))
        except pygame.error as e:
            print(f"Error loading tile image {path}: {e}")

    def current_tile(self):
        if self.tile_set and 0 <= self.current_tile_index < len(self.tile_set.tiles):
            return self.tile_set.tiles[self.current_tile_index]
        return None

    def next_tile(self):
        if self.tile_set and self.tile_set.tiles:
            self.current_tile_index = (self.current_tile_index + 1) % len(self.tile_set.tiles)
            self.selected_tile_id = self.tile_set.tiles[self.current_tile_index].id
            self.current_tile_frame_index = 0
            self._load_current_tile_to_canvas()
            print(f"Selected tile: {self.selected_tile_id}")

    def previous_tile(self):
        if self.tile_set and self.tile_set.tiles:
            self.current_tile_index = (self.current_tile_index - 1) % len(self.tile_set.tiles)
            self.selected_tile_id = self.tile_set.tiles[self.current_tile_index].id
            self.current_tile_frame_index = 0
            self._load_current_tile_to_canvas()
            print(f"Selected tile: {self.selected_tile_id}")

    def next_tile_frame(self):
        tile = self.current_tile()
        if not tile or not tile.frames:
            return
        self.current_tile_frame_index = (self.current_tile_frame_index + 1) % len(tile.frames)
        self._load_current_tile_to_canvas()
        print(f"Tile '{tile.id}' frame {self.current_tile_frame_index + 1}/{len(tile.frames)}")

    def previous_tile_frame(self):
        tile = self.current_tile()
        if not tile or not tile.frames:
            return
        self.current_tile_frame_index = (self.current_tile_frame_index - 1) % len(tile.frames)
        self._load_current_tile_to_canvas()
        print(f"Tile '{tile.id}' frame {self.current_tile_frame_index + 1}/{len(tile.frames)}")

    def add_tile_frame(self):
        tile = self.current_tile()
        if not tile:
            print("No tile selected.")
            return
        if not tile.frames:
            tile.frames = [tile.filename]
        new_index = len(tile.frames) + 1
        new_frame_name = f"{tile.id}_f{new_index:02d}.png"
        tile.frames.append(new_frame_name)
        self.current_tile_frame_index = len(tile.frames) - 1
        self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
        self.save_tile()  # save blank frame
        self.tile_set.ensure_assets()
        self._refresh_tile_previews()
        print(f"Added frame {self.current_tile_frame_index + 1} to tile '{tile.id}'")

    # --- NPC Editing ---
    def current_npc(self):
        if self.tile_set and self.tile_set.npcs and self.selected_npc_id:
            for npc in self.tile_set.npcs:
                if npc.id == self.selected_npc_id:
                    return npc
        return self.tile_set.npcs[0] if self.tile_set and self.tile_set.npcs else None

    def _ensure_npc_state_angle(self, npc: NPCSprite):
        npc.states.setdefault(self.current_npc_state, {})
        npc.states[self.current_npc_state].setdefault(self.current_npc_angle, [f"{npc.id}_{self.current_npc_state}_{self.current_npc_angle}.png"])

    def _load_current_npc_frame(self):
        self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
        if not self.tile_set:
            return
        npc = self.current_npc()
        if not npc:
            return
        self._ensure_npc_state_angle(npc)
        frames = npc.states[self.current_npc_state][self.current_npc_angle]
        if not frames:
            frames.append(f"{npc.id}_{self.current_npc_state}_{self.current_npc_angle}.png")
        if self.current_npc_frame_index >= len(frames):
            self.current_npc_frame_index = 0
        path = self.tile_set.npc_image_path(npc, self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index)
        try:
            loaded = pygame.image.load(path).convert_alpha()
            if loaded.get_size() != config.NATIVE_SPRITE_RESOLUTION:
                loaded = pygame.transform.smoothscale(loaded, config.NATIVE_SPRITE_RESOLUTION)
            self.tile_canvas.frame.blit(loaded, (0, 0))
        except pygame.error as e:
            print(f"Error loading NPC frame {path}: {e}")

    def save_npc_frame(self):
        npc = self.current_npc()
        if not npc:
            print("No NPC selected.")
            return
        self._ensure_npc_state_angle(npc)
        frames = npc.states[self.current_npc_state][self.current_npc_angle]
        if not frames:
            frames.append(f"{npc.id}_{self.current_npc_state}_{self.current_npc_angle}.png")
        if self.current_npc_frame_index >= len(frames):
            self.current_npc_frame_index = 0
        path = self.tile_set.npc_image_path(npc, self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index)
        try:
            pygame.image.save(self.tile_canvas.frame, path)
            print(f"Saved NPC '{npc.id}' state {self.current_npc_state} angle {self.current_npc_angle} frame {self.current_npc_frame_index+1}")
        except pygame.error as e:
            print(f"Error saving NPC frame: {e}")

    def add_npc_frame(self):
        npc = self.current_npc()
        if not npc:
            print("No NPC selected.")
            return
        self._ensure_npc_state_angle(npc)
        frames = npc.states[self.current_npc_state][self.current_npc_angle]
        new_index = len(frames) + 1
        new_name = f"{npc.id}_{self.current_npc_state}_{self.current_npc_angle}_f{new_index:02d}.png"
        frames.append(new_name)
        self.current_npc_frame_index = len(frames) - 1
        self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
        self.save_npc_frame()
        print(f"Added NPC frame {self.current_npc_frame_index+1} for {npc.id}")

    def next_npc(self):
        if not self.tile_set or not self.tile_set.npcs:
            return
        ids = [n.id for n in self.tile_set.npcs]
        if self.selected_npc_id not in ids:
            self.selected_npc_id = ids[0]
        else:
            idx = ids.index(self.selected_npc_id)
            self.selected_npc_id = ids[(idx + 1) % len(ids)]
        self.current_npc_frame_index = 0
        self._load_current_npc_frame()
        print(f"Selected NPC: {self.selected_npc_id}")

    def previous_npc(self):
        if not self.tile_set or not self.tile_set.npcs:
            return
        ids = [n.id for n in self.tile_set.npcs]
        if self.selected_npc_id not in ids:
            self.selected_npc_id = ids[0]
        else:
            idx = ids.index(self.selected_npc_id)
            self.selected_npc_id = ids[(idx - 1) % len(ids)]
        self.current_npc_frame_index = 0
        self._load_current_npc_frame()
        print(f"Selected NPC: {self.selected_npc_id}")

    def next_npc_frame(self):
        npc = self.current_npc()
        if not npc:
            return
        frames = npc.states.get(self.current_npc_state, {}).get(self.current_npc_angle, [])
        if not frames:
            return
        self.current_npc_frame_index = (self.current_npc_frame_index + 1) % len(frames)
        self._load_current_npc_frame()

    def previous_npc_frame(self):
        npc = self.current_npc()
        if not npc:
            return
        frames = npc.states.get(self.current_npc_state, {}).get(self.current_npc_angle, [])
        if not frames:
            return
        self.current_npc_frame_index = (self.current_npc_frame_index - 1) % len(frames)
        self._load_current_npc_frame()

    def set_npc_state(self, state: str):
        if state not in NPC_STATES:
            return
        self.current_npc_state = state
        self.current_npc_frame_index = 0
        self._load_current_npc_frame()

    def set_npc_angle(self, angle: str):
        if angle not in NPC_ANGLES:
            return
        self.current_npc_angle = angle
        self.current_npc_frame_index = 0
        self._load_current_npc_frame()

    def start_new_npc_dialog(self):
        self.dialog_mode = 'input_text'
        self.dialog_prompt = "Enter new NPC ID:"
        count = len(self.tile_set.npcs) + 1 if self.tile_set else 1
        self.dialog_input_text = f"npc_{count:02d}"
        self.dialog_input_active = True
        self.dialog_options = [
            Button(pygame.Rect(0,0, 100, 40), "Create", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
            Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._create_npc_from_dialog

    def _create_npc_from_dialog(self, npc_id):
        if not npc_id:
            print("NPC creation cancelled.")
            return
        npc_id = npc_id.strip()
        if not npc_id:
            print("NPC id cannot be empty.")
            return
        if any(n.id == npc_id for n in self.tile_set.npcs):
            print(f"NPC '{npc_id}' already exists.")
            self.selected_npc_id = npc_id
            self.dialog_mode = None
            self.dialog_callback = None
            self.dialog_options = []
            return
        npc = NPCSprite(id=npc_id, name=npc_id, states={
            "standing": {
                "south": [f"{npc_id}_standing_south.png"]
            }
        })
        self.tile_set.add_or_update_npc(npc)
        self.tile_set.ensure_assets()
        self.selected_npc_id = npc_id
        self.current_npc_state = "standing"
        self.current_npc_angle = "south"
        self.current_npc_frame_index = 0
        self._load_current_npc_frame()
        self.buttons = self.create_buttons()
        self.dialog_mode = None
        self.dialog_callback = None
        self.dialog_options = []
        print(f"Created NPC '{npc_id}'")

    def _ensure_tile_preview(self, tile: TileDefinition):
        """Cache a small preview surface for the tile manager list."""
        if tile.id in self.tile_preview_cache:
            return
        self.tile_set.ensure_assets()
        preview_size = 48
        previews = []
        frames = tile.frames or [tile.filename]
        for idx in range(len(frames)):
            path = self.tile_set.tile_image_path(tile, idx)
            try:
                surf = pygame.image.load(path).convert_alpha()
            except pygame.error:
                surf = pygame.Surface((self.tile_set.tile_size, self.tile_set.tile_size), pygame.SRCALPHA)
                surf.fill((*config.RED, 255))
            previews.append(pygame.transform.scale(surf, (preview_size, preview_size)))
        self.tile_preview_cache[tile.id] = previews

    def _refresh_tile_previews(self):
        self.tile_preview_cache = {}
        if not self.tile_set:
            return
        for tile in self.tile_set.tiles:
            self._ensure_tile_preview(tile)

    def save_tileset(self):
        if not self.tile_set:
            print("No tileset loaded.")
            return
        path = self.tile_set.save()
        print(f"Saved tileset to {path}")

    def save_tile(self):
        tile = self.current_tile()
        if not tile:
            print("No tile selected to save.")
            return
        self.tile_set.ensure_assets()
        if not tile.frames:
            tile.frames = [tile.filename]
        if self.current_tile_frame_index >= len(tile.frames):
            self.current_tile_frame_index = 0
        path = self.tile_set.tile_image_path(tile, self.current_tile_frame_index)
        try:
            pygame.image.save(self.tile_canvas.frame, path)
            print(f"Saved tile '{tile.id}' to {path}")
            self._ensure_tile_preview(tile)
        except pygame.error as e:
            print(f"Error saving tile {tile.id}: {e}")

    def start_new_tile_dialog(self):
        """Prompt for a new tile id and create the tile."""
        self.dialog_mode = 'input_text'
        self.dialog_prompt = "Enter new tile ID:"
        next_id = len(self.tile_set.tiles) + 1 if self.tile_set else 1
        self.dialog_input_text = f"tile_{next_id:02d}"
        self.dialog_input_active = True
        self.dialog_options = [
            Button(pygame.Rect(0,0, 100, 40), "Create", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
            Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._create_tile_from_dialog

    def _create_tile_from_dialog(self, tile_id):
        if not tile_id:
            print("Tile creation cancelled.")
            return
        tile_id = tile_id.strip()
        if not tile_id:
            print("Tile id cannot be empty.")
            return
        if self.tile_set.get_tile(tile_id):
            print(f"Tile '{tile_id}' already exists. Selecting existing tile.")
            self.select_tile_by_id(tile_id)
            self.dialog_mode = None
            self.dialog_callback = None
            self.dialog_options = []
            return
        filename = f"{tile_id}.png"
        new_tile = TileDefinition(id=tile_id, name=tile_id, filename=filename, frames=[filename], properties={"walkable": True, "color": [200, 200, 200, 255]})
        self.tile_set.add_or_update_tile(new_tile)
        self.tile_set.ensure_assets()
        self.current_tile_index = len(self.tile_set.tiles) - 1
        self.selected_tile_id = new_tile.id
        self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
        self.save_tile() # Save blank tile so it exists on disk
        self._refresh_tile_previews()
        self.buttons = self.create_buttons()
        self.dialog_mode = None
        self.dialog_callback = None
        self.dialog_options = []
        print(f"Created new tile '{tile_id}'")

    def start_new_tileset_dialog(self):
        """Prompt for a new tileset id and initialize it."""
        self.dialog_mode = 'input_text'
        self.dialog_prompt = "Enter new tileset ID:"
        self.dialog_input_text = "tileset"
        self.dialog_input_active = True
        self.dialog_options = [
            Button(pygame.Rect(0,0, 100, 40), "Create", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
            Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._create_tileset_from_dialog

    def _create_tileset_from_dialog(self, tileset_id):
        if not tileset_id:
            print("Tileset creation cancelled.")
            return
        tileset_id = tileset_id.strip()
        if not tileset_id:
            print("Tileset id cannot be empty.")
            return
        self.tile_set = TileSet(tileset_id, tileset_id, config.OVERWORLD_TILE_SIZE)
        starter_tile = TileDefinition(id="tile_01", name="Tile 01", filename="tile_01.png", frames=["tile_01.png"], properties={"walkable": True, "color": [180, 180, 180, 255]})
        self.tile_set.add_or_update_tile(starter_tile)
        self.tile_set.ensure_assets()
        self.tile_set.save(os.path.join(config.TILESET_DIR, f"{tileset_id}.json"))
        self.current_tile_index = 0
        self.selected_tile_id = starter_tile.id
        self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
        self.save_tile()
        self._refresh_tile_previews()
        self.buttons = self.create_buttons()
        self.dialog_mode = None
        self.dialog_callback = None
        self.dialog_options = []
        print(f"Created new tileset '{tileset_id}'")

    def toggle_tile_walkable(self):
        tile = self.current_tile()
        if not tile:
            print("No tile selected.")
            return
        current = bool(tile.properties.get("walkable", True))
        tile.properties["walkable"] = not current
        state = "walkable" if tile.properties["walkable"] else "blocked"
        print(f"Tile '{tile.id}' marked as {state}.")

    def select_tile_by_id(self, tile_id):
        if not self.tile_set:
            return
        for idx, tile in enumerate(self.tile_set.tiles):
            if tile.id == tile_id:
                self.current_tile_index = idx
                self.selected_tile_id = tile_id
                self.current_tile_frame_index = 0
                self._load_current_tile_to_canvas()
                return

    def draw_tile_panel(self, surface):
        """Render the tile manager panel with previews."""
        if not self.tile_set:
            return
        panel = self.tile_panel_rect
        pygame.draw.rect(surface, config.GRAY_LIGHT, panel)
        pygame.draw.rect(surface, config.BLACK, panel, 1)
        header_font = pygame.font.Font(config.DEFAULT_FONT, 18)
        header = header_font.render(self.tile_set.name, True, config.BLACK)
        surface.blit(header, (panel.x + 8, panel.y + 6))

        start_y = panel.y + 30
        item_height = 60
        visible = max(1, panel.height // item_height - 1)
        total_tiles = len(self.tile_set.tiles)
        self.tile_list_scroll = max(0, min(self.tile_list_scroll, max(0, total_tiles - visible)))
        self.tile_button_rects = []

        for row, idx in enumerate(range(self.tile_list_scroll, min(total_tiles, self.tile_list_scroll + visible))):
            tile = self.tile_set.tiles[idx]
            self._ensure_tile_preview(tile)
            item_rect = pygame.Rect(panel.x + 8, start_y + row * item_height, panel.width - 16, item_height - 8)
            is_selected = tile.id == self.selected_tile_id
            pygame.draw.rect(surface, config.WHITE if is_selected else config.GRAY_MEDIUM, item_rect)
            pygame.draw.rect(surface, config.BLACK, item_rect, 1)
            previews = self.tile_preview_cache.get(tile.id, [])
            if previews:
                ticks = pygame.time.get_ticks()
                frame_idx = (ticks // max(1, tile.frame_duration_ms)) % len(previews)
                surface.blit(previews[frame_idx], (item_rect.x + 4, item_rect.y + 6))
            name_surf = self.font.render(tile.name, True, config.BLACK)
            id_text = tile.id
            if tile.properties.get("type"):
                id_text += f" ({tile.properties.get('type')})"
            id_surf = self.font.render(id_text, True, config.BLUE if is_selected else config.BLACK)
            surface.blit(name_surf, (item_rect.x + 60, item_rect.y + 8))
            surface.blit(id_surf, (item_rect.x + 60, item_rect.y + 30))
            self.tile_button_rects.append((item_rect, tile.id))

    def handle_tile_panel_click(self, pos):
        if not self.tile_set or not self.tile_panel_rect.collidepoint(pos):
            return False
        for rect, tile_id in self.tile_button_rects:
            if rect.collidepoint(pos):
                self.select_tile_by_id(tile_id)
                print(f"Selected tile: {tile_id}")
                return True
        # Handle simple scroll if clicked at top/bottom margins
        margin = 20
        if pos[1] < self.tile_panel_rect.y + margin and self.tile_list_scroll > 0:
            self.tile_list_scroll -= 1
            return True
        if pos[1] > self.tile_panel_rect.bottom - margin and self.tile_list_scroll < max(0, len(self.tile_set.tiles) - 1):
            self.tile_list_scroll += 1
            return True
        return False

    def draw_npc_panel(self, surface):
        """Render NPC list and basic info."""
        if not self.tile_set:
            return
        panel = self.tile_panel_rect
        pygame.draw.rect(surface, config.GRAY_LIGHT, panel)
        pygame.draw.rect(surface, config.BLACK, panel, 1)
        header_font = pygame.font.Font(config.DEFAULT_FONT, 18)
        header = header_font.render("NPC Sprites", True, config.BLACK)
        surface.blit(header, (panel.x + 8, panel.y + 6))

        start_y = panel.y + 30
        item_height = 60
        visible = max(1, panel.height // item_height - 1)
        total = len(self.tile_set.npcs)
        self.npc_list_scroll = max(0, min(self.npc_list_scroll, max(0, total - visible)))
        self.npc_button_rects = []

        for row, idx in enumerate(range(self.npc_list_scroll, min(total, self.npc_list_scroll + visible))):
            npc = self.tile_set.npcs[idx]
            item_rect = pygame.Rect(panel.x + 8, start_y + row * item_height, panel.width - 16, item_height - 8)
            is_selected = npc.id == self.selected_npc_id
            pygame.draw.rect(surface, config.WHITE if is_selected else config.GRAY_MEDIUM, item_rect)
            pygame.draw.rect(surface, config.BLACK, item_rect, 1)
            # preview: load first available frame
            preview = None
            for state_dict in npc.states.values():
                for angle_frames in state_dict.values():
                    if angle_frames:
                        path = self.tile_set.npc_image_path(npc, self.current_npc_state if self.current_npc_state in npc.states else list(npc.states.keys())[0],
                                                            self.current_npc_angle if self.current_npc_angle in state_dict else list(state_dict.keys())[0], 0)
                        try:
                            surf = pygame.image.load(path).convert_alpha()
                            preview = pygame.transform.scale(surf, (48, 48))
                        except pygame.error:
                            pass
                        break
                if preview:
                    break
            if preview:
                surface.blit(preview, (item_rect.x + 4, item_rect.y + 6))
            name_surf = self.font.render(npc.name, True, config.BLACK)
            id_surf = self.font.render(npc.id, True, config.BLUE if is_selected else config.BLACK)
            surface.blit(name_surf, (item_rect.x + 60, item_rect.y + 8))
            surface.blit(id_surf, (item_rect.x + 60, item_rect.y + 30))
            self.npc_button_rects.append((item_rect, npc.id))

    def handle_npc_panel_click(self, pos):
        if not self.tile_set or not self.tile_panel_rect.collidepoint(pos):
            return False
        for rect, npc_id in self.npc_button_rects:
            if rect.collidepoint(pos):
                self.selected_npc_id = npc_id
                self.current_npc_frame_index = 0
                self._load_current_npc_frame()
                print(f"Selected NPC: {npc_id}")
                return True
        margin = 20
        if pos[1] < self.tile_panel_rect.y + margin and self.npc_list_scroll > 0:
            self.npc_list_scroll -= 1
            return True
        if pos[1] > self.tile_panel_rect.bottom - margin and self.npc_list_scroll < max(0, len(self.tile_set.npcs) - 1):
            self.npc_list_scroll += 1
            return True
        return False

    def set_asset_edit_target(self, target: str):
        if target not in ['tile', 'npc']:
            return
        if self.asset_edit_target != target:
            self.asset_edit_target = target
            if target == 'tile':
                self._load_current_tile_to_canvas()
            else:
                if not self.selected_npc_id and self.tile_set and self.tile_set.npcs:
                    self.selected_npc_id = self.tile_set.npcs[0].id
                self._load_current_npc_frame()
            self.buttons = self.create_buttons()

    def _handle_dialog_choice(self, value):
        """Internal handler for dialog button values or direct calls."""
        # print(f"DEBUG: Start _handle_dialog_choice(value={repr(value)})") # DEBUG 1 - REMOVE
        callback_to_call = self.dialog_callback # Store before potential modification
        if callback_to_call:
            if value is None: # Cancel Path
                 print("Dialog action cancelled by user.")
                 self.dialog_mode = None
                 self.dialog_prompt = ""
                 self.dialog_options = []
                 # Set back to None
                 # if hasattr(self, 'dialog_callback'):
                 #     del self.dialog_callback 
                 self.dialog_callback = None # <<< REVERT TO THIS
                # Reset input-specific state too
                 self.dialog_input_text = ""
                 # ... rest of cancel path clearing ...
            else: # Value is not None (Confirm Path)
                 try:
                     # print(f"DEBUG: Before calling callback {getattr(callback_to_call, '__name__', 'unknown')}") # DEBUG 2 - REMOVE
                     callback_to_call(value)
                     # Callback handles its own state transitions now
                 except Exception as e:
                     print(f"ERROR during dialog callback {getattr(callback_to_call, '__name__', 'unknown')}: {e}")
                     # Clear dialog on error
                     self.dialog_mode = None
                     # ... clear other stuff ...
        # print(f"DEBUG: End _handle_dialog_choice. dialog_mode={self.dialog_mode}") # DEBUG 3 - REMOVE

    def refocus_pygame_window(self):
        """
        Refocus the Pygame window - REMOVED as Tkinter is gone.
        """
        # pygame.display.iconify() - REMOVED
        # pygame.display.set_mode((config.EDITOR_WIDTH, config.EDITOR_HEIGHT)) - REMOVED
        # print("Editor window refocused.") - REMOVED
        pass # No longer needed

    def create_buttons(self):
        """
        Create the buttons for the editor UI.

        This method creates the buttons for the editor UI based on the current
        edit mode. It returns a list of Button instances.

        Returns:
            list: A list of Button instances.
        """
        buttons = []
        button_width = 100
        button_height = 30
        padding = 5
        start_x = config.EDITOR_WIDTH - button_width - padding
        start_y = 50

        shared_buttons = [
            ("Clear", self.clear_current),
            ("Color Picker", self.open_color_picker),
            ("Eraser", self.toggle_eraser),
            ("Fill", self.toggle_fill),
            ("Select", self.toggle_selection_mode),
            ("Copy", self.copy_selection),
            ("Paste", self.paste_selection),
            ("Mirror", self.mirror_selection),
            ("Rotate", self.rotate_selection),
            ("Undo", self.undo),
            ("Redo", self.redo),
        ]

        mode_buttons = []
        if self.edit_mode == 'monster':
            mode_buttons = [
                ("Save Sprites", self.save_current_monster_sprites),
                ("Prev Monster", self.previous_monster),
                ("Next Monster", self.next_monster),
                ("Switch Sprite", self.switch_sprite),
                ("Load Ref Img", self.load_reference_image),
                ("Clear Ref Img", self.clear_reference_image),
            ]
        elif self.edit_mode == 'background':
            mode_buttons = [
                ("Save BG", self.save_background),
                ("Load BG", self.trigger_load_background_dialog),
                ("Zoom In", self.zoom_in),
                ("Zoom Out", self.zoom_out),
                ("Brush +", self.increase_brush_size),
                ("Brush -", self.decrease_brush_size),
                ("Prev BG", self.previous_background),
                ("Next BG", self.next_background),
                ("Pan Up", self.pan_up),
                ("Pan Down", self.pan_down),
                ("Pan Left", self.pan_left),
                ("Pan Right", self.pan_right),
            ]
        elif self.edit_mode == 'tile':
            switch_buttons = [
                ("Edit Tiles", lambda: self.set_asset_edit_target('tile')),
                ("Edit NPCs", lambda: self.set_asset_edit_target('npc')),
            ]
            if self.asset_edit_target == 'tile':
                mode_buttons = [
                    ("Save Tile", self.save_tile),
                    ("Save Tileset", self.save_tileset),
                    ("Load Tileset", self.trigger_load_tileset_dialog),
                    ("New Tile", self.start_new_tile_dialog),
                    ("New Tileset", self.start_new_tileset_dialog),
                    ("Toggle Walk", self.toggle_tile_walkable),
                    ("Brush +", self.increase_brush_size),
                    ("Brush -", self.decrease_brush_size),
                    ("Prev Tile", self.previous_tile),
                    ("Next Tile", self.next_tile),
                    ("Prev Frame", self.previous_tile_frame),
                    ("Next Frame", self.next_tile_frame),
                    ("Add Frame", self.add_tile_frame),
                ]
            else:
                mode_buttons = [
                    ("Save Tileset", self.save_tileset),
                    ("Save NPC", self.save_npc_frame),
                    ("Load Tileset", self.trigger_load_tileset_dialog),
                    ("New NPC", self.start_new_npc_dialog),
                    ("Prev NPC", self.previous_npc),
                    ("Next NPC", self.next_npc),
                    ("State Stand", lambda: self.set_npc_state("standing")),
                    ("State Walk", lambda: self.set_npc_state("walking")),
                    ("Angle S", lambda: self.set_npc_angle("south")),
                    ("Angle W", lambda: self.set_npc_angle("west")),
                    ("Angle E", lambda: self.set_npc_angle("east")),
                    ("Angle N", lambda: self.set_npc_angle("north")),
                    ("Prev Frame", self.previous_npc_frame),
                    ("Next Frame", self.next_npc_frame),
                    ("Add Frame", self.add_npc_frame),
                ]
            mode_buttons = switch_buttons + mode_buttons
        else:
            mode_buttons = [("Save", lambda: print("Save disabled."))]

        all_buttons = mode_buttons + shared_buttons

        for i, (text, action) in enumerate(all_buttons):
            rect = (start_x, start_y + i * (button_height + padding), button_width, button_height)
            buttons.append(Button(rect, text, action))

        return buttons

    def save_current_monster_sprites(self):
        """Saves both front and back sprites for the current monster."""
        try:
            # Ensure monsters list and index are valid
            if not hasattr(config, 'monsters') or not isinstance(config.monsters, list):
                print("Error: Monster data not loaded or invalid. Cannot save.")
                return
            if not (0 <= self.current_monster_index < len(config.monsters)):
                print(f"Error: current_monster_index {self.current_monster_index} out of range. Cannot save.")
                return

            monster_name = config.monsters[self.current_monster_index].get('name')
            if not monster_name:
                print(f"Error: Monster name not found at index {self.current_monster_index}. Cannot save.")
                return

            # Save both front and back sprites
            self.sprites['front'].save_sprite(monster_name)
            self.sprites['back'].save_sprite(monster_name)
            print(f"Saved sprites for {monster_name}")

        except Exception as e:
            print(f"An unexpected error occurred during save_current_monster_sprites: {e}")

    def clear_current(self):
        """Clears the currently active editing area (sprite or background)."""
        self.save_state() # Save state before clearing
        if self.edit_mode == 'monster':
            sprite = self.sprites.get(self.current_sprite)
            if sprite:
                sprite.frame.fill((*config.BLACK[:3], 0)) # Fill with transparent black
                print(f"Cleared {self.current_sprite} sprite.")
            else:
                print(f"Error: Could not find sprite editor for {self.current_sprite} to clear.")
        elif self.edit_mode == 'background':
            if self.current_background:
                # Assuming default background is white, fill with that
                # Or could use a different default clear color if needed
                self.current_background.fill((*config.WHITE, 255)) # Fill with opaque white
                print("Cleared current background.")
            else:
                print("Error: No current background loaded to clear.")
        elif self.edit_mode == 'tile':
            self.tile_canvas.frame.fill((*config.BLACK[:3], 0))
            print("Cleared current tile.")
        else:
            print(f"Warning: Unknown edit mode '{self.edit_mode}' for clear operation.")

    def toggle_eraser(self):
        """Toggle eraser mode (now handled by DrawTool state)."""
        # If already draw tool, just toggle erase_mode
        if self.tool_manager.active_tool_name == 'draw':
             self.eraser_mode = not self.eraser_mode
             print(f"Eraser mode: {self.eraser_mode}")
             # Ensure other potentially conflicting modes are off
             self.fill_mode = False 
             self.paste_mode = False
        else:
             # If switching from another tool, activate draw tool and set erase mode
             self.tool_manager.set_active_tool('draw')
             self.eraser_mode = True
             print(f"Eraser mode: {self.eraser_mode}")
        # No longer need to manage select mode here, set_active_tool does it

    def toggle_fill(self):
        """Activate fill tool."""
        # self.fill_mode = not self.fill_mode # OLD
        # self.eraser_mode = False # OLD
        # self.paste_mode = False # OLD
        # if self.mode == 'select': # OLD
        #     self.mode = 'draw' # OLD
        #     self.selection.selecting = False # OLD
        #     self.selection.active = False # OLD
        # print(f"Fill mode: {self.fill_mode}") # OLD
        self.tool_manager.set_active_tool('fill') # <<< NEW
        # We might need flags like self.fill_mode if FillTool needs them?
        # For now, assume activating the tool is sufficient.
        # ToolManager.set_active_tool handles turning off other flags.
        self.fill_mode = True # Keep flag for now until FillTool state is internal
        self.eraser_mode = False
        self.paste_mode = False

    def toggle_selection_mode(self):
        """Toggle selection mode."""
        # Selection is not yet a formal tool in ToolManager
        # Keep existing logic for now
        if self.mode == 'select':
            self.mode = 'draw'
            self.selection.selecting = False
            self.selection.active = False
            # Ensure draw tool is active when exiting select mode
            self.tool_manager.set_active_tool('draw') 
            print("Switched to Draw mode.")
        else:
            self.mode = 'select'
            self.selection.toggle() # Activate selection tool logic
            # Deactivate other tools implicitly by switching mode (handled by event handler checks)
            self.eraser_mode = False
            self.fill_mode = False
            self.paste_mode = False
            # Maybe explicitly deactivate the ToolManager's tool?
            if self.tool_manager.active_tool:
                 self.tool_manager.active_tool.deactivate(self)
            print("Switched to Select mode.")

    def copy_selection(self):
        """Copy the selected pixels to the buffer."""
        if self.mode == 'select' and self.selection.active:
            # Get the currently active sprite editor
            sprite_editor = self.get_active_canvas()
            if not sprite_editor:
                 print("Copy failed: Cannot find active sprite editor.")
                 return
                 
            # Pass the sprite_editor instance
            self.copy_buffer = self.selection.get_selected_pixels(sprite_editor)
            
            if self.copy_buffer:
                 print(f"Copied {len(self.copy_buffer)} pixels.")
            else:
                 print("Copy failed: No pixels selected or error getting pixels.")
        else:
            print("Copy failed: No active selection.")

    def paste_selection(self):
        """Activate paste mode with the buffered pixels."""
        if self.copy_buffer:
            # self.paste_mode = True # OLD
            # self.mode = 'draw' # Exit select mode implicitly # OLD
            # self.selection.active = False # OLD
            # self.eraser_mode = False # OLD
            # self.fill_mode = False # OLD
            # print("Paste mode activated. Click to place.") # OLD
            self.tool_manager.set_active_tool('paste') # <<< NEW
            # Keep flags for now until PasteTool state is internal?
            self.paste_mode = True 
            self.eraser_mode = False
            self.fill_mode = False
        else:
            print("Paste failed: Copy buffer is empty.")

    def mirror_selection(self):
        """Mirror the selected pixels horizontally in-place."""
        if self.mode != 'select' or not self.selection.active:
            print("Mirror failed: Make an active selection first.")
            return

        sprite_editor = self.get_active_canvas()
        if not sprite_editor:
            print("Mirror failed: Active sprite editor not found.")
            return

        self.save_state() # Save state before modifying
        selection_rect = self.selection.rect

        # Create a subsurface referencing the selected area (no copy needed yet)
        try:
             original_area = sprite_editor.frame.subsurface(selection_rect)
             mirrored_area = pygame.transform.flip(original_area, True, False) # Flip horizontal
        except ValueError as e:
             print(f"Error creating subsurface for mirroring: {e}")
             self.undo_stack.pop() # Remove the state we just saved
             return

        # ---> ADD THIS LINE: Clear the original area first <---
        sprite_editor.frame.fill((*config.BLACK[:3], 0), selection_rect)

        # Blit mirrored surface back onto the main frame
        sprite_editor.frame.blit(mirrored_area, selection_rect.topleft)
        print("Selection mirrored.")
        # Keep selection active

    def rotate_selection(self):
        """Rotate the selected pixels 90 degrees clockwise in-place."""
        if self.mode != 'select' or not self.selection.active:
            print("Rotate failed: Make an active selection first.")
            return

        sprite_editor = self.get_active_canvas()
        if not sprite_editor:
            print("Rotate failed: Active sprite editor not found.")
            return

        self.save_state() # Save state before modifying
        selection_rect = self.selection.rect

        # Create a subsurface and rotate it
        try:
            original_area = sprite_editor.frame.subsurface(selection_rect)
            # Rotating might change dimensions, so handle carefully
            rotated_area = pygame.transform.rotate(original_area, -90) # Clockwise
        except ValueError as e:
            print(f"Error creating subsurface for rotation (maybe 0 size?): {e}")
            return

        # Clear original area ONLY IF rotation doesn't change size AND it fits
        # A simpler approach for now: Overwrite with rotated, centered.
        # Clear original area first
        sprite_editor.frame.fill((*config.BLACK[:3], 0), selection_rect)

        # Blit rotated surface back, centered in the original rect bounds
        blit_pos = rotated_area.get_rect(center=selection_rect.center)
        sprite_editor.frame.blit(rotated_area, blit_pos)
        print("Selection rotated 90 degrees clockwise.")
        # Keep selection active, rect might be slightly off if not square

    def zoom_in(self):
        """Zoom in on the background canvas."""
        if self.edit_mode == 'background':
            # Increase zoom level, potentially up to a max limit
            self.editor_zoom *= 1.2 # Example: Increase by 20%
            max_zoom = 8.0 # Example maximum zoom
            self.editor_zoom = min(self.editor_zoom, max_zoom)
            print(f"Zoom In: Level {self.editor_zoom:.2f}x")
            # TODO: Adjust view offset based on mouse position
        else:
            print("Zoom only available in background mode.")

    def zoom_out(self):
        """Zoom out on the background canvas."""
        if self.edit_mode == 'background':
            # Decrease zoom level, potentially down to a min limit
            self.editor_zoom /= 1.2 # Example: Decrease by 20%
            min_zoom = 0.25 # Example minimum zoom
            self.editor_zoom = max(self.editor_zoom, min_zoom)
            print(f"Zoom Out: Level {self.editor_zoom:.2f}x")
            # TODO: Adjust view offset based on mouse position
        else:
             print("Zoom only available in background mode.")

    def increase_brush_size(self):
        """Increase brush size."""
        if self.brush_size < config.MAX_BRUSH_SIZE:
            self.brush_size += 1
            print(f"Brush size: {self.brush_size}")
        else:
             print("Max brush size reached.")

    def decrease_brush_size(self):
        """Decrease brush size."""
        if self.brush_size > 1:
            self.brush_size -= 1
            print(f"Brush size: {self.brush_size}")
        else:
             print("Min brush size reached.")

    def previous_background(self):
        """Switch to the previous background image."""
        if self.edit_mode == 'background' and self.backgrounds:
            if self.current_background_index > 0:
                self.current_background_index -= 1
                self.current_background = self.backgrounds[self.current_background_index][1].copy()
                self.undo_stack = [] # Reset undo/redo for new image
                self.redo_stack = []
                print(f"Switched to previous background: {self.backgrounds[self.current_background_index][0]}")
            else:
                print("Already at the first background.")
        else:
             print("Previous background only available in background mode with existing backgrounds.")

    def next_background(self):
        """Switch to the next background image."""
        if self.edit_mode == 'background' and self.backgrounds:
            if self.current_background_index < len(self.backgrounds) - 1:
                self.current_background_index += 1
                self.current_background = self.backgrounds[self.current_background_index][1].copy()
                self.undo_stack = [] # Reset undo/redo for new image
                self.redo_stack = []
                print(f"Switched to next background: {self.backgrounds[self.current_background_index][0]}")
            else:
                print("Already at the last background.")
        else:
             print("Next background only available in background mode with existing backgrounds.")

    def open_color_picker(self):
        """Open the system's native color picker dialog using Tkinter."""
        if not self._ensure_tkinter_root():
            # Message already printed by _ensure_tkinter_root
            return

        tk_root = self._ensure_tkinter_root()
        if not tk_root:
             return # Exit if root is still None

        # Convert current color to Tkinter format (hex string)
        initial_color_hex = "#{:02x}{:02x}{:02x}".format(*self.current_color[:3])

        # Open the dialog, passing the global root as parent
        try:
             # Use the fetched tk_root directly
             chosen_color = colorchooser.askcolor(parent=tk_root, color=initial_color_hex, title="Select Color")
        except tk.TclError as e:
             print(f"Error opening native color picker: {e}")
             chosen_color = None
        except Exception as e: # Catch other potential errors
             print(f"Unexpected error during color chooser: {e}")
             chosen_color = None

        # Bring Pygame window back to focus might be needed here too if dialog issues persist

        if chosen_color and chosen_color[1] is not None: 
            rgb, _ = chosen_color
            new_color_rgba = (int(rgb[0]), int(rgb[1]), int(rgb[2]), 255) # Add full alpha
            self.select_color(new_color_rgba)
            print(f"Color selected via native picker: {new_color_rgba}")
        else:
            print("Color selection cancelled or failed.")

    def _get_current_picker_color(self):
        # ... This method is now only relevant for a potential Pygame fallback ...
        pass

    def _color_picker_callback(self, color):
        # ... This method is now only relevant for a potential Pygame fallback ...
        pass

    def select_color(self, color):
        """
        Select a color from the palette.

        This method sets the currently selected color based on the provided color
        tuple. It also deactivates the eraser and fill modes.

        Args:
            color (tuple): The RGBA color tuple to select.
        """
        if color is not None:
            self.current_color = color
            self.eraser_mode = False # Keep? DrawTool uses this
            self.fill_mode = False   # Keep? FillTool might need later?
            self.paste_mode = False  # Explicitly set paste mode flag off
            
            # Switch back to draw tool if another tool was active
            if self.tool_manager.active_tool_name != 'draw':
                self.tool_manager.set_active_tool('draw')
            
            # Also ensure selection mode is off
            if self.mode == 'select':
                self.mode = 'draw' # Already handled by set_active_tool if needed
                self.selection.selecting = False
                self.selection.active = False
            print(f"Selected color: {color}")

    def load_backgrounds(self):
        """
        Load available background images from the 'backgrounds' directory.

        This method scans the 'backgrounds' directory for PNG files and attempts
        to load them as background images. It returns a list of tuples, where each
        tuple contains the filename and the corresponding Pygame Surface.

        Returns:
            list: A list of tuples, each containing a filename and a Pygame Surface.
        """
        backgrounds = []
        # config should ensure BACKGROUND_DIR exists
        # if not os.path.exists(config.BACKGROUND_DIR):
        #     os.makedirs(config.BACKGROUND_DIR)
        for filename in os.listdir(config.BACKGROUND_DIR):
            if filename.endswith('.png'):
                path = os.path.join(config.BACKGROUND_DIR, filename)
                try:
                    bg = pygame.image.load(path).convert_alpha()
                    backgrounds.append((filename, bg))
                except pygame.error as e:
                    print(f"Failed to load background {filename}: {e}")
        return backgrounds

    def show_edit_mode_dialog(self):
        """
        Display a dialog to choose the editing mode - REMOVED / Replaced by dialog state.
        """
        # REMOVED Tkinter dialog code
        print("DEBUG: show_edit_mode_dialog was called but is replaced by dialog state.")
        return "monster" # Return default, logic moved to choose_edit_mode

    def show_background_action_dialog(self):
        """
        Display a dialog to choose the background action - REMOVED / Replaced by dialog state.
        """
        # REMOVED Tkinter dialog code
        print("DEBUG: show_background_action_dialog was called but is replaced by dialog state.")
        return "new" # Return default, logic moved to choose_background_action

    def choose_background_action(self):
        """
        Handle background-specific actions (new or edit) using dialog state.
        """
        # print(f"DEBUG: Start choose_background_action()") # DEBUG 7 - REMOVE
        if not self.backgrounds:
            print("No existing backgrounds. Creating a new one.")
            # print(f"DEBUG: Before calling create_new_background()") # DEBUG 8 - REMOVE
            self.create_new_background()
        else:
            self.dialog_mode = 'choose_bg_action'
            self.dialog_prompt = "Choose Background Action:"
            # --- Calculate positions --- Needed if creating buttons here
            dialog_center_x = config.EDITOR_WIDTH // 2
            dialog_center_y = config.EDITOR_HEIGHT // 2
            button_width = 150
            button_height = 40
            button_padding = 10
            new_button_y = dialog_center_y - button_height - button_padding // 2
            edit_button_y = dialog_center_y + button_padding // 2
            button_x = dialog_center_x - button_width // 2
            # --- UNCOMMENT AND SETUP DIALOG OPTIONS --- 
            self.dialog_options = [
                Button(pygame.Rect(button_x, new_button_y, button_width, button_height), "New", value="new"),
                Button(pygame.Rect(button_x, edit_button_y, button_width, button_height), "Edit Existing", value="edit")
            ]
            self.dialog_callback = self._handle_background_action_choice
        # print(f"DEBUG: End choose_background_action. dialog_mode={self.dialog_mode}") # DEBUG 9 - REMOVE

    def _handle_background_action_choice(self, action):
        """Callback after choosing background action."""
        print(f"Background action chosen: {action}")
        if action == 'new':
            self.create_new_background() # This sets dialog_mode = 'input_text'
            # Don't clear dialog state here, let the next step handle it
        elif action == 'edit' and self.backgrounds:
            self.current_background_index = 0
            self.current_background = self.backgrounds[self.current_background_index][1].copy()
            print(f"Editing background: {self.backgrounds[self.current_background_index][0]}")
            self.buttons = self.create_buttons() # Recreate buttons for the correct mode
            # --- ADD CLEARING LOGIC FOR EDIT BACKGROUND --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Invalid action or no backgrounds to edit. Creating new.")
            self.create_new_background() # This sets dialog_mode = 'input_text'
            # Don't clear dialog state here

    def create_new_background(self):
        """
        Create a new background image.
        """
        # print(f"DEBUG: Start create_new_background()") # DEBUG 10 - REMOVE
        self.dialog_mode = 'input_text'
        # print(f"DEBUG: Set dialog_mode='{self.dialog_mode}' in create_new_background") # DEBUG 11 - REMOVE
        self.dialog_prompt = "Enter filename for new background (.png):"
        self.dialog_input_text = "new_background.png" # Default text
        self.dialog_input_active = True
        self.dialog_options = [
            Button(pygame.Rect(0,0, 100, 40), "Save", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
            Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._create_new_background_callback
        # print(f"DEBUG: End create_new_background. dialog_mode={self.dialog_mode}") # DEBUG 12 - REMOVE

    def _create_new_background_callback(self, filename):
        """Callback after getting filename for new background."""
        # We don't clear dialog state here immediately, as _handle_dialog_choice handles cancel
        if filename:
            if not filename.endswith('.png'):
                filename += '.png'
            # Ensure filename is just the base name, save to BACKGROUND_DIR
            base_filename = os.path.basename(filename)
            full_path = os.path.join(config.BACKGROUND_DIR, base_filename)

            self.current_background = pygame.Surface((config.DEFAULT_BACKGROUND_WIDTH, config.DEFAULT_BACKGROUND_HEIGHT), pygame.SRCALPHA)
            self.current_background.fill((*config.WHITE, 255))  # Set to white with full opacity
            try:
                pygame.image.save(self.current_background, full_path)
                print(f"Saved background as {full_path}")
            except pygame.error as e:
                 print(f"Error saving new background {full_path}: {e}")
                 # Handle error, maybe show message? For now, just print.

            # Reload backgrounds to include the new one
            self.backgrounds = self.load_backgrounds()
            self.current_background_index = next(
                (i for i, (name, _) in enumerate(self.backgrounds) if name == base_filename),
                -1 # Should find it if save succeeded
            )
            # Ensure buttons are created/updated for the correct mode
            self.buttons = self.create_buttons()
            # --- ADD CLEARING LOGIC ON SUCCESS --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("New background creation cancelled.")
            # If cancellation happened during initial setup, decide what to do.
            # Maybe default to the first existing background or quit?
            # For now, just print. If edit_mode wasn't fully set, it might be unstable.
            if self.edit_mode == 'background' and self.current_background_index == -1:
                 print("Warning: No background loaded after cancellation.")
                 # Optionally load a default or the first available one
                 if self.backgrounds:
                      self.current_background_index = 0
                      self.current_background = self.backgrounds[0][1].copy()
                      self.buttons = self.create_buttons()
                 else:
                      # Handle case with absolutely no backgrounds - maybe quit or show error message
                      pass

    def save_background(self, filename=None):
        """
        Save the current background image.
        Uses Pygame input dialog if no filename provided or saving new.
        """
        current_filename = None
        # Corrected Indentation:
        if self.current_background_index >= 0 and self.backgrounds:
            current_filename = self.backgrounds[self.current_background_index][0]

        if not filename:
            # Use current filename if available, otherwise prompt
            filename_to_save = current_filename
            if not filename_to_save:
                 # Trigger input dialog for saving a potentially new file
                 self.dialog_mode = 'input_text'
                 self.dialog_prompt = "Enter filename to save background (.png):"
                 self.dialog_input_text = "background.png"
                 self.dialog_input_active = True
                 self.dialog_options = [
                     Button(pygame.Rect(0,0, 100, 40), "Save", action=lambda: self._handle_dialog_choice(self.dialog_input_text)),
                     Button(pygame.Rect(0,0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
                 ]
                 self.dialog_callback = self._save_background_callback
                 return # Exit function, wait for dialog callback
            else:
                 # If we have a current filename, save directly without dialog
                 self._save_background_callback(filename_to_save)
        else:
             # If a specific filename is passed (e.g., for "Save As"), use it
             # This might also need a dialog in a full implementation, but for now save directly
             print(f"Warning: Direct saving to specified filename '{filename}' without dialog.")
             self._save_background_callback(filename)

    def _save_background_callback(self, filename):
        """Callback after getting filename for saving background."""
        # We don't clear dialog state here immediately
        if filename:
            if not filename.endswith('.png'):
                filename += '.png'
            # Ensure filename is just the base name, save to BACKGROUND_DIR
            base_filename = os.path.basename(filename)
            full_path = os.path.join(config.BACKGROUND_DIR, base_filename)
            try:
                 pygame.image.save(self.current_background, full_path)
                 print(f"Saved background as {full_path}")
            except pygame.error as e:
                 print(f"Error saving background {full_path}: {e}")
                 return # Don't update index if save failed
                 
            # Reload and find index only after successful save
            self.backgrounds = self.load_backgrounds()
            self.current_background_index = next(
                (i for i, (name, _) in enumerate(self.backgrounds) if name == base_filename),
                -1 # Should be found
            )
            # Update buttons if needed (though likely already correct)
            self.buttons = self.create_buttons()
            # --- ADD CLEARING LOGIC ON SUCCESS --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Background save cancelled.")

    def load_monster(self):
        """
        Load the current monster's sprites.

        This method loads the sprites for the currently selected monster. It updates
        the sprite frames and prints a status message.
        """
        try:
            # Ensure monsters list and index are valid
            if not hasattr(config, 'monsters') or not isinstance(config.monsters, list):
                print("Error: Monster data not loaded or invalid.")
                return
            if not (0 <= self.current_monster_index < len(config.monsters)):
                print(f"Error: current_monster_index {self.current_monster_index} out of range.")
                return

            monster_name = config.monsters[self.current_monster_index]['name']
            # Corrected Indentation:
            for sprite in self.sprites.values():
                sprite.load_sprite(monster_name) # Pass monster_name here
            print(f"Loaded monster: {monster_name}")
        except KeyError:
             print(f"Error: Monster data missing 'name' key at index {self.current_monster_index}.")
        except Exception as e:
             print(f"An unexpected error occurred during load_monster: {e}")

    def switch_sprite(self):
        """
        Switch between the front and back sprites.

        This method toggles between the front and back sprites for the current
        monster. It updates the current sprite and deactivates the selection.
        """
        self.current_sprite = 'back' if self.current_sprite == 'front' else 'front'
        print(f"Switched to sprite: {self.current_sprite}")
        self.selection.active = False  # Deactivate selection on sprite switch

    def previous_monster(self):
        """
        Switch to the previous monster in the list.

        This method decrements the current monster index and loads the previous
        monster's sprites. It prints a status message.
        """
        if self.current_monster_index > 0:
            self.current_monster_index -= 1
            self.load_monster()
            print(f"Switched to previous monster: {config.monsters[self.current_monster_index]['name']}")
        else:
            print("Already at the first monster.")

    def next_monster(self):
        """
        Switch to the next monster in the list.

        This method increments the current monster index and loads the next
        monster's sprites. It prints a status message.
        """
        # Ensure monsters list is loaded and valid
        if not hasattr(config, 'monsters') or not isinstance(config.monsters, list):
            print("Error: Monster data not loaded or invalid. Cannot switch.")
            return
        
        if self.current_monster_index < len(config.monsters) - 1:
            self.current_monster_index += 1
            self.load_monster()
            print(f"Switched to next monster: {config.monsters[self.current_monster_index].get('name', 'Unknown')}")
        else:
            print("Already at the last monster.")

    def _get_background_files(self):
        """Helper to get list of .png files in background directory."""
        try:
            return [f for f in os.listdir(config.BACKGROUND_DIR) if f.endswith('.png')]
        except FileNotFoundError:
            print(f"Warning: Background directory {config.BACKGROUND_DIR} not found.")
            return []

    def _get_reference_files(self, directory):
        """Helper to get image files from a directory."""
        image_exts = ('.png', '.jpg', '.jpeg', '.bmp', '.gif')
        file_paths = []
        try:
            for name in os.listdir(directory):
                path = os.path.join(directory, name)
                if os.path.isfile(path) and name.lower().endswith(image_exts):
                    file_paths.append(path)
        except FileNotFoundError:
            return []
        return file_paths

    def _set_dialog_directory(self, directory):
        """Update dialog list to show images from the given directory."""
        if not directory:
            return
        self.dialog_current_dir = directory
        files = self._get_reference_files(directory)
        if self.dialog_sort_recent:
            files.sort(key=lambda p: os.path.getmtime(p), reverse=True)
        else:
            files.sort(key=lambda p: os.path.basename(p).lower())
        self.dialog_file_list = files
        self.dialog_file_labels = [os.path.basename(path) for path in files]
        self.dialog_file_scroll_offset = 0
        self.dialog_selected_file_index = 0 if files else -1

    def _update_scrollbar_from_offset(self):
        if not self.dialog_file_scrollbar_rect:
            return
        total = len(self.dialog_file_list)
        visible = max(1, self.dialog_file_page_size)
        if total <= visible:
            self.dialog_file_scroll_thumb_rect = pygame.Rect(
                self.dialog_file_scrollbar_rect.x,
                self.dialog_file_scrollbar_rect.y,
                self.dialog_file_scrollbar_rect.width,
                self.dialog_file_scrollbar_rect.height,
            )
            return
        ratio = visible / total
        thumb_height = max(20, int(self.dialog_file_scrollbar_rect.height * ratio))
        max_offset = total - visible
        top = self.dialog_file_scrollbar_rect.y
        if max_offset > 0:
            top += int((self.dialog_file_scroll_offset / max_offset) * (self.dialog_file_scrollbar_rect.height - thumb_height))
        self.dialog_file_scroll_thumb_rect = pygame.Rect(
            self.dialog_file_scrollbar_rect.x,
            top,
            self.dialog_file_scrollbar_rect.width,
            thumb_height,
        )

    def _set_scroll_offset_from_thumb(self, thumb_center_y):
        total = len(self.dialog_file_list)
        visible = max(1, self.dialog_file_page_size)
        if total <= visible or not self.dialog_file_scrollbar_rect:
            return
        max_offset = total - visible
        track_height = self.dialog_file_scrollbar_rect.height
        thumb_height = self.dialog_file_scroll_thumb_rect.height if self.dialog_file_scroll_thumb_rect else 20
        usable = max(1, track_height - thumb_height)
        relative = thumb_center_y - self.dialog_file_scrollbar_rect.y - (thumb_height // 2)
        relative = max(0, min(relative, usable))
        self.dialog_file_scroll_offset = int(round((relative / usable) * max_offset))

    def _ensure_dialog_scroll(self):
        """Keep selected file in view when using file list dialogs."""
        if self.dialog_file_page_size <= 0:
            return
        if self.dialog_selected_file_index < self.dialog_file_scroll_offset:
            self.dialog_file_scroll_offset = self.dialog_selected_file_index
        elif self.dialog_selected_file_index >= self.dialog_file_scroll_offset + self.dialog_file_page_size:
            self.dialog_file_scroll_offset = self.dialog_selected_file_index - self.dialog_file_page_size + 1

    def trigger_load_tileset_dialog(self):
        """Initiates the dialog for loading a tileset file."""
        if self.edit_mode != 'tile':
            print("Tileset loading only available in tile edit mode.")
            return

        self.dialog_mode = 'load_tileset'
        self.dialog_prompt = "Select Tileset to Load:"
        self.dialog_file_list = list_tileset_files()
        self.dialog_file_scroll_offset = 0
        self.dialog_selected_file_index = -1
        self.dialog_file_labels = [os.path.basename(path) for path in self.dialog_file_list]
        self.dialog_quick_dirs = []
        self.dialog_quick_dir_rects = []

        self.dialog_options = [
            Button(pygame.Rect(0, 0, 100, 40), "Load", action=lambda: self._handle_dialog_choice(
                self.dialog_file_list[self.dialog_selected_file_index] if 0 <= self.dialog_selected_file_index < len(self.dialog_file_list) else None
            )),
            Button(pygame.Rect(0, 0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._load_selected_tileset_callback

    def trigger_load_background_dialog(self):
        """Initiates the dialog for loading a background file."""
        # Ensure we are in background mode, otherwise this button shouldn't be active/visible
        if self.edit_mode != 'background':
            print("Load background only available in background edit mode.")
            return

        self.dialog_mode = 'load_bg'
        self.dialog_prompt = "Select Background to Load:"
        self.dialog_file_list = self._get_background_files() # Get the list of files
        self.dialog_file_scroll_offset = 0
        self.dialog_selected_file_index = -1
        self.dialog_file_labels = list(self.dialog_file_list)
        self.dialog_quick_dirs = []
        self.dialog_quick_dir_rects = []

        # Define buttons for the dialog (Load and Cancel)
        # Actions will call _handle_dialog_choice with filename or None
        self.dialog_options = [
            # Buttons are positioned dynamically in draw_dialog
            Button(pygame.Rect(0, 0, 100, 40), "Load", action=lambda: self._handle_dialog_choice(
                self.dialog_file_list[self.dialog_selected_file_index] if 0 <= self.dialog_selected_file_index < len(self.dialog_file_list) else None
            )),
            Button(pygame.Rect(0, 0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._load_selected_background_callback

    def trigger_load_reference_dialog(self):
        """Initiates the dialog for loading a reference image."""
        if self.edit_mode != 'monster':
            print("Reference images only available in monster edit mode.")
            return

        self.dialog_mode = 'load_ref'
        self.dialog_prompt = "Select Reference Image:"
        self.dialog_file_scroll_offset = 0
        self.dialog_selected_file_index = -1
        self.dialog_sort_recent = True
        self.dialog_quick_dirs = []
        home_dir = os.path.expanduser("~")
        desktop_dir = os.path.join(home_dir, "Desktop")
        downloads_dir = os.path.join(home_dir, "Downloads")
        for label, path in [
            ("Desktop", desktop_dir),
            ("Downloads", downloads_dir),
            ("References", config.REFERENCE_IMAGE_DIR),
            ("Sprites", config.SPRITE_DIR),
            ("Backgrounds", config.BACKGROUND_DIR),
        ]:
            if os.path.isdir(path):
                self.dialog_quick_dirs.append((label, path))

        default_dir = config.REFERENCE_IMAGE_DIR
        if not os.path.isdir(default_dir) and self.dialog_quick_dirs:
            default_dir = self.dialog_quick_dirs[0][1]
        self._set_dialog_directory(default_dir)

        self.dialog_options = [
            Button(pygame.Rect(0, 0, 100, 40), "Load", action=lambda: self._handle_dialog_choice(
                self.dialog_file_list[self.dialog_selected_file_index] if 0 <= self.dialog_selected_file_index < len(self.dialog_file_list) else None
            )),
            Button(pygame.Rect(0, 0, 100, 40), "Cancel", action=lambda: self._handle_dialog_choice(None))
        ]
        self.dialog_callback = self._load_selected_reference_callback

    def _load_selected_reference_callback(self, file_path):
        """Callback after selecting a reference file to load."""
        if file_path:
            if not os.path.exists(file_path):
                print(f"Error: Reference file {file_path} not found.")
                return
            try:
                self.reference_image = pygame.image.load(file_path).convert_alpha()
                self.reference_image_path = file_path
                print(f"Loaded reference image: {file_path}")
                self._scale_reference_image()
                self.apply_reference_alpha()
            except pygame.error as e:
                print(f"Error loading reference image {file_path}: {e}")
                self.reference_image = None
                self.reference_image_path = None
                self.scaled_reference_image = None
            except Exception as e:
                print(f"An unexpected error occurred during reference image loading: {e}")
                self.reference_image = None
                self.reference_image_path = None
                self.scaled_reference_image = None
            self.dialog_mode = None
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Reference image load cancelled.")

    def _load_selected_tileset_callback(self, filename_or_path):
        """Callback after selecting a tileset file to load."""
        if filename_or_path:
            path = filename_or_path
            if not os.path.isabs(path):
                path = os.path.join(config.TILESET_DIR, filename_or_path)
            if not os.path.exists(path):
                print(f"Tileset file {path} not found.")
            else:
                self.load_tileset(path)
                self.buttons = self.create_buttons()
            self.dialog_mode = None
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Tileset load cancelled.")

    def _load_selected_background_callback(self, filename):
        """Callback after selecting a background file to load."""
        # We don't clear dialog state here immediately
        if filename:
            full_path = os.path.join(config.BACKGROUND_DIR, filename)
            try:
                loaded_bg = pygame.image.load(full_path).convert_alpha()
                # Find the index in the self.backgrounds list (which contains Surfaces)
                found_index = -1
                for i, (name, _) in enumerate(self.backgrounds):
                    if name == filename:
                        found_index = i
                        break
                
                if found_index != -1:
                    self.current_background_index = found_index
                    self.current_background = self.backgrounds[found_index][1].copy() # Load from pre-loaded list
                    print(f"Loaded background: {filename}")
                else:
                    # If not found in pre-loaded list (shouldn't happen if list is up-to-date)
                    # Load it directly and add it (or maybe just load directly?)
                    self.current_background = loaded_bg
                    # Add to list if desired, or just use the directly loaded one
                    # For simplicity, let's just use the loaded one and reset index
                    self.backgrounds.append((filename, loaded_bg))
                    self.current_background_index = len(self.backgrounds) - 1
                    print(f"Loaded background {filename} directly.")
                
                # Reset undo/redo for the new background
                self.undo_stack = []
                self.redo_stack = []
                # Potentially save initial state for undo here if desired

            except pygame.error as e:
                print(f"Error loading background {full_path}: {e}")
            except FileNotFoundError:
                print(f"Error: Background file {full_path} not found.")
            # --- ADD CLEARING LOGIC ON SUCCESS --- 
            self.dialog_mode = None 
            self.dialog_prompt = ""
            self.dialog_options = []
            self.dialog_callback = None
        else:
            print("Background load cancelled.")

    def save_state(self):
        """Save the current state of the active canvas to the undo stack."""
        # Limit stack size if desired (optional)
        # if len(self.undo_stack) > MAX_UNDO_STEPS:
        #     self.undo_stack.pop(0)

        current_state = None
        if self.edit_mode == 'monster':
            sprite = self.sprites.get(self.current_sprite)
            if sprite:
                # Store a copy of the frame and which sprite it belongs to
                current_state = ('monster', self.current_sprite, sprite.frame.copy())
        elif self.edit_mode == 'background':
            if self.current_background:
                current_state = ('background', self.current_background_index, self.current_background.copy())
        elif self.edit_mode == 'tile':
            if self.asset_edit_target == 'tile' and self.current_tile():
                current_state = ('tile', self.current_tile().id, self.tile_canvas.frame.copy(), self.current_tile_frame_index)
            elif self.asset_edit_target == 'npc' and self.current_npc():
                current_state = ('npc', self.current_npc().id, self.tile_canvas.frame.copy(), (self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index))

        if current_state:
            self.undo_stack.append(current_state)
            self.redo_stack.clear() # Clear redo stack on new action
            # print(f"State saved. Undo stack size: {len(self.undo_stack)}") # Debug
        # else: # Debug
            # print("Save state failed: No valid state to save.")

    def undo(self):
        """Revert to the previous state from the undo stack."""
        if not self.undo_stack:
            print("Nothing to undo.")
            return

        # Get the state to restore
        state_to_restore = self.undo_stack.pop()
        if len(state_to_restore) == 4:
            state_type, state_id, state_surface, state_meta = state_to_restore
        else:
            state_type, state_id, state_surface = state_to_restore
            state_meta = None

        # Save current state to redo stack BEFORE restoring
        current_state_for_redo = None
        if self.edit_mode == 'monster':
            sprite = self.sprites.get(self.current_sprite)
            if sprite:
                 current_state_for_redo = ('monster', self.current_sprite, sprite.frame.copy())
        elif self.edit_mode == 'background':
             if self.current_background:
                  current_state_for_redo = ('background', self.current_background_index, self.current_background.copy())
        elif self.edit_mode == 'tile':
             if self.asset_edit_target == 'tile' and self.current_tile():
                  current_state_for_redo = ('tile', self.current_tile().id, self.tile_canvas.frame.copy(), self.current_tile_frame_index)
             elif self.asset_edit_target == 'npc' and self.current_npc():
                  current_state_for_redo = ('npc', self.current_npc().id, self.tile_canvas.frame.copy(), (self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index))
        
        if current_state_for_redo:
             self.redo_stack.append(current_state_for_redo)

        # Restore the popped state
        if state_type == 'monster':
            sprite = self.sprites.get(state_id)
            if sprite:
                sprite.frame = state_surface.copy() # Use copy to avoid issues
                # Ensure the editor is focused on the restored sprite if it changed
                self.current_sprite = state_id 
                self.edit_mode = 'monster' # Ensure mode is correct
                print(f"Undid action for sprite: {state_id}")
            else: # Corrected indent for this else
                 print(f"Undo failed: Could not find sprite editor '{state_id}' to restore state.")
                 # Put the state back on the undo stack? Or discard?
                 self.undo_stack.append(state_to_restore) # Re-add for now
                 # Check if redo_stack is not empty before popping
                 if self.redo_stack: self.redo_stack.pop() # Remove the state we just added
        elif state_type == 'background':
            self.current_background = state_surface.copy() # Use copy
            self.current_background_index = state_id # Restore index too
            self.edit_mode = 'background' # Ensure mode is correct
            print(f"Undid action for background index: {state_id}")
        elif state_type == 'tile':
            self.edit_mode = 'tile'
            self.asset_edit_target = 'tile'
            self.tile_canvas.frame = state_surface.copy()
            if self.tile_set:
                self.select_tile_by_id(state_id)
            if state_meta is not None:
                self.current_tile_frame_index = state_meta
            print(f"Undid action for tile: {state_id}")
        elif state_type == 'npc':
            self.edit_mode = 'tile'
            self.asset_edit_target = 'npc'
            self.selected_npc_id = state_id
            if state_meta:
                self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index = state_meta
            self.tile_canvas.frame = state_surface.copy()
            print(f"Undid action for npc: {state_id}")
        else:
            print("Undo failed: Unknown state type in stack.")
            self.undo_stack.append(state_to_restore) # Re-add
            if self.redo_stack: self.redo_stack.pop() # Remove corresponding redo

        # Update buttons if mode changed
        self.buttons = self.create_buttons()

    def redo(self):
        """Reapply the last undone action from the redo stack."""
        if not self.redo_stack:
            print("Nothing to redo.")
            return

        # Get the state to restore from redo stack
        state_to_restore = self.redo_stack.pop()
        if len(state_to_restore) == 4:
            state_type, state_id, state_surface, state_meta = state_to_restore
        else:
            state_type, state_id, state_surface = state_to_restore
            state_meta = None

        # Save current state to undo stack BEFORE restoring
        current_state_for_undo = None
        if self.edit_mode == 'monster':
             sprite = self.sprites.get(self.current_sprite)
             if sprite:
                  current_state_for_undo = ('monster', self.current_sprite, sprite.frame.copy())
        elif self.edit_mode == 'background':
             if self.current_background:
                  current_state_for_undo = ('background', self.current_background_index, self.current_background.copy())
        elif self.edit_mode == 'tile':
             if self.asset_edit_target == 'tile' and self.current_tile():
                  current_state_for_undo = ('tile', self.current_tile().id, self.tile_canvas.frame.copy(), self.current_tile_frame_index)
             elif self.asset_edit_target == 'npc' and self.current_npc():
                  current_state_for_undo = ('npc', self.current_npc().id, self.tile_canvas.frame.copy(), (self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index))

        if current_state_for_undo:
             self.undo_stack.append(current_state_for_undo)

        # Restore the popped state from redo stack
        if state_type == 'monster':
            sprite = self.sprites.get(state_id)
            if sprite:
                sprite.frame = state_surface.copy()
                self.current_sprite = state_id
                self.edit_mode = 'monster'
                print(f"Redid action for sprite: {state_id}")
            else:
                 print(f"Redo failed: Could not find sprite editor '{state_id}' to restore state.")
                 self.redo_stack.append(state_to_restore) # Re-add
                 self.undo_stack.pop() # Remove corresponding undo
        elif state_type == 'background':
            self.current_background = state_surface.copy()
            self.current_background_index = state_id
            self.edit_mode = 'background'
            print(f"Redid action for background index: {state_id}")
        elif state_type == 'tile':
            self.edit_mode = 'tile'
            self.asset_edit_target = 'tile'
            self.tile_canvas.frame = state_surface.copy()
            if self.tile_set:
                self.select_tile_by_id(state_id)
            if state_meta is not None:
                self.current_tile_frame_index = state_meta
            print(f"Redid action for tile: {state_id}")
        elif state_type == 'npc':
            self.edit_mode = 'tile'
            self.asset_edit_target = 'npc'
            self.selected_npc_id = state_id
            if state_meta:
                self.current_npc_state, self.current_npc_angle, self.current_npc_frame_index = state_meta
            self.tile_canvas.frame = state_surface.copy()
            print(f"Redid action for npc: {state_id}")
        else:
            print("Redo failed: Unknown state type in stack.")
            self.redo_stack.append(state_to_restore) # Re-add
            if self.undo_stack: self.undo_stack.pop() # Remove corresponding undo

        # Update buttons if mode changed
        self.buttons = self.create_buttons()

    def get_active_canvas(self):
        """Return the active sprite-like editor for the current mode."""
        if self.edit_mode == 'monster':
            return self.sprites.get(self.current_sprite)
        if self.edit_mode == 'tile':
            return self.tile_canvas
        return None

    def _get_sprite_editor_at_pos(self, pos):
        """Return the SpriteEditor instance at the given screen position, or None."""
        if self.edit_mode == 'monster':
            for name, sprite_editor in self.sprites.items():
                editor_rect = pygame.Rect(sprite_editor.position, (sprite_editor.display_width, sprite_editor.display_height))
                if editor_rect.collidepoint(pos):
                    return sprite_editor
        elif self.edit_mode == 'tile':
            editor_rect = pygame.Rect(self.tile_canvas.position, (self.tile_canvas.display_width, self.tile_canvas.display_height))
            if editor_rect.collidepoint(pos):
                return self.tile_canvas
        return None

    def handle_event(self, event):
        """Process a single Pygame event by delegating to the EventHandler."""
        return self.event_handler.process_event(event)

    def load_reference_image(self):
        """Opens a dialog to select a reference image, loads and scales it."""
        self.trigger_load_reference_dialog()

    def _scale_reference_image(self):
        """Scales the loaded reference image using Aspect Fit, then applies
           user-defined scale and offset, preparing it for display behind the active editor.
        """
        if not self.reference_image:
            self.scaled_reference_image = None
            return

        # Target dimensions are the display size of the sprite editor grid
        sprite_editor = self.sprites.get('front')
        if not sprite_editor:
            print("Error: Cannot scale reference image, sprite editor 'front' not found.")
            self.scaled_reference_image = None
            return

        canvas_w = sprite_editor.display_width
        canvas_h = sprite_editor.display_height
        orig_w, orig_h = self.reference_image.get_size()

        if orig_w == 0 or orig_h == 0:
             print("Warning: Reference image has zero dimension. Cannot scale.")
             self.scaled_reference_image = None
             return

        # 1. Calculate initial aspect fit scale
        scale_w_ratio = canvas_w / orig_w
        scale_h_ratio = canvas_h / orig_h
        aspect_scale = min(scale_w_ratio, scale_h_ratio)
        initial_scaled_w = int(orig_w * aspect_scale)
        initial_scaled_h = int(orig_h * aspect_scale)

        # 2. Apply user scale on top of aspect fit
        current_scaled_w = int(initial_scaled_w * self.ref_img_scale)
        current_scaled_h = int(initial_scaled_h * self.ref_img_scale)

        # Prevent scaling to zero size
        if current_scaled_w <= 0 or current_scaled_h <= 0:
             print("Warning: Calculated final scaled size is zero or negative. Cannot scale.")
             self.scaled_reference_image = None
             return

        try:
            # 3. Scale the ORIGINAL image to the final calculated size
            user_scaled_surf = pygame.transform.smoothscale(self.reference_image, (current_scaled_w, current_scaled_h))

            # 4. Create the final surface matching canvas size, transparent background
            final_display_surf = pygame.Surface((canvas_w, canvas_h), pygame.SRCALPHA)
            final_display_surf.fill((0, 0, 0, 0)) # Fully transparent

            # 5. Calculate centering position AND apply user offset
            center_x = (canvas_w - current_scaled_w) // 2
            center_y = (canvas_h - current_scaled_h) // 2
            blit_x = center_x + int(self.ref_img_offset.x)
            blit_y = center_y + int(self.ref_img_offset.y)

            # 6. Blit the user-scaled image onto the transparent canvas at the final position
            final_display_surf.blit(user_scaled_surf, (blit_x, blit_y))

            # Store this surface before applying alpha
            self.scaled_reference_image = final_display_surf

            # Apply the current alpha value
            self.apply_reference_alpha()

        except pygame.error as e:
            print(f"Error during reference image scaling: {e}")
            self.scaled_reference_image = None
        except ValueError as e: # Catch potential issues with smoothscale
            print(f"Error during reference image scaling (ValueError): {e}")
            self.scaled_reference_image = None


    def clear_reference_image(self):
        """Removes the current reference image."""
        self.reference_image_path = None
        self.reference_image = None
        self.scaled_reference_image = None
        # Reset panning and scaling
        self.ref_img_offset.update(0, 0)
        self.ref_img_scale = 1.0
        print("Reference image cleared.")

    def set_reference_alpha(self, alpha_value):
        """Sets the alpha value (0-255) for the reference image."""
        new_alpha = max(0, min(255, int(alpha_value))) # Clamp value
        if new_alpha != self.reference_alpha:
            self.reference_alpha = new_alpha
            #print(f"Set reference alpha to: {self.reference_alpha}") # Debug
            self.apply_reference_alpha()

    def apply_reference_alpha(self):
        """Applies the current alpha value to the scaled reference image surface."""
        # This logic needs refinement. set_alpha modifies the surface in-place.
        # We need to re-apply alpha if the base scaled image changes or alpha changes.
        # Let's re-scale if the reference_image exists but scaled is None
        if self.reference_image and not self.scaled_reference_image:
             self._scale_reference_image()
             # _scale_reference_image now calls apply_reference_alpha internally at the end
             return # Scaling handles alpha application

        # If scaled image exists, just set its alpha
        if self.scaled_reference_image:
            try:
                # Create a fresh scaled surface if it doesn't exist (should be handled above)
                # if not self.scaled_reference_image: self._scale_reference_image()
                # If still none, exit
                # if not self.scaled_reference_image: return

                # Apply alpha to the existing scaled surface
                self.scaled_reference_image.set_alpha(self.reference_alpha)

                # Update knob position based on new alpha
                slider_width = self.ref_alpha_slider_rect.width - self.ref_alpha_knob_rect.width
                # Ensure slider_width is not zero to avoid division error
                if slider_width > 0:
                    knob_x = self.ref_alpha_slider_rect.x + int((self.reference_alpha / 255) * slider_width)
                    self.ref_alpha_knob_rect.x = knob_x
                else: # Handle edge case where slider is too small
                    self.ref_alpha_knob_rect.x = self.ref_alpha_slider_rect.x

            except pygame.error as e:
                print(f"Error applying alpha to reference image: {e}")
            except AttributeError:
                 # Handle case where scaled_reference_image might be None unexpectedly
                 print("Warning: Tried to apply alpha but scaled_reference_image is None.")

    def set_subject_alpha(self, alpha_value):
        """Sets the alpha value (0-255) for the subject sprite being edited."""
        new_alpha = max(0, min(255, int(alpha_value))) # Clamp value
        if new_alpha != self.subject_alpha:
            self.subject_alpha = new_alpha
            # Update knob position
            slider_width = self.subj_alpha_slider_rect.width - self.subj_alpha_knob_rect.width
            if slider_width > 0:
                knob_x = self.subj_alpha_slider_rect.x + int((self.subject_alpha / 255) * slider_width)
                self.subj_alpha_knob_rect.x = knob_x
            else:
                self.subj_alpha_knob_rect.x = self.subj_alpha_slider_rect.x
            # No need to call apply_alpha here, draw_ui will use the value
            
    def draw_ui(self):
        """Draw the entire editor UI onto the screen."""
        screen.fill(config.EDITOR_BG_COLOR)
        # print(f"DEBUG: draw_ui start. self.dialog_mode = {self.dialog_mode}") 

        # --- Draw Dialog FIRST if active --- 
        if self.dialog_mode:
            self.draw_dialog(screen)
            return # Stop drawing here if a dialog is active

        # --- Draw Main UI (Only if no dialog active and mode is set) ---
        if self.edit_mode is None:
             loading_font = pygame.font.Font(config.DEFAULT_FONT, 30)
             loading_surf = loading_font.render("Waiting for mode selection...", True, config.BLACK)
             loading_rect = loading_surf.get_rect(center=screen.get_rect().center)
             screen.blit(loading_surf, loading_rect)
             return

        # Draw based on mode
        if self.edit_mode == 'monster':
            # Draw monster-specific UI
            for sprite_editor in self.sprites.values():
                sprite_editor.draw_background(screen)
            if self.scaled_reference_image:
                active_sprite_editor = self.sprites.get(self.current_sprite)
                if active_sprite_editor:
                    screen.blit(self.scaled_reference_image, active_sprite_editor.position)
            for name, sprite_editor in self.sprites.items():
                display_surface = sprite_editor.frame.copy()
                scaled_display_frame = pygame.transform.scale(display_surface, (sprite_editor.display_width, sprite_editor.display_height))
                scaled_display_frame.set_alpha(self.subject_alpha)
                screen.blit(scaled_display_frame, sprite_editor.position)
            active_sprite_editor = self.sprites.get(self.current_sprite)
            if active_sprite_editor:
                active_sprite_editor.draw_highlight(screen, self.current_sprite)
            monster_name = config.monsters[self.current_monster_index].get('name', 'Unknown')
            info_text = f"Editing: {monster_name} ({self.current_sprite})"
            info_surf = self.font.render(info_text, True, config.BLACK)
            screen.blit(info_surf, (50, 50))
            if self.mode == 'select':
                 active_sprite_editor = self.sprites.get(self.current_sprite)
                 if active_sprite_editor:
                     self.selection.draw(screen, active_sprite_editor.position)

        elif self.edit_mode == 'background':
            # Draw background-specific UI
            if self.current_background and self.canvas_rect:
                scaled_width = int(self.current_background.get_width() * self.editor_zoom)
                scaled_height = int(self.current_background.get_height() * self.editor_zoom)
                if scaled_width > 0 and scaled_height > 0:
                    zoomed_bg = pygame.transform.scale(self.current_background, (scaled_width, scaled_height))
                    max_offset_x = max(0, scaled_width - self.canvas_rect.width)
                    max_offset_y = max(0, scaled_height - self.canvas_rect.height)
                    clamped_offset_x = max(0, min(self.view_offset_x, max_offset_x))
                    clamped_offset_y = max(0, min(self.view_offset_y, max_offset_y))
                    source_rect = pygame.Rect(clamped_offset_x, clamped_offset_y, self.canvas_rect.width, self.canvas_rect.height)
                    screen.blit(zoomed_bg, self.canvas_rect.topleft, source_rect)
                pygame.draw.rect(screen, config.BLACK, self.canvas_rect, 1)
            bg_name = self.backgrounds[self.current_background_index][0] if self.current_background_index != -1 else "New BG"
            info_text = f"Editing BG: {bg_name} | Brush: {self.brush_size} | Zoom: {self.editor_zoom:.2f}x"
            info_surf = self.font.render(info_text, True, config.BLACK)
            screen.blit(info_surf, (50, 50))
        elif self.edit_mode == 'tile':
            self.tile_canvas.draw_background(screen)
            display_surface = self.tile_canvas.frame.copy()
            scaled_display = pygame.transform.scale(display_surface, (self.tile_canvas.display_width, self.tile_canvas.display_height))
            screen.blit(scaled_display, self.tile_canvas.position)
            pygame.draw.rect(screen, config.SELECTION_HIGHLIGHT_COLOR, pygame.Rect(self.tile_canvas.position, (self.tile_canvas.display_width, self.tile_canvas.display_height)), 3)
            tileset_name = self.tile_set.name if self.tile_set else "Tiles"
            if self.asset_edit_target == 'tile':
                tile = self.current_tile()
                walkable_state = tile.properties.get("walkable", True) if tile else True
                tile_label = f"{tile.id} ({tile.name})" if tile else "No Tile"
                walkable_text = "Walkable" if walkable_state else "Blocked"
                frame_info = ""
                if tile and tile.frames:
                    frame_info = f" | Frame {self.current_tile_frame_index + 1}/{len(tile.frames)} @ {tile.frame_duration_ms}ms"
                info_text = f"Tileset: {tileset_name} | Tile: {tile_label} | {walkable_text}{frame_info}"
                info_surf = self.font.render(info_text, True, config.BLACK)
                screen.blit(info_surf, (50, 50))
                if self.mode == 'select':
                    self.selection.draw(screen, self.tile_canvas.position)
                self.draw_tile_panel(screen)
            else:
                npc = self.current_npc()
                npc_label = npc.id if npc else "No NPC"
                frame_info = ""
                if npc:
                    frames = npc.states.get(self.current_npc_state, {}).get(self.current_npc_angle, [])
                    frame_info = f" | Frame {self.current_npc_frame_index + 1}/{len(frames) if frames else 1} @ {npc.frame_duration_ms}ms"
                info_text = f"Tileset: {tileset_name} | NPC: {npc_label} | State: {self.current_npc_state} | Angle: {self.current_npc_angle}{frame_info}"
                info_surf = self.font.render(info_text, True, config.BLACK)
                screen.blit(info_surf, (50, 50))
                if self.mode == 'select':
                    self.selection.draw(screen, self.tile_canvas.position)
                self.draw_npc_panel(screen)

        # Draw Common Elements
        self.palette.draw(screen, self.current_color)
        if hasattr(self, 'buttons') and self.buttons:
            for button in self.buttons:
                button.draw(screen)
        # Brush Slider
        pygame.draw.rect(screen, config.GRAY_LIGHT, self.brush_slider)
        pygame.draw.rect(screen, config.BLACK, self.brush_slider, 1)
        brush_text = f"Brush: {self.brush_size}"
        brush_surf = self.font.render(brush_text, True, config.BLACK)
        brush_rect = brush_surf.get_rect(midleft=(self.brush_slider.right + 10, self.brush_slider.centery))
        screen.blit(brush_surf, brush_rect)
        # Ref Alpha Slider
        pygame.draw.rect(screen, config.GRAY_LIGHT, self.ref_alpha_slider_rect)
        pygame.draw.rect(screen, config.BLACK, self.ref_alpha_slider_rect, 1)
        pygame.draw.rect(screen, config.BLUE, self.ref_alpha_knob_rect)
        alpha_text = f"Ref Alpha: {self.reference_alpha}"
        alpha_surf = self.font.render(alpha_text, True, config.BLACK)
        alpha_rect = alpha_surf.get_rect(midleft=(self.ref_alpha_slider_rect.right + 10, self.ref_alpha_slider_rect.centery))
        screen.blit(alpha_surf, alpha_rect)
        # Subject Alpha Slider (Monster Mode Only)
        if self.edit_mode == 'monster':
            pygame.draw.rect(screen, config.GRAY_LIGHT, self.subj_alpha_slider_rect)
            pygame.draw.rect(screen, config.BLACK, self.subj_alpha_slider_rect, 1)
            pygame.draw.rect(screen, config.RED, self.subj_alpha_knob_rect)
            subj_alpha_text = f"Subj Alpha: {self.subject_alpha}"
            subj_alpha_surf = self.font.render(subj_alpha_text, True, config.BLACK)
            subj_alpha_rect = subj_alpha_surf.get_rect(midleft=(self.subj_alpha_slider_rect.right + 10, self.subj_alpha_slider_rect.centery))
            screen.blit(subj_alpha_surf, subj_alpha_rect)
    # <<< End Restore draw_ui >>>

    def draw_dialog(self, surface):
        """Draws the current dialog box overlay."""
        # Basic semi-transparent overlay
        overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
        overlay.fill((*config.BLACK[:3], 180))
        surface.blit(overlay, (0, 0))

        # Simple box and prompt
        dialog_width = 400
        dialog_height = 300
        dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        dialog_rect.center = surface.get_rect().center
        pygame.draw.rect(surface, config.WHITE, dialog_rect, border_radius=5)
        pygame.draw.rect(surface, config.BLACK, dialog_rect, 2, border_radius=5)

        prompt_surf = self.font.render(self.dialog_prompt, True, config.BLACK)
        prompt_rect = prompt_surf.get_rect(midtop=(dialog_rect.centerx, dialog_rect.top + 20))
        surface.blit(prompt_surf, prompt_rect)

        list_top = prompt_rect.bottom + 10
        list_height = 150
        button_y = prompt_rect.bottom + 30
        if self.dialog_mode in ['load_bg', 'load_ref', 'load_tileset']:
            list_rect = pygame.Rect(
                dialog_rect.x + 20,
                list_top,
                dialog_rect.width - 40,
                list_height,
            )
            self.dialog_file_list_rect = list_rect
            pygame.draw.rect(surface, config.GRAY_LIGHT, list_rect)
            pygame.draw.rect(surface, config.BLACK, list_rect, 1)

            line_height = self.font.get_linesize()
            self.dialog_file_page_size = max(1, list_rect.height // line_height)
            scrollbar_width = 12
            self.dialog_file_scrollbar_rect = pygame.Rect(
                list_rect.right - scrollbar_width,
                list_rect.y,
                scrollbar_width,
                list_rect.height,
            )
            pygame.draw.rect(surface, config.GRAY_MEDIUM, self.dialog_file_scrollbar_rect)
            end_index = min(
                self.dialog_file_scroll_offset + self.dialog_file_page_size,
                len(self.dialog_file_list),
            )
            for row, index in enumerate(range(self.dialog_file_scroll_offset, end_index)):
                label = (
                    self.dialog_file_labels[index]
                    if index < len(self.dialog_file_labels)
                    else str(self.dialog_file_list[index])
                )
                text_color = config.WHITE if index == self.dialog_selected_file_index else config.BLACK
                if index == self.dialog_selected_file_index:
                    highlight_rect = pygame.Rect(
                        list_rect.x,
                        list_rect.y + row * line_height,
                        list_rect.width,
                        line_height,
                    )
                    pygame.draw.rect(surface, config.BLUE, highlight_rect)
                text_surf = self.font.render(label, True, text_color)
                surface.blit(text_surf, (list_rect.x + 6, list_rect.y + row * line_height))

            quick_y = list_rect.bottom + 10
            quick_x = list_rect.x
            quick_padding = 8
            self.dialog_quick_dir_rects = []
            for label, path in self.dialog_quick_dirs:
                quick_surf = self.font.render(label, True, config.BLACK)
                quick_rect = quick_surf.get_rect()
                quick_rect.topleft = (quick_x, quick_y)
                pygame.draw.rect(surface, config.GRAY_LIGHT, quick_rect.inflate(8, 6))
                pygame.draw.rect(surface, config.BLACK, quick_rect.inflate(8, 6), 1)
                surface.blit(quick_surf, quick_rect)
                self.dialog_quick_dir_rects.append((quick_rect.inflate(8, 6), path))
                quick_x += quick_rect.width + quick_padding + 8

            self._update_scrollbar_from_offset()
            if self.dialog_file_scroll_thumb_rect:
                pygame.draw.rect(surface, config.GRAY_DARK, self.dialog_file_scroll_thumb_rect)

            button_y = list_rect.bottom + 50
        else:
            self.dialog_file_list_rect = None
            self.dialog_file_page_size = 0
            self.dialog_file_scrollbar_rect = None
            self.dialog_file_scroll_thumb_rect = None
            if self.dialog_mode == 'input_text':
                input_rect = pygame.Rect(dialog_rect.x + 40, prompt_rect.bottom + 20, dialog_rect.width - 80, 40)
                pygame.draw.rect(surface, config.WHITE, input_rect)
                pygame.draw.rect(surface, config.BLACK, input_rect, 1)
                text_surf = self.font.render(self.dialog_input_text, True, config.BLACK)
                surface.blit(text_surf, (input_rect.x + 8, input_rect.y + 8))
                button_y = input_rect.bottom + 20

        # Draw options (buttons) - needs proper layout
        for i, option in enumerate(self.dialog_options):
            if isinstance(option, Button):
                option.rect.centerx = dialog_rect.centerx
                option.rect.top = button_y + i * (option.rect.height + 10)
                option.draw(surface)
        # TODO: Add rendering for other dialog elements (text input, color picker)
    # <<< End Restore draw_dialog >>>

    def run(self):
        """Main application loop."""
        running = True
        while running:
            # Event handling
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                self.handle_event(event) # Pass event to editor

            # Drawing
            self.draw_ui()

            # Update display
            pygame.display.flip()

            # Cap frame rate
            clock.tick(config.FPS)

        pygame.quit()

    # --- Add Panning Methods --- 
    def _pan_view(self, dx=0, dy=0):
        """Helper method to adjust view offset and clamp values."""
        if self.edit_mode != 'background':
            return
            
        self.view_offset_x += dx
        self.view_offset_y += dy

        # Clamp view offset
        if self.current_background:
            scaled_width = int(self.current_background.get_width() * self.editor_zoom)
            scaled_height = int(self.current_background.get_height() * self.editor_zoom)
            max_offset_x = max(0, scaled_width - self.canvas_rect.width)
            max_offset_y = max(0, scaled_height - self.canvas_rect.height)
            self.view_offset_x = max(0, min(self.view_offset_x, max_offset_x))
            self.view_offset_y = max(0, min(self.view_offset_y, max_offset_y))

    def pan_up(self):
        self._pan_view(dy=-config.PAN_SPEED_PIXELS)

    def pan_down(self):
        self._pan_view(dy=config.PAN_SPEED_PIXELS)

    def pan_left(self):
        self._pan_view(dx=-config.PAN_SPEED_PIXELS)

    def pan_right(self):
        self._pan_view(dx=config.PAN_SPEED_PIXELS)
    # --- End Panning Methods --- 

# Main execution block
if __name__ == "__main__":
    # --- Remove explicit Tkinter init call from here ---
    # It's handled globally at the top now
    # print("Attempting Tkinter global initialization...")
    # if not _initialize_tkinter_globally():
    #      print("Warning: Tkinter initialization failed. File/Color dialogs may not work.")
    
    # --- Remove explicit Pygame init call from here ---
    # It's also handled globally at the top now
    # print("Initializing Pygame...")
    # pygame.init()

    # Set up necessary directories if they don't exist
    # ... (directory setup code remains the same) ...
    if not os.path.exists(config.SPRITE_DIR):
        os.makedirs(config.SPRITE_DIR)
        print(f"Created missing directory: {config.SPRITE_DIR}")
    if not os.path.exists(config.BACKGROUND_DIR):
        os.makedirs(config.BACKGROUND_DIR)
        print(f"Created missing directory: {config.BACKGROUND_DIR}")
    if not os.path.exists(config.DATA_DIR):
         os.makedirs(config.DATA_DIR)
         print(f"Created missing directory: {config.DATA_DIR}")

    # Ensure monster data is loaded globally for the Editor
    # ... (monster loading code remains the same) ...
    if 'monsters' not in globals() or not monsters:
         print("Reloading monster data for main execution...")
         monsters = load_monsters() 
         if not monsters:
              print("Fatal: Could not load monster data. Exiting.")
              sys.exit(1)
    config.monsters = monsters 

    editor = Editor()
    editor.run()



================================================
File: src/editor/selection_manager.py
================================================
import pygame
# from ..core import config # Relative import
from src.core import config # Absolute import

# Selection Tool Class
class SelectionTool:
    """
    A selection tool for the pixel art editor.

    This class allows users to select and manipulate a rectangular area of pixels
    within the editor. It supports copying, pasting, mirroring, and rotating
    the selected area.

    Attributes:
        editor (Editor): The main editor instance.
        selecting (bool): Flag indicating if the selection tool is currently active.
        active (bool): Flag indicating if a selection is currently in progress.
        start_pos (tuple): The starting position of the selection rectangle.
        end_pos (tuple): The ending position of the selection rectangle.
        rect (pygame.Rect): The current selection rectangle.

    Methods:
        toggle() -> None
        start(pos: tuple) -> None
        update(pos: tuple) -> None
        end_selection(pos: tuple) -> None
        update_rect() -> None
        draw(surface: pygame.Surface) -> None
        get_selected_pixels(sprite_editor) -> dict
    """

    def __init__(self, editor):
        """
        Initialize a new SelectionTool instance.

        Args:
            editor (Editor): The main editor instance.
        """
        self.editor = editor
        self.selecting = False
        self.active = False
        self.start_pos = None
        self.end_pos = None
        self.rect = pygame.Rect(0, 0, 0, 0)

    def toggle(self):
        """
        Toggle the selection tool's activation state.
        """
        self.selecting = True  # Always start fresh selection
        self.active = False  # Reset active state
        self.start_pos = None  # Reset start position
        self.end_pos = None  # Reset end position
        self.rect = pygame.Rect(0, 0, 0, 0)  # Reset rectangle
        print("Selection mode activated.")

    def start(self, pos, sprite_editor):
        """
        Start a new selection at the given position on the specified sprite editor.

        Args:
            pos (tuple): The starting screen position of the selection rectangle.
            sprite_editor (SpriteEditor): The sprite editor where the selection is starting.
        """
        grid_pos = sprite_editor.get_grid_position(pos)
        if grid_pos:
            self.start_pos = grid_pos
            self.end_pos = grid_pos
            self.update_rect()
            print(f"Selection started at: {self.start_pos}")

    def update(self, pos, sprite_editor):
        """
        Update the selection rectangle based on the given position on the specified sprite editor.

        Args:
            pos (tuple): The current screen position of the mouse.
            sprite_editor (SpriteEditor): The sprite editor where the selection is active.
        """
        grid_pos = sprite_editor.get_grid_position(pos)
        if grid_pos:
            self.end_pos = grid_pos
            self.update_rect()
            print(f"Selection updated to: {self.end_pos}")

    def end_selection(self, pos, sprite_editor):
        """
        End the current selection at the given position on the specified sprite editor.

        Args:
            pos (tuple): The ending screen position of the selection rectangle.
            sprite_editor (SpriteEditor): The sprite editor where the selection ended.
        """
        grid_pos = sprite_editor.get_grid_position(pos)
        if grid_pos:
            self.end_pos = grid_pos
            self.update_rect()
            self.active = True
            self.selecting = False
            print(f"Selection defined: {self.rect}")

    def update_rect(self):
        """
        Update the selection rectangle based on the start and end positions.
        """
        if self.start_pos and self.end_pos:
            x1, y1 = self.start_pos
            x2, y2 = self.end_pos
            left = min(x1, x2)
            top = min(y1, y2)
            width = abs(x2 - x1) + 1
            height = abs(y2 - y1) + 1
            self.rect = pygame.Rect(left, top, width, height)

    def draw(self, surface, sprite_position):
        """
        Draw the selection rectangle on a given surface, relative to the sprite's position.

        Args:
            surface (pygame.Surface): The surface on which to draw the selection.
            sprite_position (tuple): The screen coordinates (x, y) of the top-left corner of the sprite editor.
        """
        # Draw selection rectangle while selecting (mouse down) or when selection is active
        if (self.selecting and self.start_pos and self.end_pos) or self.active:
            x0, y0 = sprite_position
            selection_surface = pygame.Surface((self.rect.width * config.EDITOR_PIXEL_SIZE, self.rect.height * config.EDITOR_PIXEL_SIZE), pygame.SRCALPHA)
            selection_surface.fill(config.SELECTION_FILL_COLOR)  # Semi-transparent blue
            pygame.draw.rect(selection_surface, config.BLUE, selection_surface.get_rect(), 2)
            surface.blit(selection_surface, (x0 + self.rect.x * config.EDITOR_PIXEL_SIZE, y0 + self.rect.y * config.EDITOR_PIXEL_SIZE))

    def get_selected_pixels(self, sprite_editor):
        """ Get the pixels within the selection rectangle (coords relative to 32x32 grid). """
        if not sprite_editor or not self.active:
            return {}

        pixels = {}
        # self.rect is relative to the visual grid (0-31 range)
        # Native frame is also 32x32, so coords match directly
        for x in range(self.rect.width):
            for y in range(self.rect.height):
                grid_x = self.rect.x + x
                grid_y = self.rect.y + y
                # Check bounds against native resolution (32x32)
                if 0 <= grid_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= grid_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                    color = sprite_editor.get_pixel_color((grid_x, grid_y))
                    if color is not None:
                        pixels[(x, y)] = color # Store relative to selection top-left
        return pixels

    def apply_paste(self, sprite_editor, top_left_grid_pos, copy_buffer):
        """Pastes the copy_buffer onto the sprite_editor frame."""
        if not copy_buffer or not sprite_editor:
            return

        start_x, start_y = top_left_grid_pos
        for (rel_x, rel_y), color in copy_buffer.items():
            abs_x = start_x + rel_x
            abs_y = start_y + rel_y
            # Check bounds before attempting to draw
            if 0 <= abs_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= abs_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                # Only paste non-transparent pixels.
                if color[3] > 0:
                    sprite_editor.draw_pixel((abs_x, abs_y), color)



================================================
File: src/editor/sprite_editor.py
================================================
import pygame
import os
# from ..core import config # Relative import
from src.core import config # Absolute import

class SpriteEditor:
    """ Edits sprites at 32x32 native resolution. """
    def __init__(self, position, name, sprite_dir):
        self.position = position
        self.name = name
        self.sprite_dir = sprite_dir # Store the directory
        # Internal frame stores the actual sprite data at native resolution (32x32)
        self.frame = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
        self.frame.fill((*config.BLACK[:3], 0)) # Transparent black
        # Calculate the total display size of the editor grid
        self.display_width = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE
        self.display_height = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE

    def load_sprite(self, monster_name):
        """Loads sprite, checks size, scales to NATIVE_SPRITE_RESOLUTION if needed."""
        self.frame.fill((*config.BLACK[:3], 0)) # Transparent black
        # Use the stored sprite_dir
        filename = os.path.join(self.sprite_dir, f"{monster_name}_{self.name}.png")
        if os.path.exists(filename):
            try:
                loaded_image = pygame.image.load(filename).convert_alpha()
                # Scale to native (32x32) if it doesn't match
                if loaded_image.get_size() != config.NATIVE_SPRITE_RESOLUTION:
                    print(f"Warning: Loaded sprite {filename} size {loaded_image.get_size()} does not match native {config.NATIVE_SPRITE_RESOLUTION}. Scaling down.")
                    loaded_image = pygame.transform.smoothscale(loaded_image, config.NATIVE_SPRITE_RESOLUTION)
                self.frame.blit(loaded_image, (0, 0))
            except pygame.error as e:
                 print(f"Error loading sprite {filename}: {e}")
                 # Use a placeholder color from config
                 placeholder_color = (*config.RED[:3], 100) if hasattr(config, 'RED') else (255, 0, 0, 100)
                 self.frame.fill(placeholder_color) # Semi-transparent red/magenta placeholder
        else:
            print(f"Sprite not found: {filename}. Creating blank.")
            self.frame.fill((*config.BLACK[:3], 0))

    def save_sprite(self, monster_name):
        """Saves the internal 32x32 frame directly, requires monster_name."""
        # config.py should ensure SPRITE_DIR exists

        # Ensure monster_name is provided
        if not monster_name:
            print("Error: Cannot save sprite. Monster name is required.")
            return

        filename = os.path.join(self.sprite_dir, f"{monster_name}_{self.name}.png")
        try:
            pygame.image.save(self.frame, filename)
            print(f"Saved sprite: {filename} at {config.NATIVE_SPRITE_RESOLUTION}")
        except pygame.error as e:
             print(f"Error saving sprite {filename}: {e}")

    def draw_background(self, surface):
        """Draws the checkerboard background for the editor grid."""
        for y in range(config.EDITOR_GRID_SIZE):
            for x in range(config.EDITOR_GRID_SIZE):
                rect = (self.position[0] + x * config.EDITOR_PIXEL_SIZE, 
                        self.position[1] + y * config.EDITOR_PIXEL_SIZE, 
                        config.EDITOR_PIXEL_SIZE, config.EDITOR_PIXEL_SIZE)
                # Use checkerboard colors from config
                color1 = config.GRID_COLOR_1 if hasattr(config, 'GRID_COLOR_1') else (200, 200, 200)
                color2 = config.GRID_COLOR_2 if hasattr(config, 'GRID_COLOR_2') else (180, 180, 180)
                color = color1 if (x + y) % 2 == 0 else color2
                pygame.draw.rect(surface, color, rect)

    def draw_pixels(self, surface):
        """Draws the scaled sprite pixels onto the target surface."""
        # Scale the 32x32 native frame up to the display size (e.g., 480x480)
        # Use regular scale for pixel art sharpness
        scaled_display_frame = pygame.transform.scale(self.frame, (self.display_width, self.display_height))
        surface.blit(scaled_display_frame, self.position)

    def draw_highlight(self, surface, current_sprite_name):
        """Draws the highlight rectangle if this editor is active."""
        if current_sprite_name == self.name:
            highlight_rect = pygame.Rect(self.position[0] - 10, self.position[1] - 10,
                                         self.display_width + 20, self.display_height + 20)
            # Use highlight color from config
            highlight_color = config.SELECTION_HIGHLIGHT_COLOR if hasattr(config, 'SELECTION_HIGHLIGHT_COLOR') else (0, 255, 0)
            pygame.draw.rect(surface, highlight_color, highlight_rect, 3)

    def draw(self, surface):
        """Draws the scaled-up sprite editor grid onto the target surface.
           DEPRECATED in favor of draw_background and draw_pixels.
           Kept for compatibility or potential future use, but logic moved.
        """
        # This method is now simplified or can be removed if draw_ui is fully updated.
        # For safety, let's make it call the new methods for now.
        self.draw_background(surface)
        self.draw_pixels(surface)
        # Highlight is drawn separately in draw_ui now.

    def get_grid_position(self, pos):
        """Converts screen coordinates (within display area) to 32x32 grid coordinates."""
        x, y = pos
        # Check if click is within the visual editor bounds
        if not (self.position[0] <= x < self.position[0] + self.display_width and
                self.position[1] <= y < self.position[1] + self.display_height):
            return None

        # Calculate grid coordinates directly from relative position and PIXEL_SIZE
        grid_x = (x - self.position[0]) // config.EDITOR_PIXEL_SIZE
        grid_y = (y - self.position[1]) // config.EDITOR_PIXEL_SIZE

        # Ensure coordinates are within the 32x32 grid bounds
        if 0 <= grid_x < config.EDITOR_GRID_SIZE and 0 <= grid_y < config.EDITOR_GRID_SIZE:
             # Since native is 32x32 and editor grid is 32x32, coords are the same
            return grid_x, grid_y
        return None

    def draw_pixel(self, grid_pos, color):
        """Draws a pixel at the given 32x32 grid coordinates."""
        if 0 <= grid_pos[0] < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= grid_pos[1] < config.NATIVE_SPRITE_RESOLUTION[1]:
            self.frame.set_at(grid_pos, color)

    def get_pixel_color(self, grid_pos):
         """Gets the color of a pixel from the 32x32 grid coordinates."""
         if 0 <= grid_pos[0] < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= grid_pos[1] < config.NATIVE_SPRITE_RESOLUTION[1]:
            return self.frame.get_at(grid_pos)
         return None 


================================================
File: src/editor/tool_manager.py
================================================
# tool_manager.py

"""Manages different editing tools (Draw, Fill, Paste, etc.) for the pixel editor."""

import pygame
# from ..core import config # Relative import
from src.core import config # Absolute import
# Need SpriteEditor for type hinting potentially, or direct manipulation
# from .sprite_editor import SpriteEditor # Relative import
from src.editor.sprite_editor import SpriteEditor # Absolute import

# --- Base Tool --- (Optional, but good for structure)
class BaseTool:
    def __init__(self, name):
        self.name = name

    def handle_click(self, editor, pos):
        """Handles a mouse click event at the given position."""
        raise NotImplementedError

    def handle_drag(self, editor, pos):
        """Handles a mouse drag event at the given position."""
        # Default behavior for many tools might be same as click
        self.handle_click(editor, pos)

    def activate(self, editor):
        """Called when the tool becomes active."""
        print(f"{self.name} tool activated.")
        pass # Optional setup

    def deactivate(self, editor):
        """Called when the tool is deactivated."""
        print(f"{self.name} tool deactivated.")
        pass # Optional cleanup

# --- Draw/Erase Tool ---
class DrawTool(BaseTool):
    def __init__(self):
        super().__init__("Draw/Erase")

    def _get_target(self, editor, pos):
        """Helper to get the target sprite editor or background surface."""
        if editor.edit_mode == 'monster':
            return editor._get_sprite_editor_at_pos(pos)
        elif editor.edit_mode == 'tile':
            return editor._get_sprite_editor_at_pos(pos)
        elif editor.edit_mode == 'background' and editor.canvas_rect and editor.current_background:
            if editor.canvas_rect.collidepoint(pos):
                return editor.current_background # Return the surface
        return None

    def _draw_on_sprite(self, editor, sprite_editor, grid_pos):
        """Handles drawing/erasing on a SpriteEditor."""
        color = (*config.BLACK[:3], 0) if editor.eraser_mode else editor.current_color
        half_brush = (editor.brush_size - 1) // 2
        for dy in range(-half_brush, half_brush + 1):
            for dx in range(-half_brush, half_brush + 1):
                # Optional: Add check for circular brush shape if desired
                # if dx*dx + dy*dy <= half_brush*half_brush:
                draw_x = grid_pos[0] + dx
                draw_y = grid_pos[1] + dy
                if 0 <= draw_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= draw_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                    sprite_editor.draw_pixel((draw_x, draw_y), color)

    def _draw_on_background(self, editor, background_surface, pos):
        """Handles drawing/erasing on the background surface."""
        if not editor.canvas_rect: return

        # Calculate position relative to the background canvas top-left
        screen_x_rel = pos[0] - editor.canvas_rect.x
        screen_y_rel = pos[1] - editor.canvas_rect.y
        
        # Convert screen coordinates within canvas_rect to coordinates on the original surface
        original_x = int((screen_x_rel + editor.view_offset_x) / editor.editor_zoom)
        original_y = int((screen_y_rel + editor.view_offset_y) / editor.editor_zoom)
        
        # Check if calculated coordinates are within the original background bounds
        bg_width, bg_height = background_surface.get_size()
        if 0 <= original_x < bg_width and 0 <= original_y < bg_height:
            color = config.WHITE if editor.eraser_mode else editor.current_color[:3] # Use opaque colors for BG
            # Scale the brush radius based on zoom
            scaled_radius = max(1, int((editor.brush_size / 2) / editor.editor_zoom))
            pygame.draw.circle(background_surface, color, (original_x, original_y), scaled_radius)


    def handle_click(self, editor, pos):
        target = self._get_target(editor, pos)
        if not target: 
            return

        if isinstance(target, SpriteEditor): # Target is SpriteEditor
            sprite_editor = target
            grid_pos = sprite_editor.get_grid_position(pos)
            if grid_pos:
                self._draw_on_sprite(editor, sprite_editor, grid_pos)
        elif isinstance(target, pygame.Surface): # Target is background Surface
            self._draw_on_background(editor, target, pos)

# --- Fill Tool ---
class FillTool(BaseTool):
    def __init__(self):
        super().__init__("Fill")

    def _flood_fill_sprite(self, sprite_editor, start_pos, fill_color):
        """Perform flood fill on the sprite editor's frame."""
        native_res = config.NATIVE_SPRITE_RESOLUTION
        target_color = sprite_editor.get_pixel_color(start_pos)

        if target_color == fill_color:
            return # No need to fill

        stack = [start_pos]
        visited = {start_pos}

        while stack:
            x, y = stack.pop()
            # Check color again in case it was changed by another path
            current_pixel_color = sprite_editor.get_pixel_color((x, y))
            if current_pixel_color == target_color:
                sprite_editor.draw_pixel((x, y), fill_color)
                # Check neighbors
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < native_res[0] and 0 <= ny < native_res[1]:
                        neighbor_pos = (nx, ny)
                        if neighbor_pos not in visited:
                             stack.append(neighbor_pos)
                             visited.add(neighbor_pos)
        print("Fill complete.")
        # Note: editor.save_state() should be called *before* invoking the tool's handle_click

    def _flood_fill_background(self, editor, background_surface, start_screen_pos, fill_color):
        """Perform flood fill on the background surface."""
        print("Background Fill - Not Implemented Yet")
        # TODO: Implement background fill logic
        # Needs to handle zoom/pan to convert screen coords to surface coords
        # Needs to handle potentially large surfaces efficiently
        pass

    def handle_click(self, editor, pos):
        if editor.edit_mode in ['monster', 'tile']:
            sprite_editor = editor._get_sprite_editor_at_pos(pos)
            if sprite_editor:
                grid_pos = sprite_editor.get_grid_position(pos)
                if grid_pos:
                    fill_color_rgba = editor.current_color # Use full RGBA
                    self._flood_fill_sprite(sprite_editor, grid_pos, fill_color_rgba)
        elif editor.edit_mode == 'background' and editor.canvas_rect and editor.current_background:
             if editor.canvas_rect.collidepoint(pos):
                 fill_color_rgb = editor.current_color[:3] # Use RGB for background
                 self._flood_fill_background(editor, editor.current_background, pos, fill_color_rgb)
        
    # Drag usually doesn't make sense for fill
    def handle_drag(self, editor, pos):
        pass 

# --- Paste Tool ---
class PasteTool(BaseTool):
    def __init__(self):
        super().__init__("Paste")

    def _apply_paste_sprite(self, editor, sprite_editor, top_left_grid_pos):
        """Pastes the editor's copy_buffer onto the sprite_editor frame."""
        if not editor.copy_buffer:
            print("Paste Error: Copy buffer is empty.")
            return

        start_x, start_y = top_left_grid_pos
        for (rel_x, rel_y), color in editor.copy_buffer.items():
            abs_x = start_x + rel_x
            abs_y = start_y + rel_y
            # Check bounds before attempting to draw
            if 0 <= abs_x < config.NATIVE_SPRITE_RESOLUTION[0] and 0 <= abs_y < config.NATIVE_SPRITE_RESOLUTION[1]:
                # Only paste non-transparent pixels.
                if color[3] > 0:
                    sprite_editor.draw_pixel((abs_x, abs_y), color)
        print("Pasted selection.")
        # Paste mode typically allows multiple pastes until cancelled/switched
        # We might not want to deactivate immediately after one click.
        # This depends on desired UX. For now, clicking just pastes once.

    def _apply_paste_background(self, editor, background_surface, top_left_screen_pos):
        """Pastes the editor's copy_buffer onto the background frame."""
        print("Background Paste - Not Implemented Yet")
        # TODO: Implement background paste logic
        # Needs to handle zoom/pan for positioning
        # Needs to handle potentially different data in copy_buffer (if BG copy is added)
        pass

    def handle_click(self, editor, pos):
        if not editor.copy_buffer:
             print("Cannot paste: Copy buffer is empty.")
             editor.tool_manager.set_active_tool('draw') # Switch back to draw if buffer empty
             return
             
        if editor.edit_mode in ['monster', 'tile']:
            sprite_editor = editor._get_sprite_editor_at_pos(pos)
            if sprite_editor:
                grid_pos = sprite_editor.get_grid_position(pos)
                if grid_pos:
                    self._apply_paste_sprite(editor, sprite_editor, grid_pos)
                    # Optional: Deactivate paste mode after one paste? 
                    # editor.tool_manager.set_active_tool('draw') 
        elif editor.edit_mode == 'background' and editor.canvas_rect and editor.current_background:
             if editor.canvas_rect.collidepoint(pos):
                 self._apply_paste_background(editor, editor.current_background, pos)
                 # Optional: Deactivate paste mode after one paste?
                 # editor.tool_manager.set_active_tool('draw') 

    # Drag usually doesn't make sense for paste
    def handle_drag(self, editor, pos):
        pass


# --- Tool Manager ---
class ToolManager:
    def __init__(self, editor):
        self.editor = editor
        self.tools = {
            'draw': DrawTool(),
            'fill': FillTool(),    # <<< Add FillTool
            'paste': PasteTool(),   # <<< Add PasteTool
            # 'select': SelectionTool() # Selection might be managed differently
        }
        self.active_tool_name = 'draw' # Default tool
        self.active_tool = self.tools[self.active_tool_name]
        self.active_tool.activate(self.editor)

    def set_active_tool(self, tool_name):
        if tool_name in self.tools and tool_name != self.active_tool_name:
            if self.active_tool:
                self.active_tool.deactivate(self.editor)
            
            self.active_tool_name = tool_name
            self.active_tool = self.tools[tool_name]
            self.active_tool.activate(self.editor)
            print(f"Switched to {tool_name} tool") # Debug
            # Reset specific editor modes when switching tools
            # (This logic might need refinement based on tool interactions)
            self.editor.eraser_mode = False
            self.editor.fill_mode = False 
            self.editor.paste_mode = False
            if self.editor.mode == 'select': # Exit select mode if switching tool
                self.editor.mode = 'draw' 
                self.editor.selection.active = False
                self.editor.selection.selecting = False

    def handle_click(self, pos):
        if self.active_tool:
            # Need to pass the editor instance to the tool method
            self.active_tool.handle_click(self.editor, pos)

    def handle_drag(self, pos):
        if self.active_tool:
            # Need to pass the editor instance to the tool method
            self.active_tool.handle_drag(self.editor, pos)



================================================
File: src/editor/undo_redo_manager.py
================================================




================================================
File: src/overworld/__init__.py
================================================
"""Overworld package."""



================================================
File: src/overworld/map_editor.py
================================================
import json
import math
import os
import random
import subprocess
import sys
from typing import Dict, List, Optional, Tuple

import pygame

from src.core import config
from src.core.tileset import TileDefinition, TileSet, list_tileset_files, NPCSprite
from src.overworld.overworld import load_tileset_images
from src.overworld.state import (
    CellOverride,
    Connection,
    EntityDef,
    MapData,
    MapLayer,
    TriggerDef,
)

# Basic colors for UI
PANEL_BG = (40, 40, 50)
PANEL_TEXT = (235, 235, 235)
HIGHLIGHT = (90, 160, 255)

PALETTE_WIDTH = 220
INSPECTOR_WIDTH = 280
CANVAS_MARGIN = 8
TOOLBAR_HEIGHT = 110


def prompt_text(screen: pygame.Surface, font: pygame.font.Font, message: str, default: str = "") -> Optional[str]:
    """Blocking text input prompt rendered over the editor."""
    input_text = default
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return None
            if event.type == pygame.KEYDOWN:
                if event.key in (pygame.K_RETURN, pygame.K_KP_ENTER):
                    return input_text
                if event.key == pygame.K_ESCAPE:
                    return None
                if event.key == pygame.K_BACKSPACE:
                    input_text = input_text[:-1]
                else:
                    if event.unicode:
                        input_text += event.unicode

        overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))
        lines = [
            message,
            "> " + input_text,
            "Enter to confirm, Esc to cancel",
        ]
        for idx, line in enumerate(lines):
            surf = font.render(line, True, PANEL_TEXT)
            rect = surf.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2 + idx * 24))
            screen.blit(surf, rect)
        pygame.display.flip()
        clock.tick(30)


def clamp(value: float, minimum: float, maximum: float) -> float:
    return max(minimum, min(maximum, value))


class MapEditor:
    def __init__(self, map_path: Optional[str] = None) -> None:
        pygame.init()
        self.screen = pygame.display.set_mode((config.EDITOR_WIDTH, config.EDITOR_HEIGHT))
        pygame.display.set_caption("Overworld Map Editor")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(config.DEFAULT_FONT, 16)
        self.font_small = pygame.font.Font(config.DEFAULT_FONT, 13)

        self.map = self._load_initial_map(map_path)
        self.tileset = self._load_tileset(self.map.tileset_id)
        self.tile_images = load_tileset_images(self.tileset, self.map.tile_size)
        self._ensure_all_npc_frames()

        self.mode = "tiles"  # tiles, entities, triggers, connections, overrides
        self.tool = "brush"  # brush, fill, rect, line, erase, eyedropper
        self.active_layer = "ground"
        self.selected_tile = self.tileset.tiles[0].id if self.tileset and self.tileset.tiles else None
        self.selected_npc = self.tileset.npcs[0].id if self.tileset and self.tileset.npcs else None
        self.palette_mode = "tiles"
        self.status_message = "Loaded map."
        self.zoom = 1.0
        self.camera = [0.0, 0.0]
        self.dragging = False
        self.drag_start: Optional[Tuple[int, int]] = None
        self.line_start: Optional[Tuple[int, int]] = None
        self.hover_cell: Optional[Tuple[int, int]] = None
        self.selected_entity: Optional[EntityDef] = None
        self.selected_trigger: Optional[TriggerDef] = None
        self.selected_connection: Optional[Connection] = None
        self.help_mode = False
        self.tool_button_rects: List[Tuple[pygame.Rect, str]] = []
        self.mode_button_rects: List[Tuple[pygame.Rect, str]] = []
        self.layer_button_rects: List[Tuple[pygame.Rect, str]] = []
        self.help_button_rect: Optional[pygame.Rect] = None
        self.world_view_button_rect: Optional[pygame.Rect] = None
        self.add_button_rects: List[Tuple[pygame.Rect, str]] = []
        self.palette_tab_rects: List[Tuple[pygame.Rect, str]] = []
        self.new_map_button_rect: Optional[pygame.Rect] = None

        self.history: List[MapData] = []
        self.redo_stack: List[MapData] = []

    # Loading helpers ------------------------------------------------------
    def _load_initial_map(self, map_path: Optional[str]) -> MapData:
        if map_path and os.path.exists(map_path):
            return MapData.load(map_path)
        default_path = os.path.join(config.MAP_DIR, "demo_tiles.json")
        if os.path.exists(default_path):
            return MapData.load(default_path)
        return MapData(
            map_id="new_map",
            name="New Map",
            version="1.0.0",
            tile_size=config.OVERWORLD_TILE_SIZE,
            dimensions=(config.OVERWORLD_GRID_WIDTH, config.OVERWORLD_GRID_HEIGHT),
            tileset_id=config.DEFAULT_TILESET_ID,
            layers=[
                MapLayer(
                    name="ground",
                    tiles=[[None for _ in range(config.OVERWORLD_GRID_WIDTH)] for _ in range(config.OVERWORLD_GRID_HEIGHT)],
                ),
                MapLayer(
                    name="overlay",
                    tiles=[[None for _ in range(config.OVERWORLD_GRID_WIDTH)] for _ in range(config.OVERWORLD_GRID_HEIGHT)],
                ),
            ],
            connections=[],
            entities=[],
            triggers=[],
            overrides={},
        )

    def _load_tileset(self, tileset_id: str) -> Optional[TileSet]:
        path = os.path.join(config.TILESET_DIR, f"{tileset_id}.json")
        if os.path.exists(path):
            return TileSet.load(path)
        available = list_tileset_files()
        if available:
            return TileSet.load(available[0])
        return None

    # Undo/redo ------------------------------------------------------------
    def push_history(self):
        self.history.append(self.map.clone())
        # Limit history size to avoid large memory use
        if len(self.history) > 30:
            self.history.pop(0)
        self.redo_stack.clear()

    def undo(self):
        if not self.history:
            return
        previous = self.history.pop()
        self.redo_stack.append(self.map.clone())
        self.map = previous
        self.status_message = "Undo."

    def redo(self):
        if not self.redo_stack:
            return
        next_state = self.redo_stack.pop()
        self.history.append(self.map.clone())
        self.map = next_state
        self.status_message = "Redo."

    # Event handling -------------------------------------------------------
    def run(self) -> None:
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False
                    self._handle_key(event)
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    self._handle_mouse_down(event)
                elif event.type == pygame.MOUSEBUTTONUP:
                    self._handle_mouse_up(event)
                elif event.type == pygame.MOUSEMOTION:
                    self._handle_mouse_motion(event)

            self._draw()
            pygame.display.flip()
            self.clock.tick(config.FPS)

        pygame.quit()

    def _handle_key(self, event: pygame.event.Event) -> None:
        mods = pygame.key.get_mods()
        ctrl = mods & pygame.KMOD_CTRL
        if ctrl and event.key == pygame.K_s:
            self._save_map()
            return
        if ctrl and event.key == pygame.K_o:
            self._load_map_prompt()
            return
        if ctrl and event.key == pygame.K_z:
            self.undo()
            return
        if ctrl and event.key == pygame.K_y:
            self.redo()
            return

        if event.key == pygame.K_1:
            self.active_layer = "ground"
        elif event.key == pygame.K_2:
            self.active_layer = "overlay"
        elif event.key == pygame.K_b:
            self.tool = "brush"
        elif event.key == pygame.K_f:
            self.tool = "fill"
        elif event.key == pygame.K_r:
            self.tool = "rect"
        elif event.key == pygame.K_l:
            self.tool = "line"
        elif event.key == pygame.K_e:
            self.tool = "erase"
        elif event.key == pygame.K_i:
            self.tool = "eyedropper"
        elif event.key == pygame.K_t:
            self.mode = "tiles"
        elif event.key == pygame.K_n:
            self.mode = "entities"
        elif event.key == pygame.K_g:
            self.mode = "triggers"
        elif event.key == pygame.K_c:
            self.mode = "connections"
        elif event.key == pygame.K_o:
            self.mode = "overrides"
        elif event.key in (pygame.K_EQUALS, pygame.K_PLUS, pygame.K_KP_PLUS, pygame.K_RIGHTBRACKET):
            self.zoom = clamp(self.zoom + 0.1, 0.5, 3.0)
        elif event.key in (pygame.K_MINUS, pygame.K_UNDERSCORE, pygame.K_KP_MINUS, pygame.K_LEFTBRACKET):
            self.zoom = clamp(self.zoom - 0.1, 0.5, 3.0)
        elif event.key == pygame.K_a and self.mode == "entities" and self.hover_cell:
            self._add_entity(self.hover_cell)
        elif event.key == pygame.K_a and self.mode == "triggers" and self.hover_cell:
            self._add_trigger(self.hover_cell)
        elif event.key == pygame.K_a and self.mode == "connections" and self.hover_cell:
            self._add_connection(self.hover_cell)
        elif event.key == pygame.K_m:
            self._edit_metadata()

    def _handle_mouse_down(self, event: pygame.event.Event) -> None:
        if event.button == 1:
            if self._handle_help_or_buttons(event.pos):
                return
            if self._palette_rect().collidepoint(event.pos):
                self._handle_palette_click(event.pos)
                return
        keys = pygame.key.get_pressed()
        if event.button == 2 or (event.button == 1 and keys[pygame.K_SPACE]):
            self.dragging = True
            self.drag_start = event.pos
            return
        if event.button == 1:
            cell = self._cell_from_mouse(event.pos)
            if cell:
                self._apply_primary_action(cell)
        if event.button == 3:
            cell = self._cell_from_mouse(event.pos)
            if cell:
                self._apply_secondary_action(cell)

    def _handle_mouse_up(self, event: pygame.event.Event) -> None:
        if event.button == 2 or (event.button == 1 and self.dragging):
            self.dragging = False
            self.drag_start = None
        if self.tool in ("rect", "line") and self.line_start and event.button == 1:
            cell = self._cell_from_mouse(event.pos)
            if cell:
                self._apply_shape(self.line_start, cell)
            self.line_start = None

    def _handle_mouse_motion(self, event: pygame.event.Event) -> None:
        if self.dragging and self.drag_start:
            dx = event.pos[0] - self.drag_start[0]
            dy = event.pos[1] - self.drag_start[1]
            self.camera[0] -= dx
            self.camera[1] -= dy
            self.drag_start = event.pos
        else:
            self.hover_cell = self._cell_from_mouse(event.pos)

    def _handle_help_or_buttons(self, pos: Tuple[int, int]) -> bool:
        # Help toggle
        if self.help_button_rect and self.help_button_rect.collidepoint(pos):
            self.help_mode = not self.help_mode
            self.status_message = "Help mode on: click a control to learn more." if self.help_mode else "Help mode off."
            return True
        # Tool buttons
        for rect, key in self.tool_button_rects + self.mode_button_rects + self.layer_button_rects + self.add_button_rects:
            if rect.collidepoint(pos):
                if self.help_mode:
                    self.status_message = self._tooltip_for(key)
                else:
                    if key in ("brush", "fill", "rect", "line", "erase", "eyedropper"):
                        self.tool = key
                    elif key in ("tiles", "entities", "triggers", "connections", "overrides"):
                        self.mode = key
                    elif key in ("ground", "overlay"):
                        self.active_layer = key
                    elif key == "add_tile":
                        self._add_tile()
                    elif key == "add_npc":
                        self._add_npc()
                return True
        for rect, key in self.palette_tab_rects:
            if rect.collidepoint(pos):
                self.palette_mode = key
                self.status_message = f"Palette: {key}"
                return True
        if self.new_map_button_rect and self.new_map_button_rect.collidepoint(pos):
            if self.help_mode:
                self.status_message = self._tooltip_for("new_map")
            else:
                self._new_map_dialog()
            return True
        if self.world_view_button_rect and self.world_view_button_rect.collidepoint(pos):
            if self.help_mode:
                self.status_message = self._tooltip_for("world_view")
            else:
                self._open_world_view()
            return True
        return False

    # Coordinate helpers ---------------------------------------------------
    def _canvas_rect(self) -> pygame.Rect:
        top = CANVAS_MARGIN + TOOLBAR_HEIGHT
        return pygame.Rect(
            PALETTE_WIDTH + CANVAS_MARGIN,
            top,
            self.screen.get_width() - PALETTE_WIDTH - INSPECTOR_WIDTH - CANVAS_MARGIN * 2,
            self.screen.get_height() - top - CANVAS_MARGIN,
        )

    def _palette_rect(self) -> pygame.Rect:
        return pygame.Rect(0, 0, PALETTE_WIDTH, self.screen.get_height())

    def _cell_from_mouse(self, pos: Tuple[int, int]) -> Optional[Tuple[int, int]]:
        canvas = self._canvas_rect()
        if not canvas.collidepoint(pos):
            return None
        tile_px = int(self.map.tile_size * self.zoom)
        world_x = (pos[0] - canvas.x) + self.camera[0]
        world_y = (pos[1] - canvas.y) + self.camera[1]
        x = int(world_x // tile_px)
        y = int(world_y // tile_px)
        if not self.map.in_bounds(x, y):
            return None
        return x, y

    # Actions --------------------------------------------------------------
    def _apply_primary_action(self, cell: Tuple[int, int]) -> None:
        if self.mode == "tiles":
            if self.tool in ("rect", "line"):
                self.line_start = cell
                return
            if self.tool == "fill":
                self.push_history()
                self._flood_fill(cell, self.selected_tile)
            elif self.tool == "eyedropper":
                tile = self.map.get_tile(self.active_layer, cell[0], cell[1])
                if tile:
                    self.selected_tile = tile
            else:
                self.push_history()
                self._set_tile(cell, self.selected_tile)
        elif self.mode == "entities":
            entities = self.map.find_entities_at(cell[0], cell[1])
            if entities:
                self._select_entity(cell)
            else:
                self._place_entity(cell)
        elif self.mode == "triggers":
            self._select_trigger(cell)
        elif self.mode == "connections":
            if self._select_connection(cell):
                return
            self._add_connection(cell)
        elif self.mode == "overrides":
            self.push_history()
            self._cycle_override(cell)

    def _apply_secondary_action(self, cell: Tuple[int, int]) -> None:
        mods = pygame.key.get_mods()
        if self.mode == "tiles":
            tile = self.map.get_tile(self.active_layer, cell[0], cell[1])
            if tile and not (mods & pygame.KMOD_SHIFT):
                self._open_art_editor("tile", tile)
                return
            self.push_history()
            self._set_tile(cell, None)
        elif self.mode == "entities":
            entities = self.map.find_entities_at(cell[0], cell[1])
            if entities and not (mods & pygame.KMOD_SHIFT):
                self._open_art_editor("npc", entities[0].sprite_id)
                return
            if entities:
                self.push_history()
                self.map.entities.remove(entities[0])
                self.status_message = f"Removed entity {entities[0].id}"
        elif self.mode == "overrides":
            self.push_history()
            self.map.overrides.pop(cell, None)

    def _apply_shape(self, start: Tuple[int, int], end: Tuple[int, int]) -> None:
        self.push_history()
        if self.tool == "rect":
            x1, y1 = start
            x2, y2 = end
            for y in range(min(y1, y2), max(y1, y2) + 1):
                for x in range(min(x1, x2), max(x1, x2) + 1):
                    self._set_tile((x, y), self.selected_tile)
        elif self.tool == "line":
            for x, y in self._bresenham_line(start, end):
                self._set_tile((x, y), self.selected_tile)

    def _set_tile(self, cell: Tuple[int, int], tile_id: Optional[str]) -> None:
        x, y = cell
        self.map.set_tile(self.active_layer, x, y, tile_id)

    def _flood_fill(self, start: Tuple[int, int], new_tile: Optional[str]) -> None:
        layer = self.map.layer(self.active_layer)
        if not layer:
            return
        width, height = self.map.width, self.map.height
        target = layer.tiles[start[1]][start[0]]
        if target == new_tile:
            return
        stack = [start]
        while stack:
            x, y = stack.pop()
            if not (0 <= x < width and 0 <= y < height):
                continue
            if layer.tiles[y][x] != target:
                continue
            layer.tiles[y][x] = new_tile
            stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])

    def _cycle_override(self, cell: Tuple[int, int]) -> None:
        existing = self.map.get_override(cell[0], cell[1]) or CellOverride()
        current = existing.walkable
        if current is None:
            existing.walkable = False
        elif current is False:
            existing.walkable = True
        else:
            existing.walkable = None
        # Toggle spawn flag with Shift
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            if "spawn" in existing.flags:
                existing.flags.remove("spawn")
            else:
                existing.flags.append("spawn")
        if existing.walkable is None and not existing.flags:
            self.map.overrides.pop(cell, None)
        else:
            self.map.set_override(cell[0], cell[1], existing)

    def _select_entity(self, cell: Tuple[int, int]) -> None:
        entities = self.map.find_entities_at(cell[0], cell[1])
        self.selected_entity = entities[0] if entities else None
        if self.selected_entity:
            self.status_message = f"Selected entity {self.selected_entity.id}"

    def _place_entity(self, cell: Tuple[int, int]) -> None:
        npc_id = self.selected_npc
        if not npc_id:
            self.status_message = "Select an NPC first."
            return
        counter = len(self.map.entities) + 1
        entity_id = f"npc_{counter}"
        entity = EntityDef(
            id=entity_id,
            type="npc",
            name=entity_id,
            sprite_id=npc_id,
            position={"x": cell[0], "y": cell[1]},
            facing="down",
            collision=True,
        )
        self.push_history()
        self.map.entities.append(entity)
        self.selected_entity = entity
        self.status_message = f"Placed NPC {npc_id} at {cell[0]},{cell[1]}"

    def _select_trigger(self, cell: Tuple[int, int]) -> None:
        triggers = self.map.find_triggers_at(cell[0], cell[1], None)
        self.selected_trigger = triggers[0] if triggers else None
        if self.selected_trigger:
            self.status_message = f"Selected trigger {self.selected_trigger.id}"

    def _select_connection(self, cell: Tuple[int, int]) -> bool:
        connection = self.map.portal_at(cell[0], cell[1])
        if not connection:
            direction = None
            x, y = cell
            if x == 0:
                direction = "left"
            elif x == self.map.width - 1:
                direction = "right"
            elif y == 0:
                direction = "up"
            elif y == self.map.height - 1:
                direction = "down"
            if direction:
                connection = self.map.connection_for_edge(direction)
        self.selected_connection = connection
        if connection:
            self.status_message = f"Selected connection {connection.id}"
            return True
        return False

    def _add_entity(self, cell: Tuple[int, int]) -> None:
        base_id = prompt_text(self.screen, self.font, "Entity id:", "entity_1")
        if not base_id:
            return
        name = prompt_text(self.screen, self.font, "Entity name:", base_id)
        sprite_id = prompt_text(self.screen, self.font, "Sprite id:", "npc")
        dialog = prompt_text(self.screen, self.font, "Dialog (comma separated for multiple lines):", "")
        dialog_value = dialog.split(",") if dialog else []
        entity = EntityDef(
            id=base_id,
            type="npc",
            name=name or base_id,
            sprite_id=sprite_id or "",
            position={"x": cell[0], "y": cell[1]},
            facing="down",
            collision=True,
            dialog=dialog_value if dialog_value else None,
        )
        self.push_history()
        self.map.entities.append(entity)
        self.selected_entity = entity
        self.status_message = f"Added entity {entity.id}"

    def _add_trigger(self, cell: Tuple[int, int]) -> None:
        trig_id = prompt_text(self.screen, self.font, "Trigger id:", "trigger_1")
        if not trig_id:
            return
        trig_type = prompt_text(self.screen, self.font, "Type (onEnter/onInteract):", "onEnter") or "onEnter"
        action_text = prompt_text(self.screen, self.font, "Action JSON (default showText):", "")
        actions = [{"kind": "showText", "text": "Hello"}]
        if action_text:
            try:
                parsed = json.loads(action_text)
                if isinstance(parsed, list):
                    actions = parsed
                elif isinstance(parsed, dict):
                    actions = [parsed]
            except json.JSONDecodeError:
                pass
        trigger = TriggerDef(
            id=trig_id,
            type=trig_type,
            position={"x": cell[0], "y": cell[1]},
            actions=actions,
            repeatable=True,
        )
        self.push_history()
        self.map.triggers.append(trigger)
        self.selected_trigger = trigger
        self.status_message = f"Added trigger {trigger.id}"

    def _add_connection(self, cell: Tuple[int, int]) -> None:
        x, y = cell
        is_edge = x == 0 or y == 0 or x == self.map.width - 1 or y == self.map.height - 1
        conn_id = prompt_text(self.screen, self.font, "Connection id:", "conn_1")
        if not conn_id:
            return
        target_map = prompt_text(self.screen, self.font, "Target map id:", "map_id")
        if not target_map:
            return
        spawn_x = prompt_text(self.screen, self.font, "Spawn x:", "0")
        spawn_y = prompt_text(self.screen, self.font, "Spawn y:", "0")
        facing = prompt_text(self.screen, self.font, "Facing (optional):", "")
        try:
            spawn = {"x": int(spawn_x or 0), "y": int(spawn_y or 0)}
        except ValueError:
            spawn = {"x": 0, "y": 0}
        if is_edge:
            direction = "left" if x == 0 else "right" if x == self.map.width - 1 else "up" if y == 0 else "down"
            connection = Connection(
                id=conn_id,
                type="edge",
                from_ref=direction,
                to={"mapId": target_map, "spawn": spawn, "facing": facing or None},
                condition=None,
                extra={},
            )
        else:
            connection = Connection(
                id=conn_id,
                type="portal",
                from_ref={"x": x, "y": y},
                to={"mapId": target_map, "spawn": spawn, "facing": facing or None},
                condition=None,
                extra={},
            )
        self.push_history()
        self.map.connections.append(connection)
        self.selected_connection = connection
        self.status_message = f"Added connection {connection.id}"

    # Drawing --------------------------------------------------------------
    def _draw(self) -> None:
        self.screen.fill((20, 20, 25))
        self._draw_toolbar()
        self._draw_palette()
        self._draw_inspector()
        self._draw_canvas()
        self._draw_status()

    def _draw_palette(self) -> None:
        panel = pygame.Rect(0, 0, PALETTE_WIDTH, self.screen.get_height())
        pygame.draw.rect(self.screen, PANEL_BG, panel)
        # Tabs
        self.palette_tab_rects = []
        tab_y = 8
        for idx, (label, key) in enumerate([("Tiles", "tiles"), ("NPCs", "npcs")]):
            rect = pygame.Rect(10 + idx * 70, tab_y, 64, 24)
            active = self.palette_mode == key
            pygame.draw.rect(self.screen, HIGHLIGHT if active else config.GRAY_DARK, rect, 2 if active else 1)
            text = self.font_small.render(label, True, PANEL_TEXT)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)
            self.palette_tab_rects.append((rect, key))

        if not self.tileset:
            return

        if self.palette_mode == "tiles":
            self._draw_tile_palette(panel)
        else:
            self._draw_npc_palette(panel)

        # Action buttons
        self.add_button_rects = []
        btn_y = panel.height - 120
        for label, key in (("Add Tile", "add_tile"), ("Add NPC", "add_npc")):
            rect = pygame.Rect(10, btn_y, PALETTE_WIDTH - 20, 28)
            pygame.draw.rect(self.screen, HIGHLIGHT if key == "add_tile" else config.GRAY_DARK, rect, 1)
            text = self.font_small.render(label, True, PANEL_TEXT)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)
            self.add_button_rects.append((rect, key))
            btn_y += 36

    def _handle_palette_click(self, pos: Tuple[int, int]) -> None:
        if not self.tileset:
            return
        # Tab click handled elsewhere
        if self.palette_mode == "tiles":
            tile_px = 48
            padding = 8
            local_x, local_y = pos[0], pos[1]
            local_y -= 40
            if local_y >= 0:
                col = local_x // (tile_px + padding)
                row = local_y // (tile_px + padding)
                idx = int(row * 3 + col)
                if 0 <= idx < len(self.tileset.tiles):
                    self.selected_tile = self.tileset.tiles[idx].id
                    self.status_message = f"Selected tile {self.selected_tile}"
        else:
            # NPC list rows
            start_y = 40
            row_height = 36
            idx = (pos[1] - start_y) // row_height
            if 0 <= idx < len(self.tileset.npcs):
                npc = self.tileset.npcs[idx]
                self.selected_npc = npc.id
                self.status_message = f"Selected NPC {npc.id}"

        for rect, key in self.add_button_rects:
            if rect.collidepoint(pos):
                if self.help_mode:
                    self.status_message = self._tooltip_for(key)
                elif key == "add_tile":
                    self._add_tile()
                elif key == "add_npc":
                    self._add_npc()

    def _draw_inspector(self) -> None:
        panel = pygame.Rect(self.screen.get_width() - INSPECTOR_WIDTH, 0, INSPECTOR_WIDTH, self.screen.get_height())
        pygame.draw.rect(self.screen, PANEL_BG, panel)
        lines = [
            f"Mode: {self.mode}",
            f"Tool: {self.tool}",
            f"Layer: {self.active_layer}",
            f"Tile: {self.selected_tile or 'None'}",
            f"Map: {self.map.id} {self.map.width}x{self.map.height}",
            f"Tileset: {self.map.tileset_id}",
            f"Zoom: {self.zoom:.2f}",
        ]
        y = 10
        for line in lines:
            surf = self.font.render(line, True, PANEL_TEXT)
            self.screen.blit(surf, (panel.x + 10, y))
            y += 22

        y += 10
        if self.hover_cell:
            hx, hy = self.hover_cell
            hover_lines = [
                f"Hover: {hx},{hy}",
                f"Ground: {self.map.get_tile('ground', hx, hy)}",
                f"Overlay: {self.map.get_tile('overlay', hx, hy)}",
            ]
            ov = self.map.get_override(hx, hy)
            if ov:
                hover_lines.append(f"Override walkable={ov.walkable} flags={','.join(ov.flags)}")
            entities = self.map.find_entities_at(hx, hy)
            if entities:
                hover_lines.append(f"Entity: {entities[0].id}")
            triggers = self.map.find_triggers_at(hx, hy, None)
            if triggers:
                hover_lines.append(f"Trigger: {triggers[0].id}")
            portal = self.map.portal_at(hx, hy)
            if portal:
                hover_lines.append(f"Portal: {portal.id}")
            for line in hover_lines:
                surf = self.font_small.render(line, True, PANEL_TEXT)
                self.screen.blit(surf, (panel.x + 10, y))
                y += 18

        y += 10
        self.screen.blit(self.font.render("Shortcuts", True, PANEL_TEXT), (panel.x + 10, y))
        y += 20
        shortcuts = [
            "1/2: layer",
            "B/F/R/L/E/I: tools",
            "T/N/G/C/O: modes",
            "Ctrl+S: Save",
            "Ctrl+O: Load",
            "Ctrl+Z/Y: Undo/Redo",
            "+/-: Zoom",
            "A: add (mode)",
        ]
        for sc in shortcuts:
            surf = self.font_small.render(sc, True, PANEL_TEXT)
            self.screen.blit(surf, (panel.x + 10, y))
            y += 16

    def _draw_canvas(self) -> None:
        canvas = self._canvas_rect()
        pygame.draw.rect(self.screen, config.GRAY_DARK, canvas)
        tile_px = int(self.map.tile_size * self.zoom)
        start_x = int(self.camera[0] // tile_px)
        start_y = int(self.camera[1] // tile_px)
        offset_x = -(self.camera[0] - start_x * tile_px) + canvas.x
        offset_y = -(self.camera[1] - start_y * tile_px) + canvas.y
        visible_x = canvas.width // tile_px + 2
        visible_y = canvas.height // tile_px + 2

        ground_layers = [layer for layer in self.map.layers if layer.name != "overlay"]
        overlay_layers = [layer for layer in self.map.layers if layer.name == "overlay"]

        for y in range(visible_y):
            map_y = start_y + y
            if map_y >= self.map.height or map_y < 0:
                continue
            for x in range(visible_x):
                map_x = start_x + x
                if map_x >= self.map.width or map_x < 0:
                    continue
                dest_x = offset_x + x * tile_px
                dest_y = offset_y + y * tile_px
                rect = pygame.Rect(dest_x, dest_y, tile_px, tile_px)
                for layer in ground_layers:
                    tile_id = layer.tiles[map_y][map_x]
                    self._blit_tile(tile_id, rect, tile_px)
                for entity in self.map.find_entities_at(map_x, map_y):
                    if entity.hidden:
                        continue
                    pygame.draw.rect(self.screen, (120, 200, 255), rect.inflate(-4, -4))
                    label = self.font_small.render(entity.id, True, config.BLACK)
                    self.screen.blit(label, (rect.x + 2, rect.y + 2))
                for trigger in self.map.find_triggers_at(map_x, map_y, None):
                    pygame.draw.circle(self.screen, (255, 220, 80), rect.center, max(4, tile_px // 8))
                portal = self.map.portal_at(map_x, map_y)
                if portal:
                    pygame.draw.circle(self.screen, (80, 255, 120), rect.center, max(5, tile_px // 6), 2)
                for layer in overlay_layers:
                    tile_id = layer.tiles[map_y][map_x]
                    self._blit_tile(tile_id, rect, tile_px)
                pygame.draw.rect(self.screen, config.BLACK, rect, 1)

        if self.hover_cell:
            hx, hy = self.hover_cell
            if self.map.in_bounds(hx, hy):
                dest_x = offset_x + (hx - start_x) * tile_px
                dest_y = offset_y + (hy - start_y) * tile_px
                rect = pygame.Rect(dest_x, dest_y, tile_px, tile_px)
                pygame.draw.rect(self.screen, HIGHLIGHT, rect, 2)

    def _blit_tile(self, tile_id: Optional[str], rect: pygame.Rect, tile_px: int) -> None:
        if tile_id is None:
            return
        img_entry = self.tile_images.get(tile_id)
        if img_entry and img_entry.get("frames"):
            frame = img_entry["frames"][0]
            frame_scaled = pygame.transform.scale(frame, (tile_px, tile_px))
            self.screen.blit(frame_scaled, rect)
        else:
            pygame.draw.rect(self.screen, config.GRAY_MEDIUM, rect)

    def _draw_status(self) -> None:
        bar_rect = pygame.Rect(PALETTE_WIDTH, self.screen.get_height() - 24, self.screen.get_width() - PALETTE_WIDTH - INSPECTOR_WIDTH, 24)
        pygame.draw.rect(self.screen, PANEL_BG, bar_rect)
        text = self.font_small.render(self.status_message, True, PANEL_TEXT)
        self.screen.blit(text, (bar_rect.x + 6, bar_rect.y + 4))

    def _draw_toolbar(self) -> None:
        toolbar = pygame.Rect(
            PALETTE_WIDTH + CANVAS_MARGIN,
            CANVAS_MARGIN,
            self.screen.get_width() - PALETTE_WIDTH - INSPECTOR_WIDTH - CANVAS_MARGIN * 2,
            TOOLBAR_HEIGHT - 10,
        )
        pygame.draw.rect(self.screen, PANEL_BG, toolbar)
        self.tool_button_rects = []
        self.mode_button_rects = []
        self.layer_button_rects = []
        start_x = toolbar.x + 10
        y = toolbar.y + 8
        tool_right_reserved = 260  # space for world/new/help buttons
        btn_width = 86

        def draw_button(label: str, key: str, collection: List[Tuple[pygame.Rect, str]]) -> None:
            nonlocal start_x, y
            rect = pygame.Rect(start_x, y, btn_width, 26)
            if collection is self.tool_button_rects and start_x + rect.width > toolbar.right - tool_right_reserved:
                start_x = toolbar.x + 10
                y += 30
                rect.topleft = (start_x, y)
            active = (
                (collection is self.tool_button_rects and self.tool == key)
                or (collection is self.mode_button_rects and self.mode == key)
                or (collection is self.layer_button_rects and self.active_layer == key)
            )
            pygame.draw.rect(self.screen, HIGHLIGHT if active else config.GRAY_DARK, rect, 2 if active else 1)
            text = self.font_small.render(label, True, PANEL_TEXT)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)
            collection.append((rect, key))
            start_x += rect.width + 8

        # Tool row
        for label, key in [("Brush", "brush"), ("Fill", "fill"), ("Rect", "rect"), ("Line", "line"), ("Erase", "erase"), ("Eye", "eyedropper")]:
            draw_button(label, key, self.tool_button_rects)

        # Mode row
        start_x = toolbar.x + 10
        y += 30
        for label, key in [("Tiles", "tiles"), ("Entities", "entities"), ("Triggers", "triggers"), ("Connect", "connections"), ("Overrides", "overrides")]:
            draw_button(label, key, self.mode_button_rects)

        # Layer row
        start_x = toolbar.x + 10
        y += 30
        for label, key in [("Ground", "ground"), ("Overlay", "overlay")]:
            draw_button(label, key, self.layer_button_rects)

        # Help toggle and new map buttons on right
        self.help_button_rect = pygame.Rect(toolbar.right - 80, toolbar.y + 8, 70, 26)
        self.new_map_button_rect = pygame.Rect(toolbar.right - 160, toolbar.y + 8, 70, 26)
        self.world_view_button_rect = pygame.Rect(toolbar.right - 240, toolbar.y + 8, 70, 26)
        pygame.draw.rect(self.screen, (200, 150, 60) if self.help_mode else config.GRAY_DARK, self.help_button_rect, 0)
        label = "Help?" if not self.help_mode else "Help On"
        text = self.font_small.render(label, True, PANEL_TEXT)
        text_rect = text.get_rect(center=self.help_button_rect.center)
        self.screen.blit(text, text_rect)

        pygame.draw.rect(self.screen, HIGHLIGHT, self.new_map_button_rect, 1)
        text = self.font_small.render("New Map", True, PANEL_TEXT)
        text_rect = text.get_rect(center=self.new_map_button_rect.center)
        self.screen.blit(text, text_rect)

        pygame.draw.rect(self.screen, HIGHLIGHT, self.world_view_button_rect, 1)
        text = self.font_small.render("World", True, PANEL_TEXT)
        text_rect = text.get_rect(center=self.world_view_button_rect.center)
        self.screen.blit(text, text_rect)

    def _tooltip_for(self, key: str) -> str:
        tips = {
            "brush": "Brush: paint the selected tile on a single cell.",
            "fill": "Fill: flood-fill the active layer starting from the clicked cell.",
            "rect": "Rect: drag to fill a rectangle with the selected tile.",
            "line": "Line: drag to draw a straight line of the selected tile.",
            "erase": "Erase: clear the tile from the active layer.",
            "eyedropper": "Eyedropper: pick the tile under the cursor.",
            "tiles": "Tiles mode: edit ground/overlay tiles.",
            "entities": "Entities mode: select or add NPC/object entries.",
            "triggers": "Triggers mode: select or add onEnter/onInteract triggers.",
            "connections": "Connections mode: add portals or edge transfers between maps.",
            "overrides": "Overrides mode: toggle walkable/spawn flags per cell.",
            "ground": "Ground layer: base tiles the player walks on.",
            "overlay": "Overlay layer: decorative tiles drawn above entities.",
            "add_tile": "Add a new tile to the tileset with autogenerated placeholder art.",
            "add_npc": "Add a new NPC sprite to the tileset with autogenerated frames.",
            "new_map": "Create a new map and optionally connect it to the current map.",
            "world_view": "Open world view to arrange maps, zoom, and auto-connect edges.",
        }
        return tips.get(key, "No help available.")

    def _add_tile(self) -> None:
        if not self.tileset:
            self.status_message = "No tileset loaded."
            return
        new_id = prompt_text(self.screen, self.font, "New tile id:", "tile_new")
        if not new_id:
            return
        name = prompt_text(self.screen, self.font, "Tile name:", new_id) or new_id
        filename = f"{new_id}.png"
        color = [random.randint(50, 230) for _ in range(3)] + [255]
        tile = TileDefinition(
            id=new_id,
            name=name,
            filename=filename,
            frames=[filename],
            frame_duration_ms=200,
            properties={"walkable": True, "color": color},
        )
        self.tileset.add_or_update_tile(tile)
        self.tileset.save()
        self.tileset.ensure_assets()
        self.tile_images = load_tileset_images(self.tileset, self.map.tile_size)
        self.selected_tile = new_id
        self.status_message = f"Added tile '{new_id}' (auto-colored)."

    def _add_npc(self) -> None:
        if not self.tileset:
            self.status_message = "No tileset loaded."
            return
        new_id = prompt_text(self.screen, self.font, "New NPC id:", "npc_new")
        if not new_id:
            return
        name = prompt_text(self.screen, self.font, "NPC name:", new_id) or new_id
        color = [random.randint(50, 230) for _ in range(3)] + [255]
        npc = NPCSprite(
            id=new_id,
            name=name,
            frame_duration_ms=200,
            states=self._build_default_npc_states(new_id),
        )
        self.tileset.add_or_update_npc(npc)
        self.tileset.save()
        self.tileset.ensure_assets()
        self.selected_npc = new_id
        self.status_message = f"Added NPC '{new_id}' with placeholder art."

    # Save/load ------------------------------------------------------------
    def _save_map(self) -> None:
        if not self.tileset:
            self.status_message = "Cannot save: no tileset."
            return
        errors, warnings = self.map.validate(self.tileset)
        if errors:
            self.status_message = f"Validation failed: {errors[0]}"
            return
        self.map.save()
        self.status_message = "Map saved."

    def _load_map_prompt(self) -> None:
        new_id = prompt_text(self.screen, self.font, "Map id to load:", self.map.id)
        if not new_id:
            return
        path = os.path.join(config.MAP_DIR, f"{new_id}.json")
        if not os.path.exists(path):
            self.status_message = f"Map {new_id} not found."
            return
        self.map = MapData.load(path)
        self.tileset = self._load_tileset(self.map.tileset_id)
        self.tile_images = load_tileset_images(self.tileset, self.map.tile_size)
        if self.tileset and self.tileset.tiles:
            self.selected_tile = self.tileset.tiles[0].id
        if self.tileset and self.tileset.npcs:
            self.selected_npc = self.tileset.npcs[0].id
        self.status_message = f"Loaded map {self.map.id}"

    def _edit_metadata(self) -> None:
        new_id = prompt_text(self.screen, self.font, "Map id:", self.map.id) or self.map.id
        new_name = prompt_text(self.screen, self.font, "Map name:", self.map.name) or self.map.name
        new_tileset = prompt_text(self.screen, self.font, "Tileset id:", self.map.tileset_id) or self.map.tileset_id
        width_text = prompt_text(self.screen, self.font, "Width:", str(self.map.width))
        height_text = prompt_text(self.screen, self.font, "Height:", str(self.map.height))
        tile_size_text = prompt_text(self.screen, self.font, "Tile size:", str(self.map.tile_size))
        music_id = prompt_text(self.screen, self.font, "Music id (optional):", self.map.music_id or "") or None
        try:
            new_width = max(1, int(width_text or self.map.width))
            new_height = max(1, int(height_text or self.map.height))
            new_tile_size = max(1, int(tile_size_text or self.map.tile_size))
        except ValueError:
            self.status_message = "Invalid dimensions."
            return
        self.push_history()
        self.map.id = new_id
        self.map.name = new_name
        self.map.tileset_id = new_tileset
        self.map.width = new_width
        self.map.height = new_height
        self.map.tile_size = new_tile_size
        self.map.music_id = music_id
        # Trim overrides out of bounds
        for coord in list(self.map.overrides.keys()):
            if not self.map.in_bounds(*coord):
                self.map.overrides.pop(coord, None)
        self.map._normalize_layers()
        self.tileset = self._load_tileset(self.map.tileset_id)
        self.tile_images = load_tileset_images(self.tileset, self.map.tile_size)
        if self.tileset and self.tileset.tiles:
            self.selected_tile = self.tileset.tiles[0].id
        self.status_message = "Updated metadata."

    # Utility --------------------------------------------------------------
    def _bresenham_line(self, start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
        x1, y1 = start
        x2, y2 = end
        points = []
        dx = abs(x2 - x1)
        dy = -abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        err = dx + dy
        while True:
            points.append((x1, y1))
            if x1 == x2 and y1 == y2:
                break
            e2 = 2 * err
            if e2 >= dy:
                err += dy
                x1 += sx
            if e2 <= dx:
                err += dx
                y1 += sy
        return points

    # Palette helpers -----------------------------------------------------
    def _draw_tile_palette(self, panel: pygame.Rect) -> None:
        tile_px = 48
        padding = 8
        for idx, tile in enumerate(self.tileset.tiles):
            col = idx % 3
            row = idx // 3
            x = 10 + col * (tile_px + padding)
            y = 40 + row * (tile_px + padding)
            rect = pygame.Rect(x, y, tile_px, tile_px)
            selected = tile.id == self.selected_tile
            pygame.draw.rect(self.screen, HIGHLIGHT if selected else config.GRAY_DARK, rect, 2 if selected else 1)
            img_entry = self.tile_images.get(tile.id)
            if img_entry and img_entry.get("frames"):
                frame = img_entry["frames"][0]
                frame_scaled = pygame.transform.scale(frame, (tile_px - 6, tile_px - 6))
                self.screen.blit(frame_scaled, (x + 3, y + 3))
            else:
                pygame.draw.rect(self.screen, config.GRAY_MEDIUM, rect.inflate(-6, -6))
            label = self.font_small.render(tile.id, True, PANEL_TEXT)
            self.screen.blit(label, (x, y + tile_px + 2))

    def _draw_npc_palette(self, panel: pygame.Rect) -> None:
        start_y = 40
        row_h = 36
        for idx, npc in enumerate(self.tileset.npcs):
            rect = pygame.Rect(10, start_y + idx * row_h, PALETTE_WIDTH - 20, row_h - 6)
            selected = npc.id == self.selected_npc
            pygame.draw.rect(self.screen, HIGHLIGHT if selected else config.GRAY_DARK, rect, 2 if selected else 1)
            label = self.font_small.render(npc.id, True, PANEL_TEXT)
            self.screen.blit(label, (rect.x + 8, rect.y + 8))

    # NPC helpers ---------------------------------------------------------
    def _build_default_npc_states(self, npc_id: str) -> Dict[str, Dict[str, List[str]]]:
        states: Dict[str, Dict[str, List[str]]] = {}
        for state in ["standing", "walking"]:
            states[state] = {}
            for angle in ["south", "west", "east", "north"]:
                states[state][angle] = [f"{npc_id}_{state}_{angle}.png"]
        return states

    def _ensure_npc_frames(self, npc: NPCSprite) -> None:
        desired_states = self._build_default_npc_states(npc.id)
        updated = False
        for state, angles in desired_states.items():
            npc.states.setdefault(state, {})
            for angle, frames in angles.items():
                if not npc.states[state].get(angle):
                    npc.states[state][angle] = frames
                    updated = True
        if updated:
            self.tileset.add_or_update_npc(npc)
            self.tileset.save()
            self.tileset.ensure_assets()

    def _ensure_all_npc_frames(self) -> None:
        if not self.tileset:
            return
        for npc in self.tileset.npcs:
            self._ensure_npc_frames(npc)

    # External editor -----------------------------------------------------
    def _open_art_editor(self, kind: str, identifier: str) -> None:
        editor_path = os.path.join(config.PROJECT_ROOT, "pixle_art_editor.py")
        if not os.path.exists(editor_path):
            self.status_message = "Pixel editor entrypoint not found."
            return
        if kind == "npc" and self.tileset:
            for npc in self.tileset.npcs:
                if npc.id == identifier:
                    self._ensure_npc_frames(npc)
                    break
        try:
            subprocess.Popen([sys.executable, editor_path])
            self.status_message = f"Opening pixel editor for {kind} '{identifier}'..."
        except Exception as e:
            self.status_message = f"Failed to open editor: {e}"

    def _open_world_view(self) -> None:
        world_view_path = os.path.join(config.PROJECT_ROOT, "src", "overworld", "world_view.py")
        if not os.path.exists(world_view_path):
            self.status_message = "World view not found."
            return
        try:
            subprocess.Popen([sys.executable, world_view_path])
            self.status_message = "Opened world view."
        except Exception as e:
            self.status_message = f"Failed to open world view: {e}"

    # Map creation --------------------------------------------------------
    def _new_map_dialog(self) -> None:
        new_id = prompt_text(self.screen, self.font, "New map id:", f"{self.map.id}_new")
        if not new_id:
            return
        width = prompt_text(self.screen, self.font, "Width:", str(self.map.width)) or str(self.map.width)
        height = prompt_text(self.screen, self.font, "Height:", str(self.map.height)) or str(self.map.height)
        try:
            w = max(1, int(width))
            h = max(1, int(height))
        except ValueError:
            self.status_message = "Invalid width/height."
            return
        connect = prompt_text(self.screen, self.font, "Connect to current? (edge/portal/none):", "none") or "none"
        new_map = MapData(
            map_id=new_id,
            name=new_id,
            version="1.0.0",
            tile_size=self.map.tile_size,
            dimensions=(w, h),
            tileset_id=self.map.tileset_id,
            layers=[
                MapLayer(name="ground", tiles=[[None for _ in range(w)] for _ in range(h)]),
                MapLayer(name="overlay", tiles=[[None for _ in range(w)] for _ in range(h)]),
            ],
            connections=[],
            entities=[],
            triggers=[],
            overrides={},
        )
        if connect.lower() in ("edge", "portal"):
            self._connect_new_map(new_map, connect.lower())
        new_map.save()
        self.map = new_map
        self.tile_images = load_tileset_images(self.tileset, self.map.tile_size)
        self.status_message = f"Created and opened new map '{new_id}'."

    def _connect_new_map(self, new_map: MapData, mode: str) -> None:
        if mode == "edge":
            direction = prompt_text(self.screen, self.font, "Direction from current (north/east/south/west):", "north") or "north"
            spawn_x = int(prompt_text(self.screen, self.font, "New map spawn x:", "1") or 1)
            spawn_y = int(prompt_text(self.screen, self.font, "New map spawn y:", "1") or 1)
            facing = prompt_text(self.screen, self.font, "Facing on arrival:", "south") or "south"
            conn_id = f"{direction}_to_{new_map.id}"
            connection = Connection(
                id=conn_id,
                type="edge",
                from_ref=direction,
                to={"mapId": new_map.id, "spawn": {"x": spawn_x, "y": spawn_y}, "facing": facing},
                condition=None,
                extra={},
            )
            self.map.connections.append(connection)
            # Reciprocal
            opposite = {"north": "south", "south": "north", "east": "west", "west": "east"}.get(direction, "south")
            new_map.connections.append(
                Connection(
                    id=f"{opposite}_to_{self.map.id}",
                    type="edge",
                    from_ref=opposite,
                    to={"mapId": self.map.id, "spawn": {"x": self.map.spawn_point()[0], "y": self.map.spawn_point()[1]}, "facing": direction},
                    condition=None,
                    extra={},
                )
            )
        elif mode == "portal":
            portal_x = int(prompt_text(self.screen, self.font, "Portal X on current map:", "0") or 0)
            portal_y = int(prompt_text(self.screen, self.font, "Portal Y on current map:", "0") or 0)
            spawn_x = int(prompt_text(self.screen, self.font, "New map spawn x:", "1") or 1)
            spawn_y = int(prompt_text(self.screen, self.font, "New map spawn y:", "1") or 1)
            conn_id = f"portal_to_{new_map.id}"
            connection = Connection(
                id=conn_id,
                type="portal",
                from_ref={"x": portal_x, "y": portal_y},
                to={"mapId": new_map.id, "spawn": {"x": spawn_x, "y": spawn_y}},
                condition=None,
                extra={},
            )
            self.map.connections.append(connection)
            new_map.connections.append(
                Connection(
                    id=f"portal_to_{self.map.id}",
                    type="portal",
                    from_ref={"x": 0, "y": 0},
                    to={"mapId": self.map.id, "spawn": {"x": self.map.spawn_point()[0], "y": self.map.spawn_point()[1]}},
                    condition=None,
                    extra={},
                )
            )


def main() -> None:
    map_path = sys.argv[1] if len(sys.argv) > 1 else None
    editor = MapEditor(map_path)
    editor.run()


if __name__ == "__main__":
    main()



================================================
File: src/overworld/overworld.py
================================================
import os
import sys
from typing import Dict, Optional

import pygame

from src.core import config
from src.core.tileset import TileSet
from src.overworld.state import MapData, MapLayer, OverworldSession


class OverworldAudio:
    """Simple audio controller that respects map music ids."""

    def __init__(self) -> None:
        if not pygame.mixer.get_init():
            try:
                pygame.mixer.init()
            except pygame.error:
                # Audio not available; fall back to silent controller
                self.disabled = True
                return
        self.disabled = False

    def play_music(self, music_id: Optional[str]) -> None:
        if self.disabled or not music_id:
            return
        path = os.path.join(config.SONGS_DIR, music_id)
        if not os.path.splitext(path)[1]:
            # Try common extensions if not provided
            for ext in (".mp3", ".ogg", ".wav"):
                candidate = f"{path}{ext}"
                if os.path.exists(candidate):
                    path = candidate
                    break
        if not os.path.exists(path):
            return
        try:
            pygame.mixer.music.load(path)
            pygame.mixer.music.play(-1)
        except pygame.error:
            return

    def stop_music(self) -> None:
        if self.disabled:
            return
        pygame.mixer.music.stop()

    def play_sound(self, sound_id: Optional[str]) -> None:
        if self.disabled or not sound_id:
            return
        path = os.path.join(config.SOUNDS_DIR, sound_id)
        if not os.path.exists(path):
            return
        try:
            sound = pygame.mixer.Sound(path)
            sound.play()
        except pygame.error:
            return


def load_tileset_images(tileset: Optional[TileSet], tile_size: int) -> Dict[str, Dict[str, object]]:
    """Load tile images (all frames) from disk and scale them to the tileset size."""
    images: Dict[str, Dict[str, object]] = {}
    if not tileset:
        return images
    for tile in tileset.tiles:
        frames = []
        frame_names = tile.frames or [tile.filename]
        total_frames = len(frame_names)
        for idx in range(total_frames):
            path = tileset.tile_image_path(tile, idx)
            try:
                surf = pygame.image.load(path).convert_alpha()
            except pygame.error:
                surf = pygame.Surface((tile_size, tile_size), pygame.SRCALPHA)
                color = tile.properties.get("color", [170, 170, 170, 255])
                pygame.draw.rect(surf, color, surf.get_rect())
            if surf.get_size() != (tile_size, tile_size):
                surf = pygame.transform.scale(surf, (tile_size, tile_size))
            frames.append(surf)
        images[tile.id] = {"frames": frames, "duration": max(1, tile.frame_duration_ms)}
    return images


def wrap_text(text: str, font: pygame.font.Font, max_width: int) -> list:
    words = text.split()
    if not words:
        return []
    lines = []
    current = ""
    for word in words:
        candidate = f"{current} {word}".strip()
        if font.size(candidate)[0] <= max_width:
            current = candidate
        else:
            if current:
                lines.append(current)
            current = word
    if current:
        lines.append(current)
    return lines


def draw_message(screen: pygame.Surface, font: pygame.font.Font, message: str) -> None:
    if not message:
        return
    padding = 10
    box_height = 90
    box_width = screen.get_width() - (padding * 2)
    box_rect = pygame.Rect(padding, screen.get_height() - box_height - padding, box_width, box_height)
    overlay = pygame.Surface((box_rect.width, box_rect.height), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 200))
    screen.blit(overlay, box_rect.topleft)

    text_area_width = box_rect.width - (padding * 2)
    lines = wrap_text(message, font, text_area_width)
    for i, line in enumerate(lines):
        text_surf = font.render(line, True, config.WHITE)
        screen.blit(text_surf, (box_rect.x + padding, box_rect.y + padding + i * font.get_linesize()))


def draw_world(screen: pygame.Surface, session: OverworldSession, tile_images: Dict[str, Dict[str, object]], font_small: pygame.font.Font, debug: bool = False) -> None:
    tile_size = session.map.tile_size
    screen.fill(config.OVERWORLD_BG_COLOR)

    map_pixel_w = session.map.width * tile_size
    map_pixel_h = session.map.height * tile_size
    screen_w, screen_h = screen.get_size()

    center_x = session.player.x * tile_size + tile_size // 2
    center_y = session.player.y * tile_size + tile_size // 2
    camera_x = max(0, min(center_x - screen_w // 2, map_pixel_w - screen_w))
    camera_y = max(0, min(center_y - screen_h // 2, map_pixel_h - screen_h))

    start_tile_x = int(camera_x // tile_size)
    start_tile_y = int(camera_y // tile_size)
    offset_x = -(camera_x - start_tile_x * tile_size)
    offset_y = -(camera_y - start_tile_y * tile_size)

    visible_tiles_x = screen_w // tile_size + 2
    visible_tiles_y = screen_h // tile_size + 2

    ground_layers = [layer for layer in session.map.layers if layer.name != "overlay"]
    overlay_layers = [layer for layer in session.map.layers if layer.name == "overlay"]

    def _draw_tile(layer_tiles, map_x, map_y, dest_x, dest_y) -> None:
        tile_id = layer_tiles[map_y][map_x]
        if tile_id is None:
            return
        tile_entry = tile_images.get(tile_id)
        dest_rect = pygame.Rect(dest_x, dest_y, tile_size, tile_size)
        if isinstance(tile_entry, dict) and tile_entry.get("frames"):
            frames = tile_entry["frames"]
            duration = max(1, tile_entry.get("duration", 200))
            frame_idx = (pygame.time.get_ticks() // duration) % len(frames)
            screen.blit(frames[frame_idx], dest_rect)
        elif tile_entry:
            screen.blit(tile_entry, dest_rect)
        else:
            pygame.draw.rect(screen, config.GRAY_MEDIUM, dest_rect)

    for y in range(visible_tiles_y):
        map_y = start_tile_y + y
        if map_y >= session.map.height:
            continue
        for x in range(visible_tiles_x):
            map_x = start_tile_x + x
            if map_x >= session.map.width:
                continue
            dest_x = offset_x + x * tile_size
            dest_y = offset_y + y * tile_size
            for layer in ground_layers:
                _draw_tile(layer.tiles, map_x, map_y, dest_x, dest_y)

    # Entities and player (depth sort by y)
    renderables = []
    for entity in session.map.entities:
        if entity.hidden:
            continue
        renderables.append(("entity", entity.position.get("x", 0), entity.position.get("y", 0), entity))
    renderables.append(("player", session.player.x, session.player.y, session.player))
    renderables.sort(key=lambda item: item[2])

    for kind, map_x, map_y, obj in renderables:
        dest_x = offset_x + (map_x - start_tile_x) * tile_size
        dest_y = offset_y + (map_y - start_tile_y) * tile_size
        if dest_x + tile_size < 0 or dest_y + tile_size < 0 or dest_x > screen_w or dest_y > screen_h:
            continue
        rect = pygame.Rect(dest_x, dest_y, tile_size, tile_size)
        if kind == "player":
            pygame.draw.rect(screen, config.RED, rect)
            pygame.draw.rect(screen, config.BLACK, rect, 2)
        else:
            pygame.draw.rect(screen, config.BLUE, rect)
            pygame.draw.rect(screen, config.BLACK, rect, 1)
            if getattr(obj, "name", None):
                label = font_small.render(str(obj.name)[:4], True, config.WHITE)
                screen.blit(label, (rect.x + 2, rect.y + 2))

    # Overlay layers after entities/player
    for y in range(visible_tiles_y):
        map_y = start_tile_y + y
        if map_y >= session.map.height:
            continue
        for x in range(visible_tiles_x):
            map_x = start_tile_x + x
            if map_x >= session.map.width:
                continue
            dest_x = offset_x + x * tile_size
            dest_y = offset_y + y * tile_size
            for layer in overlay_layers:
                _draw_tile(layer.tiles, map_x, map_y, dest_x, dest_y)

    # Grid
    for x in range(visible_tiles_x + 1):
        gx = offset_x + x * tile_size
        pygame.draw.line(screen, config.GRAY_DARK, (gx, 0), (gx, screen_h), 1)
    for y in range(visible_tiles_y + 1):
        gy = offset_y + y * tile_size
        pygame.draw.line(screen, config.GRAY_DARK, (0, gy), (screen_w, gy), 1)

    if debug:
        _draw_debug_overlays(screen, session, start_tile_x, start_tile_y, visible_tiles_x, visible_tiles_y, offset_x, offset_y, tile_size)


def _draw_debug_overlays(screen: pygame.Surface, session: OverworldSession, start_x: int, start_y: int, tiles_x: int, tiles_y: int, offset_x: float, offset_y: float, tile_size: int) -> None:
    screen_w, screen_h = screen.get_size()
    for y in range(tiles_y):
        map_y = start_y + y
        if map_y >= session.map.height:
            continue
        for x in range(tiles_x):
            map_x = start_x + x
            if map_x >= session.map.width:
                continue
            dest_x = offset_x + x * tile_size
            dest_y = offset_y + y * tile_size
            rect = pygame.Rect(dest_x, dest_y, tile_size, tile_size)
            if not session.map.in_bounds(map_x, map_y):
                continue
            if not session._cell_walkable(map_x, map_y):
                overlay = pygame.Surface((tile_size, tile_size), pygame.SRCALPHA)
                overlay.fill((255, 0, 0, 80))
                screen.blit(overlay, rect.topleft)
            triggers = session.map.find_triggers_at(map_x, map_y, None)
            if triggers:
                pygame.draw.circle(screen, config.BLUE, rect.center, max(4, tile_size // 8))
            if session.map.portal_at(map_x, map_y):
                pygame.draw.circle(screen, config.GREEN, rect.center, max(4, tile_size // 6), 1)


def load_default_map() -> MapData:
    if len(sys.argv) > 1:
        target = sys.argv[1]
        if os.path.exists(target):
            return MapData.load(target)
        target_path = os.path.join(config.MAP_DIR, f"{target}.json")
        if os.path.exists(target_path):
            return MapData.load(target)
    default_path = os.path.join(config.MAP_DIR, "demo_tiles.json")
    if os.path.exists(default_path):
        return MapData.load(default_path)
    return MapData(
        map_id="blank",
        name="Blank",
        version="1.0.0",
        tile_size=config.OVERWORLD_TILE_SIZE,
        dimensions=(config.OVERWORLD_GRID_WIDTH, config.OVERWORLD_GRID_HEIGHT),
        tileset_id=config.DEFAULT_TILESET_ID,
        layers=[
            MapLayer(
                name="ground",
                tiles=[[None for _ in range(config.OVERWORLD_GRID_WIDTH)] for _ in range(config.OVERWORLD_GRID_HEIGHT)],
            ),
            MapLayer(
                name="overlay",
                tiles=[[None for _ in range(config.OVERWORLD_GRID_WIDTH)] for _ in range(config.OVERWORLD_GRID_HEIGHT)],
            ),
        ],
        connections=[],
        entities=[],
        triggers=[],
        overrides={},
    )


def main() -> None:
    pygame.init()
    screen = pygame.display.set_mode((config.OVERWORLD_WIDTH, config.OVERWORLD_HEIGHT))
    pygame.display.set_caption("Overworld")
    clock = pygame.time.Clock()

    map_data = load_default_map()
    tileset_path = os.path.join(config.TILESET_DIR, f"{map_data.tileset_id}.json")
    tileset = TileSet.load(tileset_path) if os.path.exists(tileset_path) else None
    tile_images = load_tileset_images(tileset, map_data.tile_size)
    audio = OverworldAudio()
    session = OverworldSession(map_data, tileset=tileset, audio_controller=audio)

    font = pygame.font.Font(config.DEFAULT_FONT, config.OVERWORLD_FONT_SIZE)
    font_small = pygame.font.Font(config.DEFAULT_FONT, 14)
    debug_overlay = False

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False
                elif event.key in (pygame.K_UP, pygame.K_w):
                    session.move("up")
                elif event.key in (pygame.K_DOWN, pygame.K_s):
                    session.move("down")
                elif event.key in (pygame.K_LEFT, pygame.K_a):
                    session.move("left")
                elif event.key in (pygame.K_RIGHT, pygame.K_d):
                    session.move("right")
                elif event.key in (pygame.K_SPACE, pygame.K_RETURN):
                    session.interact()
                elif event.key == pygame.K_r:
                    # Hot reload current map from disk
                    map_data = MapData.load(map_data.id)
                    tileset_path = os.path.join(config.TILESET_DIR, f"{map_data.tileset_id}.json")
                    tileset = TileSet.load(tileset_path) if os.path.exists(tileset_path) else None
                    tile_images = load_tileset_images(tileset, map_data.tile_size)
                    session.set_map(map_data, tileset=tileset)
                elif event.key == pygame.K_F1:
                    debug_overlay = not debug_overlay

        draw_world(screen, session, tile_images, font_small, debug=debug_overlay)
        hud = font_small.render(f"Map: {session.map.id}  Facing: {session.player.facing}", True, config.BLACK)
        screen.blit(hud, (8, 8))
        if session.active_message:
            draw_message(screen, font, session.active_message)

        pygame.display.flip()
        clock.tick(config.FPS)

    pygame.quit()


if __name__ == "__main__":
    main()



================================================
File: src/overworld/state.py
================================================
import copy
import json
import os
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Set, Tuple

from src.core import config
from src.core.tileset import TileSet

DIRECTIONS: Dict[str, Tuple[int, int]] = {
    "up": (0, -1),
    "down": (0, 1),
    "left": (-1, 0),
    "right": (1, 0),
}

OPPOSITE_FACING = {
    "up": "down",
    "down": "up",
    "left": "right",
    "right": "left",
    "north": "south",
    "south": "north",
    "east": "west",
    "west": "east",
}
EDGE_NORMALIZE = {"north": "up", "south": "down", "east": "right", "west": "left"}


@dataclass
class TileBehavior:
    walkable: bool = True
    interaction: Optional[str] = None


@dataclass
class MapLayer:
    name: str
    tiles: List[List[Optional[str]]]


@dataclass
class CellOverride:
    walkable: Optional[bool] = None
    flags: List[str] = field(default_factory=list)
    extra: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Connection:
    id: str
    type: str
    from_ref: Any
    to: Dict[str, Any]
    condition: Optional[Dict[str, Any]] = None
    extra: Dict[str, Any] = field(default_factory=dict)


@dataclass
class EntityDef:
    id: str
    type: str
    name: str
    sprite_id: str
    position: Dict[str, int]
    facing: str = "down"
    collision: bool = True
    dialog: Optional[Any] = None
    dialog_id: Optional[str] = None
    actions: List[Dict[str, Any]] = field(default_factory=list)
    conditions: Dict[str, Any] = field(default_factory=dict)
    properties: Dict[str, Any] = field(default_factory=dict)
    hidden: bool = False
    extra: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TriggerDef:
    id: str
    type: str
    position: Dict[str, Any]
    actions: List[Dict[str, Any]] = field(default_factory=list)
    repeatable: bool = True
    conditions: Dict[str, Any] = field(default_factory=dict)
    extra: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Player:
    x: int
    y: int
    facing: str = "down"


def _copy_tiles(tiles: Iterable[Iterable[Optional[str]]]) -> List[List[Optional[str]]]:
    return [list(row) for row in tiles]


class MapData:
    """Container for map data and helper methods shared by runtime and editor."""

    def __init__(
        self,
        map_id: str,
        name: str,
        version: str,
        tile_size: int,
        dimensions: Tuple[int, int],
        tileset_id: str,
        layers: List[MapLayer],
        connections: List[Connection],
        entities: List[EntityDef],
        triggers: List[TriggerDef],
        overrides: Dict[Tuple[int, int], CellOverride],
        music_id: Optional[str] = None,
        spawn: Optional[Dict[str, int]] = None,
        extra: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.id = map_id
        self.name = name or map_id
        self.version = version or "1.0.0"
        self.tile_size = tile_size or config.OVERWORLD_TILE_SIZE
        self.width, self.height = dimensions
        self.tileset_id = tileset_id or config.DEFAULT_TILESET_ID
        self.layers = layers
        self.connections = connections
        self.entities = entities
        self.triggers = triggers
        self.overrides = overrides
        self.music_id = music_id
        self.spawn = spawn
        self.extra = extra or {}
        self._normalize_layers()

    # Construction helpers -------------------------------------------------
    @classmethod
    def from_dict(cls, raw: Dict[str, Any]) -> "MapData":
        known_keys = {
            "id",
            "name",
            "version",
            "tileSize",
            "dimensions",
            "tilesetId",
            "layers",
            "connections",
            "entities",
            "triggers",
            "overrides",
            "musicId",
            "spawn",
        }
        extra = {k: v for k, v in raw.items() if k not in known_keys}
        dimensions_raw = raw.get("dimensions") or {}
        layers_raw = raw.get("layers", [])
        inferred_width, inferred_height = cls._infer_dimensions(layers_raw)
        width = dimensions_raw.get("width", inferred_width or config.OVERWORLD_GRID_WIDTH)
        height = dimensions_raw.get("height", inferred_height or config.OVERWORLD_GRID_HEIGHT)

        layers: List[MapLayer] = []
        for layer in layers_raw:
            layers.append(
                MapLayer(
                    name=layer.get("name", "layer"),
                    tiles=_copy_tiles(layer.get("tiles", [])),
                )
            )

        if not any(layer.name == "overlay" for layer in layers):
            overlay_tiles = [[None for _ in range(width)] for _ in range(height)]
            layers.append(MapLayer(name="overlay", tiles=overlay_tiles))

        connections: List[Connection] = []
        for connection in raw.get("connections", []) or []:
            conn_extra = {k: v for k, v in connection.items() if k not in {"id", "type", "from", "to", "condition"}}
            connections.append(
                Connection(
                    id=connection.get("id", ""),
                    type=connection.get("type", "edge"),
                    from_ref=connection.get("from"),
                    to=connection.get("to") or {},
                    condition=connection.get("condition"),
                    extra=conn_extra,
                )
            )

        entities: List[EntityDef] = []
        for entity in raw.get("entities", []) or []:
            entity_extra = {
                k: v
                for k, v in entity.items()
                if k
                not in {
                    "id",
                    "type",
                    "name",
                    "spriteId",
                    "position",
                    "facing",
                    "collision",
                    "dialog",
                    "dialogId",
                    "actions",
                    "conditions",
                    "properties",
                    "hidden",
                }
            }
            entities.append(
                EntityDef(
                    id=entity.get("id", ""),
                    type=entity.get("type", "npc"),
                    name=entity.get("name", ""),
                    sprite_id=entity.get("spriteId", ""),
                    position=entity.get("position") or {"x": 0, "y": 0},
                    facing=entity.get("facing", "down"),
                    collision=bool(entity.get("collision", True)),
                    dialog=entity.get("dialog"),
                    dialog_id=entity.get("dialogId"),
                    actions=entity.get("actions", []) or [],
                    conditions=entity.get("conditions", {}) or {},
                    properties=entity.get("properties", {}) or {},
                    hidden=bool(entity.get("hidden", False)),
                    extra=entity_extra,
                )
            )

        triggers: List[TriggerDef] = []
        for trigger in raw.get("triggers", []) or []:
            trigger_extra = {k: v for k, v in trigger.items() if k not in {"id", "type", "position", "actions", "repeatable", "conditions"}}
            triggers.append(
                TriggerDef(
                    id=trigger.get("id", ""),
                    type=trigger.get("type", "onEnter"),
                    position=trigger.get("position") or {},
                    actions=trigger.get("actions", []) or [],
                    repeatable=bool(trigger.get("repeatable", True)),
                    conditions=trigger.get("conditions", {}) or {},
                    extra=trigger_extra,
                )
            )

        overrides: Dict[Tuple[int, int], CellOverride] = {}
        for key, value in (raw.get("overrides") or {}).items():
            try:
                x_str, y_str = key.split(",")
                coord = (int(x_str), int(y_str))
            except Exception:
                continue
            ov_extra = {k: v for k, v in value.items() if k not in {"walkable", "flags"}}
            overrides[coord] = CellOverride(
                walkable=value.get("walkable"),
                flags=list(value.get("flags", []) or []),
                extra=ov_extra,
            )

        return cls(
            map_id=raw.get("id", "map"),
            name=raw.get("name", raw.get("id", "map")),
            version=raw.get("version", "1.0.0"),
            tile_size=raw.get("tileSize") or config.OVERWORLD_TILE_SIZE,
            dimensions=(width, height),
            tileset_id=raw.get("tilesetId") or config.DEFAULT_TILESET_ID,
            layers=layers,
            connections=connections,
            entities=entities,
            triggers=triggers,
            overrides=overrides,
            music_id=raw.get("musicId"),
            spawn=raw.get("spawn"),
            extra=extra,
        )

    @classmethod
    def load(cls, path_or_id: str) -> "MapData":
        if os.path.isfile(path_or_id):
            path = path_or_id
        else:
            path = os.path.join(config.MAP_DIR, f"{path_or_id}.json")
        with open(path, "r") as f:
            raw = json.load(f)
        return cls.from_dict(raw)

    def to_dict(self) -> Dict[str, Any]:
        raw = {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "tileSize": self.tile_size,
            "dimensions": {"width": self.width, "height": self.height},
            "tilesetId": self.tileset_id,
            "layers": [{"name": layer.name, "tiles": _copy_tiles(layer.tiles)} for layer in self.layers],
            "connections": [
                {
                    **{"id": conn.id, "type": conn.type, "from": conn.from_ref, "to": conn.to},
                    **({"condition": conn.condition} if conn.condition is not None else {}),
                    **conn.extra,
                }
                for conn in self.connections
            ],
            "entities": [
                {
                    **{
                        "id": entity.id,
                        "type": entity.type,
                        "name": entity.name,
                        "spriteId": entity.sprite_id,
                        "position": entity.position,
                        "facing": entity.facing,
                        "collision": entity.collision,
                        "dialog": entity.dialog,
                        "dialogId": entity.dialog_id,
                        "actions": entity.actions,
                        "conditions": entity.conditions,
                        "properties": entity.properties,
                        "hidden": entity.hidden,
                    },
                    **entity.extra,
                }
                for entity in self.entities
            ],
            "triggers": [
                {
                    **{
                        "id": trigger.id,
                        "type": trigger.type,
                        "position": trigger.position,
                        "actions": trigger.actions,
                        "repeatable": trigger.repeatable,
                        "conditions": trigger.conditions,
                    },
                    **trigger.extra,
                }
                for trigger in self.triggers
            ],
            "overrides": {
                f"{x},{y}": {
                    **({"walkable": ov.walkable} if ov.walkable is not None else {}),
                    **({"flags": ov.flags} if ov.flags else {}),
                    **ov.extra,
                }
                for (x, y), ov in self.overrides.items()
            },
        }
        if self.music_id is not None:
            raw["musicId"] = self.music_id
        if self.spawn is not None:
            raw["spawn"] = self.spawn
        raw.update(self.extra)
        return raw

    def save(self, path_or_id: Optional[str] = None) -> str:
        if path_or_id is None:
            path = os.path.join(config.MAP_DIR, f"{self.id}.json")
        elif os.path.isdir(path_or_id):
            path = os.path.join(path_or_id, f"{self.id}.json")
        else:
            path = path_or_id
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w") as f:
            json.dump(self.to_dict(), f, indent=2)
        return path

    # Helpers --------------------------------------------------------------
    @staticmethod
    def _infer_dimensions(layers_raw: List[Dict[str, Any]]) -> Tuple[int, int]:
        for layer in layers_raw:
            tiles = layer.get("tiles") or []
            if tiles:
                height = len(tiles)
                width = len(tiles[0]) if tiles[0] else 0
                return width, height
        return 0, 0

    def _normalize_layers(self) -> None:
        """Ensure all layers match map dimensions and fill empty rows/cols with None."""
        for layer in self.layers:
            # Expand rows to map height
            while len(layer.tiles) < self.height:
                layer.tiles.append([None for _ in range(self.width)])
            # Trim extra rows if present
            if len(layer.tiles) > self.height:
                layer.tiles = layer.tiles[: self.height]
            # Normalize each row width
            for y in range(self.height):
                row = layer.tiles[y]
                if len(row) < self.width:
                    row.extend([None] * (self.width - len(row)))
                elif len(row) > self.width:
                    layer.tiles[y] = row[: self.width]

    def clone(self) -> "MapData":
        return copy.deepcopy(self)

    def in_bounds(self, x: int, y: int) -> bool:
        return 0 <= x < self.width and 0 <= y < self.height

    def layer(self, name: str) -> Optional[MapLayer]:
        for layer in self.layers:
            if layer.name == name:
                return layer
        return None

    def get_tile(self, layer_name: str, x: int, y: int) -> Optional[str]:
        layer = self.layer(layer_name)
        if not layer or not self.in_bounds(x, y):
            return None
        return layer.tiles[y][x]

    def set_tile(self, layer_name: str, x: int, y: int, value: Optional[str]) -> None:
        layer = self.layer(layer_name)
        if not layer or not self.in_bounds(x, y):
            return
        layer.tiles[y][x] = value

    def get_override(self, x: int, y: int) -> Optional[CellOverride]:
        return self.overrides.get((x, y))

    def set_override(self, x: int, y: int, override: CellOverride) -> None:
        self.overrides[(x, y)] = override

    def find_entities_at(self, x: int, y: int) -> List[EntityDef]:
        return [entity for entity in self.entities if entity.position.get("x") == x and entity.position.get("y") == y]

    def find_triggers_at(self, x: int, y: int, trigger_type: Optional[str] = None) -> List[TriggerDef]:
        matches: List[TriggerDef] = []
        for trigger in self.triggers:
            if trigger_type and trigger.type != trigger_type:
                continue
            position = trigger.position or {}
            if self._position_matches(position, x, y):
                matches.append(trigger)
        return matches

    def get_connection_by_id(self, connection_id: str) -> Optional[Connection]:
        for connection in self.connections:
            if connection.id == connection_id:
                return connection
        return None

    def connection_for_edge(self, direction: str) -> Optional[Connection]:
        for connection in self.connections:
            if connection.type != "edge":
                continue
            from_ref = connection.from_ref
            normalized = EDGE_NORMALIZE.get(from_ref, from_ref)
            if normalized == direction:
                return connection
        return None

    def portal_at(self, x: int, y: int) -> Optional[Connection]:
        for connection in self.connections:
            if connection.type != "portal":
                continue
            source = connection.from_ref or {}
            if isinstance(source, dict) and source.get("x") == x and source.get("y") == y:
                return connection
        return None

    def spawn_point(self) -> Tuple[int, int]:
        if self.spawn and "x" in self.spawn and "y" in self.spawn:
            return int(self.spawn["x"]), int(self.spawn["y"])
        for (x, y), override in self.overrides.items():
            if "spawn" in override.flags:
                return x, y
        return 0, 0

    @staticmethod
    def _position_matches(position: Dict[str, Any], x: int, y: int) -> bool:
        if not position:
            return False
        if "width" in position and "height" in position:
            px = position.get("x", 0)
            py = position.get("y", 0)
            return px <= x < px + position["width"] and py <= y < py + position["height"]
        return position.get("x") == x and position.get("y") == y

    def validate(self, tileset: Optional[TileSet] = None, known_maps: Optional[Set[str]] = None) -> Tuple[List[str], List[str]]:
        errors: List[str] = []
        warnings: List[str] = []

        if self.width <= 0 or self.height <= 0:
            errors.append("Map dimensions must be greater than zero.")

        for layer in self.layers:
            if len(layer.tiles) != self.height:
                errors.append(f"Layer '{layer.name}' height {len(layer.tiles)} does not match map height {self.height}.")
            for row in layer.tiles:
                if len(row) != self.width:
                    errors.append(f"Layer '{layer.name}' row width mismatch (expected {self.width}).")

        for (x, y) in self.overrides.keys():
            if not self.in_bounds(x, y):
                errors.append(f"Override at ({x},{y}) is out of bounds.")

        for entity in self.entities:
            pos = entity.position or {}
            ex, ey = pos.get("x"), pos.get("y")
            if ex is None or ey is None:
                errors.append(f"Entity '{entity.id}' missing position.")
            elif not self.in_bounds(ex, ey):
                errors.append(f"Entity '{entity.id}' at ({ex},{ey}) is out of bounds.")

        for trigger in self.triggers:
            pos = trigger.position or {}
            if "x" in pos and "y" in pos and not self.in_bounds(pos["x"], pos["y"]):
                errors.append(f"Trigger '{trigger.id}' at ({pos['x']},{pos['y']}) is out of bounds.")

        for connection in self.connections:
            if connection.type == "portal" and isinstance(connection.from_ref, dict):
                px, py = connection.from_ref.get("x"), connection.from_ref.get("y")
                if px is None or py is None:
                    errors.append(f"Connection '{connection.id}' portal missing coordinates.")
                elif not self.in_bounds(px, py):
                    errors.append(f"Connection '{connection.id}' portal at ({px},{py}) is out of bounds.")
            to_target = connection.to or {}
            spawn = to_target.get("spawn") or {}
            if "x" in spawn and "y" in spawn:
                sx, sy = spawn.get("x"), spawn.get("y")
                if sx is None or sy is None:
                    errors.append(f"Connection '{connection.id}' spawn missing coordinates.")
                elif sx < 0 or sy < 0:
                    errors.append(f"Connection '{connection.id}' spawn coordinates must be non-negative.")
            target_map_id = to_target.get("mapId")
            if known_maps is not None and target_map_id and target_map_id not in known_maps:
                warnings.append(f"Connection '{connection.id}' references unknown map '{target_map_id}'.")

        if tileset:
            valid_tile_ids = {tile.id for tile in tileset.tiles}
            for layer in self.layers:
                for y, row in enumerate(layer.tiles):
                    for x, tile_id in enumerate(row):
                        if tile_id is None:
                            continue
                        if tile_id not in valid_tile_ids:
                            errors.append(f"Unknown tile id '{tile_id}' at ({x},{y}) in layer '{layer.name}'.")

        return errors, warnings


class NullAudioController:
    """No-op audio controller usable in tests."""

    def play_music(self, music_id: Optional[str]) -> None:
        return

    def stop_music(self) -> None:
        return

    def play_sound(self, sound_id: Optional[str]) -> None:
        return


class OverworldSession:
    """Runtime controller for overworld logic (movement, triggers, connections)."""

    def __init__(self, map_data: MapData, tileset: Optional[TileSet] = None, audio_controller: Optional[object] = None) -> None:
        self.map: MapData = map_data
        self.tileset: Optional[TileSet] = tileset
        self.tile_behaviors: Dict[str, TileBehavior] = self._build_tile_behaviors(tileset)
        spawn_x, spawn_y = self.map.spawn_point()
        self.player = Player(x=spawn_x, y=spawn_y)
        self.flags: Set[str] = set()
        self.consumed_triggers: Set[str] = set()
        self.message_queue: List[str] = []
        self.audio = audio_controller or NullAudioController()
        self.current_music_id: Optional[str] = None
        self._ensure_music()

    # Map + tile handling --------------------------------------------------
    def _build_tile_behaviors(self, tileset: Optional[TileSet]) -> Dict[str, TileBehavior]:
        behaviors: Dict[str, TileBehavior] = {}
        if not tileset:
            return behaviors
        for tile in tileset.tiles:
            behavior = TileBehavior(
                walkable=bool(tile.properties.get("walkable", True)),
                interaction=tile.properties.get("interaction"),
            )
            behaviors[tile.id] = behavior
        return behaviors

    def set_tileset(self, tileset: TileSet) -> None:
        self.tileset = tileset
        self.tile_behaviors = self._build_tile_behaviors(tileset)

    def set_map(self, map_data: MapData, tileset: Optional[TileSet] = None, spawn_override: Optional[Dict[str, int]] = None, facing: Optional[str] = None) -> None:
        self.map = map_data
        if tileset:
            self.set_tileset(tileset)
        spawn_x, spawn_y = map_data.spawn_point()
        if spawn_override:
            spawn_x, spawn_y = spawn_override.get("x", spawn_x), spawn_override.get("y", spawn_y)
        self.player = Player(x=spawn_x, y=spawn_y, facing=facing or self.player.facing)
        self._ensure_music()

    def _ensure_music(self) -> None:
        if self.map.music_id != self.current_music_id:
            if self.map.music_id is not None:
                self.audio.play_music(self.map.music_id)
            else:
                self.audio.stop_music()
            self.current_music_id = self.map.music_id

    # Message handling -----------------------------------------------------
    def queue_message(self, text: Optional[Any]) -> None:
        if text is None:
            return
        if isinstance(text, list):
            for line in text:
                if line is not None:
                    self.message_queue.append(str(line))
        else:
            self.message_queue.append(str(text))

    @property
    def active_message(self) -> Optional[str]:
        return self.message_queue[0] if self.message_queue else None

    def acknowledge_message(self) -> None:
        if self.message_queue:
            self.message_queue.pop(0)

    # Collision + helpers --------------------------------------------------
    def _cell_walkable(self, x: int, y: int) -> bool:
        if not self.map.in_bounds(x, y):
            return False
        walkable = True
        for layer in self.map.layers:
            tile_id = layer.tiles[y][x]
            if tile_id is None:
                continue
            behavior = self.tile_behaviors.get(tile_id, TileBehavior())
            if not behavior.walkable:
                walkable = False
                break
        override = self.map.get_override(x, y)
        if override and override.walkable is not None:
            walkable = bool(override.walkable)
        for entity in self.map.find_entities_at(x, y):
            if entity.collision and not entity.hidden:
                walkable = False
                break
        return walkable

    def _tile_interaction(self, x: int, y: int) -> Optional[str]:
        if not self.map.in_bounds(x, y):
            return None
        for layer in self.map.layers:
            tile_id = layer.tiles[y][x]
            if tile_id is None:
                continue
            behavior = self.tile_behaviors.get(tile_id)
            if behavior and behavior.interaction:
                return behavior.interaction
        return None

    # Movement + triggers --------------------------------------------------
    def move(self, direction: str) -> bool:
        if direction not in DIRECTIONS:
            raise ValueError(f"Unknown direction: {direction}")
        if self.active_message:
            return False
        dx, dy = DIRECTIONS[direction]
        self.player.facing = direction
        new_x = self.player.x + dx
        new_y = self.player.y + dy

        # Edge connections
        if not self.map.in_bounds(new_x, new_y):
            connection = self.map.connection_for_edge(direction)
            if connection:
                self._execute_connection(connection, attempted_direction=direction)
                return True
            return False

        if not self._cell_walkable(new_x, new_y):
            return False

        self.player.x = new_x
        self.player.y = new_y

        portal = self.map.portal_at(new_x, new_y)
        if portal:
            self._execute_connection(portal, attempted_direction=direction)
            return True

        self._run_triggers_at(new_x, new_y, trigger_type="onEnter")
        return True

    def interact(self) -> Optional[str]:
        if self.active_message:
            self.acknowledge_message()
            return self.active_message

        dx, dy = DIRECTIONS[self.player.facing]
        target_x = self.player.x + dx
        target_y = self.player.y + dy

        entity_ran = False
        entities = self.map.find_entities_at(target_x, target_y)
        if entities:
            self._run_entity_interaction(entities[0])
            entity_ran = True

        self._run_triggers_at(target_x, target_y, trigger_type="onInteract")

        if not self.active_message and not entity_ran:
            interaction_text = self._tile_interaction(target_x, target_y)
            if interaction_text:
                self.queue_message(interaction_text)

        return self.active_message

    # Internal helpers -----------------------------------------------------
    def _conditions_met(self, conditions: Dict[str, Any]) -> bool:
        if not conditions:
            return True
        flags_all = conditions.get("flags") or conditions.get("flagsAll") or []
        flags_any = conditions.get("flagsAny") or []
        flags_not = conditions.get("notFlags") or []
        if flags_all and any(flag not in self.flags for flag in flags_all):
            return False
        if flags_any and not any(flag in self.flags for flag in flags_any):
            return False
        if flags_not and any(flag in self.flags for flag in flags_not):
            return False
        return True

    def _run_entity_interaction(self, entity: EntityDef) -> Optional[str]:
        if entity.hidden or not self._conditions_met(entity.conditions):
            return None
        if entity.actions:
            self._run_actions(entity.actions)
        elif entity.dialog is not None:
            self.queue_message(entity.dialog)
        elif entity.dialog_id:
            self.queue_message(f"[Dialog: {entity.dialog_id}]")
        return self.active_message

    def _run_triggers_at(self, x: int, y: int, trigger_type: str) -> None:
        triggers = self.map.find_triggers_at(x, y, trigger_type)
        for trigger in triggers:
            if not trigger.repeatable and trigger.id in self.consumed_triggers:
                continue
            if not self._conditions_met(trigger.conditions):
                continue
            self._run_actions(trigger.actions)
            if not trigger.repeatable:
                self.consumed_triggers.add(trigger.id)

    def _run_actions(self, actions: List[Dict[str, Any]]) -> None:
        for action in actions or []:
            kind = action.get("kind") or action.get("type")
            if kind == "showText":
                self.queue_message(action.get("text"))
            elif kind == "setFlag":
                flag = action.get("flag")
                if flag:
                    self.flags.add(flag)
            elif kind == "clearFlag":
                flag = action.get("flag")
                if flag and flag in self.flags:
                    self.flags.remove(flag)
            elif kind == "playSound":
                self.audio.play_sound(action.get("soundId") or action.get("id"))
            elif kind == "playMusic":
                self.current_music_id = None
                self.map.music_id = action.get("musicId")
                self._ensure_music()
            elif kind == "stopMusic":
                self.audio.stop_music()
                self.current_music_id = None
            elif kind == "warp":
                target_map = action.get("mapId")
                spawn = action.get("spawn")
                facing = action.get("facing")
                if target_map:
                    self._load_and_set_map(target_map, spawn_override=spawn, facing=facing)
            elif kind == "runConnection":
                conn_id = action.get("connectionId")
                if conn_id:
                    connection = self.map.get_connection_by_id(conn_id)
                    if connection:
                        self._execute_connection(connection, attempted_direction=None, preserve_facing=action.get("preserveFacing", False))
            elif kind == "toggleEntity":
                entity_id = action.get("entityId") or action.get("id")
                if entity_id:
                    self._toggle_entity(entity_id, action)
            elif kind == "toggleTileOverride":
                position = action.get("position") or {}
                self._toggle_override(position, action)
            elif kind == "startBattle":
                opponent = action.get("opponentId") or action.get("battleId") or "Encounter"
                self.queue_message(f"Battle start: {opponent}")

    def _toggle_entity(self, entity_id: str, action: Dict[str, Any]) -> None:
        for entity in self.map.entities:
            if entity.id != entity_id:
                continue
            if "visible" in action:
                entity.hidden = not bool(action.get("visible", True))
            if "hidden" in action:
                entity.hidden = bool(action["hidden"])
            if "collision" in action:
                entity.collision = bool(action["collision"])
            break

    def _toggle_override(self, position: Dict[str, Any], action: Dict[str, Any]) -> None:
        if "x" not in position or "y" not in position:
            return
        x, y = position["x"], position["y"]
        override = self.map.get_override(x, y) or CellOverride()
        if "walkable" in action:
            override.walkable = action["walkable"]
        flags_to_add = action.get("addFlags") or []
        flags_to_remove = action.get("removeFlags") or []
        override.flags = list(set(override.flags + flags_to_add))
        override.flags = [f for f in override.flags if f not in flags_to_remove]
        self.map.set_override(x, y, override)

    def _execute_connection(self, connection: Connection, attempted_direction: Optional[str], preserve_facing: bool = False) -> None:
        target = connection.to or {}
        spawn = target.get("spawn")
        target_map_id = target.get("mapId")
        target_facing = target.get("facing")
        facing = self.player.facing if preserve_facing else target_facing or OPPOSITE_FACING.get(attempted_direction, self.player.facing)
        if target_map_id:
            self._load_and_set_map(target_map_id, spawn_override=spawn, facing=facing)

    def _load_and_set_map(self, map_id: str, spawn_override: Optional[Dict[str, int]], facing: Optional[str]) -> None:
        new_map = MapData.load(map_id)
        tileset_path = os.path.join(config.TILESET_DIR, f"{new_map.tileset_id}.json")
        tileset = TileSet.load(tileset_path) if os.path.exists(tileset_path) else None
        self.set_map(new_map, tileset=tileset, spawn_override=spawn_override, facing=facing)
        self._run_triggers_at(self.player.x, self.player.y, trigger_type="onEnter")



================================================
File: src/overworld/world_view.py
================================================
import json
import os
import sys
from typing import Dict, List, Optional, Tuple
import math

import pygame

# Ensure project root on sys.path when launched directly
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from src.core import config
from src.core.tileset import TileSet
from src.overworld.state import Connection, MapData, MapLayer

LAYOUT_FILE = os.path.join(config.MAP_DIR, "world_layout.json")
AUTO_FLAG = "world"
SNAP_STEP = 1  # tiles
EPS = 0.5


def list_maps() -> List[str]:
    if not os.path.isdir(config.MAP_DIR):
        return []
    return sorted([f[:-5] for f in os.listdir(config.MAP_DIR) if f.endswith(".json")])


def load_layout() -> Dict[str, Dict[str, int]]:
    if not os.path.exists(LAYOUT_FILE):
        return {}
    try:
        with open(LAYOUT_FILE, "r") as f:
            data = json.load(f)
        return data.get("maps", {})
    except Exception:
        return {}


def save_layout(layout: Dict[str, Dict[str, int]]) -> None:
    os.makedirs(config.MAP_DIR, exist_ok=True)
    with open(LAYOUT_FILE, "w") as f:
        json.dump({"maps": layout}, f, indent=2)


def _tile_walkable(map_data: MapData, tileset: Optional[TileSet], x: int, y: int) -> bool:
    x = int(x)
    y = int(y)
    if not map_data.in_bounds(x, y):
        return False
    walkable = True
    for layer in map_data.layers:
        tile_id = layer.tiles[y][x]
        if tile_id is None:
            continue
        if tileset:
            tile_def = next((t for t in tileset.tiles if t.id == tile_id), None)
            if tile_def and tile_def.properties.get("walkable") is False:
                walkable = False
    override = map_data.get_override(x, y)
    if override and override.walkable is not None:
        walkable = override.walkable
    return walkable


def _make_preview(map_data: MapData, tileset: Optional[TileSet]) -> pygame.Surface:
    """Tiny color-coded preview (1px per tile) scaled later."""
    surf = pygame.Surface((max(1, map_data.width), max(1, map_data.height)))
    for y in range(map_data.height):
        for x in range(map_data.width):
            color = (60, 60, 60)
            tile_id = map_data.get_tile("ground", x, y)
            if tileset and tile_id:
                tile_def = next((t for t in tileset.tiles if t.id == tile_id), None)
                if tile_def:
                    color = tuple(tile_def.properties.get("color", (120, 120, 120, 255))[:3])
            if not _tile_walkable(map_data, tileset, x, y):
                color = (80, 40, 40)
            surf.set_at((x, y), color)
    return surf


def _load_map_bundle(map_id: str):
    path = os.path.join(config.MAP_DIR, f"{map_id}.json")
    map_data = MapData.load(path)
    tileset_path = os.path.join(config.TILESET_DIR, f"{map_data.tileset_id}.json")
    tileset = TileSet.load(tileset_path) if os.path.exists(tileset_path) else None
    preview = _make_preview(map_data, tileset)
    return map_data, tileset, preview


class WorldView:
    def __init__(self) -> None:
        pygame.init()
        self.screen = pygame.display.set_mode((1200, 800))
        pygame.display.set_caption("Overworld World View")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(config.DEFAULT_FONT, 16)
        self.font_small = pygame.font.Font(config.DEFAULT_FONT, 12)
        self.zoom = 4.0  # pixels per tile
        self.offset = [100.0, 80.0]
        self.dragging = False
        self.dragging_map: Optional[str] = None
        self.drag_offset = (0.0, 0.0)
        self.mouse_pan = False

        self.layout = load_layout()
        self.maps: Dict[str, MapData] = {}
        self.tilesets: Dict[str, TileSet] = {}
        self.previews: Dict[str, pygame.Surface] = {}
        self._load_maps()

    def _load_maps(self) -> None:
        self.maps.clear()
        self.tilesets.clear()
        self.previews.clear()
        ids = list_maps()
        for idx, map_id in enumerate(ids):
            map_data, tileset, preview = _load_map_bundle(map_id)
            self.maps[map_id] = map_data
            if tileset:
                self.tilesets[map_id] = tileset
            self.previews[map_id] = preview
            self.layout.setdefault(map_id, {"x": idx * (map_data.width + 4), "y": 0})

    def run(self) -> None:
        running = True
        self.manual_src: Optional[str] = None
        self.manual_dst: Optional[str] = None
        self.manual_mode = False
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key in (pygame.K_ESCAPE, pygame.K_q):
                        running = False
                    elif event.key == pygame.K_r:
                        self._load_maps()
                    elif event.key == pygame.K_s:
                        save_layout(self.layout)
                    elif event.key == pygame.K_c:
                        self._auto_connect()
                    elif event.key == pygame.K_p:
                        self.manual_mode = not self.manual_mode
                        self.manual_src = None
                        self.manual_dst = None
                    elif event.key == pygame.K_RETURN and self.manual_src and self.manual_dst:
                        self._create_manual_connection()
                    elif event.key == pygame.K_EQUALS or event.key == pygame.K_PLUS:
                        self.zoom = min(24.0, self.zoom + 0.5)
                    elif event.key == pygame.K_MINUS or event.key == pygame.K_UNDERSCORE:
                        self.zoom = max(1.0, self.zoom - 0.5)
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if event.button == 1:
                        clicked = self._map_at(event.pos)
                        if self.manual_mode:
                            self._handle_manual_click(clicked)
                        elif clicked:
                            self.dragging_map = clicked
                            map_pos = self._map_screen_rect(clicked).topleft
                            self.drag_offset = (event.pos[0] - map_pos[0], event.pos[1] - map_pos[1])
                        else:
                            self.mouse_pan = True
                            self.drag_offset = event.pos
                    elif event.button == 4:
                        self.zoom = min(24.0, self.zoom + 0.5)
                    elif event.button == 5:
                        self.zoom = max(1.0, self.zoom - 0.5)
                elif event.type == pygame.MOUSEBUTTONUP:
                    if event.button == 1:
                        if self.dragging_map:
                            self._snap_map(self.dragging_map)
                        self.dragging_map = None
                        self.mouse_pan = False
                elif event.type == pygame.MOUSEMOTION:
                    if self.dragging_map:
                        mx, my = event.pos
                        rect = self._map_screen_rect(self.dragging_map)
                        dx = mx - rect.x - self.drag_offset[0]
                        dy = my - rect.y - self.drag_offset[1]
                        map_id = self.dragging_map
                        self.layout[map_id]["x"] += dx / self.zoom
                        self.layout[map_id]["y"] += dy / self.zoom
                    elif self.mouse_pan:
                        dx = event.pos[0] - self.drag_offset[0]
                        dy = event.pos[1] - self.drag_offset[1]
                        self.offset[0] += dx
                        self.offset[1] += dy
                        self.drag_offset = event.pos

            self._draw()
            pygame.display.flip()
            self.clock.tick(config.FPS)
        pygame.quit()

    # Drawing --------------------------------------------------------------
    def _draw(self) -> None:
        self.screen.fill((18, 22, 26))
        self._draw_connections()
        # Draw maps
        for map_id, map_data in self.maps.items():
            rect = self._map_screen_rect(map_id)
            preview = self.previews.get(map_id)
            if preview:
                scaled = pygame.transform.scale(preview, rect.size)
                self.screen.blit(scaled, rect)
            pygame.draw.rect(self.screen, (200, 200, 200), rect, 2)
            label = self.font.render(map_id, True, (240, 240, 240))
            self.screen.blit(label, (rect.x + 6, rect.y + 6))
            dims = self.font_small.render(f"{map_data.width}x{map_data.height}", True, (200, 200, 200))
            self.screen.blit(dims, (rect.x + 6, rect.y + 26))

        # HUD
        hud_lines = [
            "World View: drag maps to arrange, wheel to zoom",
            "S: save layout, C: auto-connect, R: reload, Q/Esc: quit",
            f"Zoom: {self.zoom:.1f}px/tile  Maps: {len(self.maps)}",
            "P: manual portal mode (click source, then target, Enter to confirm)",
        ]
        y = 8
        for line in hud_lines:
            surf = self.font.render(line, True, (230, 230, 230))
            self.screen.blit(surf, (10, y))
            y += 22
        if self.manual_mode:
            status = "Manual: click source map" if not self.manual_src else "Manual: click target map" if not self.manual_dst else "Manual: press Enter to create portal"
            note = self.font_small.render(status, True, (200, 220, 255))
            self.screen.blit(note, (10, y + 4))

    def _draw_connections(self) -> None:
        seen = set()
        for map_id, map_data in self.maps.items():
            for conn in map_data.connections:
                target_id = conn.to.get("mapId") if conn.to else None
                if not target_id or target_id not in self.maps:
                    continue
                key = (map_id, conn.id, target_id)
                if key in seen:
                    continue
                seen.add(key)
                if conn.type == "edge":
                    start = self._edge_point(map_id, conn.from_ref or "right")
                    end = self._edge_point(target_id, conn.to.get("facing") or "left", opposite=True)
                    pygame.draw.line(self.screen, (120, 200, 255), start, end, 2)
                    pygame.draw.circle(self.screen, (200, 200, 80), end, 5)
                elif conn.type == "portal":
                    start = self._cell_point(map_id, conn.from_ref or {})
                    end = self._cell_point(target_id, conn.to.get("spawn") or {})
                    pygame.draw.line(self.screen, (200, 140, 255), start, end, 2)
                    pygame.draw.circle(self.screen, (200, 200, 80), end, 5)

    def _map_screen_rect(self, map_id: str) -> pygame.Rect:
        map_data = self.maps[map_id]
        pos = self.layout.get(map_id, {"x": 0, "y": 0})
        x = pos.get("x", 0) * self.zoom + self.offset[0]
        y = pos.get("y", 0) * self.zoom + self.offset[1]
        w = map_data.width * self.zoom
        h = map_data.height * self.zoom
        return pygame.Rect(int(x), int(y), int(w), int(h))

    def _edge_point(self, map_id: str, direction: str, opposite: bool = False) -> Tuple[int, int]:
        rect = self._map_screen_rect(map_id)
        if direction in ("left", "west"):
            return (rect.left, rect.centery)
        if direction in ("right", "east"):
            return (rect.right, rect.centery)
        if direction in ("up", "north"):
            return (rect.centerx, rect.top)
        return (rect.centerx, rect.bottom)

    def _cell_point(self, map_id: str, pos: Dict[str, int]) -> Tuple[int, int]:
        rect = self._map_screen_rect(map_id)
        x = rect.x + int(pos.get("x", 0)) * self.zoom + self.zoom / 2
        y = rect.y + int(pos.get("y", 0)) * self.zoom + self.zoom / 2
        return (int(x), int(y))

    def _map_at(self, pos: Tuple[int, int]) -> Optional[str]:
        for map_id in reversed(list(self.maps.keys())):
            if self._map_screen_rect(map_id).collidepoint(pos):
                return map_id
        return None

    def _snap_map(self, map_id: str) -> None:
        pos = self.layout.get(map_id, {"x": 0, "y": 0})
        pos["x"] = round(pos.get("x", 0) / SNAP_STEP) * SNAP_STEP
        pos["y"] = round(pos.get("y", 0) / SNAP_STEP) * SNAP_STEP
        self.layout[map_id] = pos

    # Auto connection generation ------------------------------------------
    def _auto_connect(self) -> None:
        # Load fresh copies to avoid sharing mutable references
        bundles = {mid: _load_map_bundle(mid) for mid in self.maps.keys()}
        updated: Dict[str, MapData] = {}
        for map_id, (map_data, tileset, _) in bundles.items():
            # drop previous auto connections
            map_data.connections = [c for c in map_data.connections if c.extra.get("auto") != AUTO_FLAG]
            updated[map_id] = map_data

        # Build adjacency based on layout
        ids = sorted(updated.keys())
        for i, a_id in enumerate(ids):
            a_map = updated[a_id]
            a_pos = self.layout.get(a_id, {"x": 0, "y": 0})
            for b_id in ids[i + 1 :]:
                b_map = updated[b_id]
                b_pos = self.layout.get(b_id, {"x": 0, "y": 0})
                self._maybe_connect_pair(a_id, a_map, bundles[a_id][1], a_pos, b_id, b_map, bundles[b_id][1], b_pos)

        # Save + refresh runtime copies
        for map_id, map_data in updated.items():
            map_data.save()
            self.maps[map_id] = map_data
        save_layout(self.layout)

    def _maybe_connect_pair(
        self,
        a_id: str,
        a_map: MapData,
        a_tileset: Optional[TileSet],
        a_pos: Dict[str, float],
        b_id: str,
        b_map: MapData,
        b_tileset: Optional[TileSet],
        b_pos: Dict[str, float],
    ) -> None:
        ax, ay = a_pos.get("x", 0), a_pos.get("y", 0)
        bx, by = b_pos.get("x", 0), b_pos.get("y", 0)

        # Horizontal adjacency (A right to B left)
        if abs((ax + a_map.width) - bx) < EPS:
            overlap_y0 = max(ay, by)
            overlap_y1 = min(ay + a_map.height, by + b_map.height)
            start = int(math.ceil(overlap_y0))
            end = int(math.floor(overlap_y1))
            for gy in range(start, end):
                ay_local = int(round(gy - ay))
                by_local = int(round(gy - by))
                if _tile_walkable(a_map, a_tileset, a_map.width - 1, ay_local) and _tile_walkable(b_map, b_tileset, 0, by_local):
                    self._add_auto_edge(
                        a_map,
                        "right",
                        b_id,
                        {"x": 0, "y": by_local},
                        facing="right",
                        y_tag=ay_local,
                    )
                    self._add_auto_edge(
                        b_map,
                        "left",
                        a_id,
                        {"x": a_map.width - 1, "y": ay_local},
                        facing="left",
                        y_tag=by_local,
                    )
        # Vertical adjacency (A bottom to B top)
        if abs((ay + a_map.height) - by) < EPS:
            overlap_x0 = max(ax, bx)
            overlap_x1 = min(ax + a_map.width, bx + b_map.width)
            start = int(math.ceil(overlap_x0))
            end = int(math.floor(overlap_x1))
            for gx in range(start, end):
                ax_local = int(round(gx - ax))
                bx_local = int(round(gx - bx))
                if _tile_walkable(a_map, a_tileset, ax_local, a_map.height - 1) and _tile_walkable(b_map, b_tileset, bx_local, 0):
                    self._add_auto_edge(
                        a_map,
                        "down",
                        b_id,
                        {"x": bx_local, "y": 0},
                        facing="down",
                        x_tag=ax_local,
                    )
                    self._add_auto_edge(
                        b_map,
                        "up",
                        a_id,
                        {"x": ax_local, "y": a_map.height - 1},
                        facing="up",
                        x_tag=bx_local,
                    )

    def _add_auto_edge(
        self,
        source_map: MapData,
        direction: str,
        target_id: str,
        spawn: Dict[str, int],
        facing: str,
        x_tag: Optional[int] = None,
        y_tag: Optional[int] = None,
    ) -> None:
        tag = x_tag if x_tag is not None else y_tag if y_tag is not None else 0
        conn_id = f"auto_{direction}_{target_id}_{tag}"
        source_map.connections.append(
            Connection(
                id=conn_id,
                type="edge",
                from_ref=direction,
                to={"mapId": target_id, "spawn": spawn, "facing": facing},
                condition=None,
                extra={"auto": AUTO_FLAG},
            )
        )

    # Manual portal creation ----------------------------------------------
    def _handle_manual_click(self, map_id: Optional[str]) -> None:
        if not map_id:
            return
        if not self.manual_src:
            self.manual_src = map_id
        elif not self.manual_dst:
            self.manual_dst = map_id

    def _prompt_text(self, message: str, default: str = "") -> Optional[str]:
        input_text = default
        clock = pygame.time.Clock()
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return None
                if event.type == pygame.KEYDOWN:
                    if event.key in (pygame.K_RETURN, pygame.K_KP_ENTER):
                        return input_text
                    if event.key == pygame.K_ESCAPE:
                        return None
                    if event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    else:
                        if event.unicode:
                            input_text += event.unicode
            overlay = pygame.Surface(self.screen.get_size(), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            self.screen.blit(overlay, (0, 0))
            lines = [message, "> " + input_text, "Enter to confirm, Esc to cancel"]
            for idx, line in enumerate(lines):
                surf = self.font.render(line, True, (230, 230, 230))
                rect = surf.get_rect(center=(self.screen.get_width() // 2, self.screen.get_height() // 2 + idx * 24))
                self.screen.blit(surf, rect)
            pygame.display.flip()
            clock.tick(30)

    def _create_manual_connection(self) -> None:
        if not (self.manual_src and self.manual_dst):
            return
        src = self.manual_src
        dst = self.manual_dst
        try:
            sx = int(self._prompt_text(f"{src} portal X:", "0") or "0")
            sy = int(self._prompt_text(f"{src} portal Y:", "0") or "0")
            tx = int(self._prompt_text(f"{dst} spawn X:", "0") or "0")
            ty = int(self._prompt_text(f"{dst} spawn Y:", "0") or "0")
        except (TypeError, ValueError):
            self.manual_src = None
            self.manual_dst = None
            self.manual_mode = False
            return
        conn = Connection(
            id=f"portal_{src}_to_{dst}_{sx}_{sy}",
            type="portal",
            from_ref={"x": sx, "y": sy},
            to={"mapId": dst, "spawn": {"x": tx, "y": ty}},
            condition=None,
            extra={"manual": True},
        )
        self.maps[src].connections.append(conn)
        # optional reciprocal
        try:
            do_back = self._prompt_text("Add reverse portal? (y/n):", "y")
            if do_back and do_back.lower().startswith("y"):
                back = Connection(
                    id=f"portal_{dst}_to_{src}_{tx}_{ty}",
                    type="portal",
                    from_ref={"x": tx, "y": ty},
                    to={"mapId": src, "spawn": {"x": sx, "y": sy}},
                    condition=None,
                    extra={"manual": True},
                )
                self.maps[dst].connections.append(back)
        except Exception:
            pass
        self.maps[src].save()
        if dst in self.maps:
            self.maps[dst].save()
        self.manual_src = None
        self.manual_dst = None
        self.manual_mode = False


def main() -> None:
    viewer = WorldView()
    viewer.run()


if __name__ == "__main__":
    main()







================================================
File: src/ui/__init__.py
================================================
 


================================================
File: src/ui/main_menu.py
================================================
import runpy

import pygame

from src.core import config

MENU_OPTIONS = [
    ("Overworld", "src.overworld.overworld"),
    ("Battle Simulator", "src.battle.battle_simulator"),
    ("Pixel Art Editor", "src.editor.pixle_art_editor"),
    ("Map Editor", "src.overworld.map_editor"),
    ("Quit", None),
]


def init_menu():
    pygame.init()
    screen = pygame.display.set_mode((config.MENU_WIDTH, config.MENU_HEIGHT))
    pygame.display.set_caption("PokeClone")
    title_font = pygame.font.Font(config.DEFAULT_FONT, config.MENU_TITLE_FONT_SIZE)
    option_font = pygame.font.Font(config.DEFAULT_FONT, config.MENU_OPTION_FONT_SIZE)
    clock = pygame.time.Clock()
    return screen, title_font, option_font, clock


def run_module(module_name: str) -> None:
    try:
        runpy.run_module(module_name, run_name="__main__")
    except SystemExit:
        pass


def draw_menu(screen, title_font, option_font, selected_index):
    screen.fill(config.MENU_BG_COLOR)
    title_surf = title_font.render("PokeClone", True, config.MENU_TEXT_COLOR)
    title_rect = title_surf.get_rect(center=(config.MENU_WIDTH // 2, 120))
    screen.blit(title_surf, title_rect)

    option_rects = []
    start_y = 240
    spacing = 55
    for i, (label, _) in enumerate(MENU_OPTIONS):
        color = config.MENU_HIGHLIGHT_COLOR if i == selected_index else config.MENU_TEXT_COLOR
        option_surf = option_font.render(label, True, color)
        option_rect = option_surf.get_rect(center=(config.MENU_WIDTH // 2, start_y + i * spacing))
        screen.blit(option_surf, option_rect)
        option_rects.append(option_rect)

    pygame.display.flip()
    return option_rects


def main() -> None:
    screen, title_font, option_font, clock = init_menu()
    selected_index = 0
    running = True

    while running:
        option_rects = draw_menu(screen, title_font, option_font, selected_index)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key in (pygame.K_DOWN, pygame.K_s):
                    selected_index = (selected_index + 1) % len(MENU_OPTIONS)
                elif event.key in (pygame.K_UP, pygame.K_w):
                    selected_index = (selected_index - 1) % len(MENU_OPTIONS)
                elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                    label, module_name = MENU_OPTIONS[selected_index]
                    if module_name is None:
                        running = False
                    else:
                        run_module(module_name)
                        screen, title_font, option_font, clock = init_menu()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                for i, rect in enumerate(option_rects):
                    if rect.collidepoint(event.pos):
                        selected_index = i
                        label, module_name = MENU_OPTIONS[i]
                        if module_name is None:
                            running = False
                        else:
                            run_module(module_name)
                            screen, title_font, option_font, clock = init_menu()
                        break

        clock.tick(config.FPS)

    pygame.quit()


if __name__ == "__main__":
    main()



================================================
File: src/ui/ui_manager.py
================================================




================================================
File: tests/__init__.py
================================================



================================================
File: tests/_test_pixle_art_editor.py
================================================
import pytest
import pygame
import os
import shutil
from unittest.mock import patch, MagicMock, ANY
import colorsys
import unittest
import json
import tkinter as tk # Import tkinter to patch it

# --- Patch Tkinter Globally for Test Session --- 
# This prevents the tk.Tk() call in pixle_art_editor.py top-level from running
# when pytest imports the module.
@pytest.fixture(scope="session", autouse=True)
def patch_global_tkinter():
    # Create a mock object that behaves like a withdrawn Tk root
    mock_root = MagicMock(spec=tk.Tk)
    mock_root.withdraw = MagicMock()
    
    with patch('tkinter.Tk', return_value=mock_root) as mock_tk_global:
        print("DEBUG: Applied global tkinter.Tk patch for tests.")
        yield mock_tk_global # Provide the mock if needed, but primary goal is patching import
    print("DEBUG: Removed global tkinter.Tk patch.")
# --- End Global Patch --- 

# Adjust the path to import from the root directory
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.core import config
# Now import pixle_art_editor AFTER the global patch is set up by the fixture
from src.editor.pixle_art_editor import SpriteEditor, Editor, PALETTE
# Import EventHandler
from src.core.event_handler import EventHandler
# Import Button from editor_ui
from src.editor.editor_ui import Button 
# Import SelectionTool for patching
from src.editor.selection_manager import SelectionTool

# Pygame setup fixture (optional, but good practice)
@pytest.fixture(scope="session", autouse=True)
def pygame_setup():
    # Initialize Pygame minimally for surface creation etc.
    # Avoid full display init if possible
    pygame.init()
    yield
    pygame.quit()

# Fixture to create a temporary directory for test sprites
@pytest.fixture
def temp_sprite_dir(tmp_path):
    sprite_dir = tmp_path / "sprites"
    sprite_dir.mkdir()
    # Temporarily override the config SPRITE_DIR
    original_sprite_dir = config.SPRITE_DIR
    config.SPRITE_DIR = str(sprite_dir)
    yield str(sprite_dir)
    # Restore original config and clean up
    config.SPRITE_DIR = original_sprite_dir
    # No need to manually remove tmp_path contents, pytest handles it

# Fixture to create a temporary Editor instance (mocks problematic parts)
@pytest.fixture
def mock_editor(temp_sprite_dir):
    # Mock problematic parts to avoid GUI popups or complex setup during tests
    mock_monster_data = [{'name': 'TestMon', 'type': 'Test', 'max_hp': 10, 'moves': []}] # Define mock data
    with patch('src.editor.pixle_art_editor.Editor._get_background_files', return_value=['bg1.png', 'bg2.png'], create=True), \
         patch('src.editor.pixle_art_editor.load_monsters', return_value=mock_monster_data), \
         patch('pygame.display.set_mode', return_value=pygame.Surface((10, 10))), \
         patch('pygame.display.set_caption', return_value=None), \
         patch('pygame.font.Font', return_value=MagicMock(render=MagicMock(return_value=pygame.Surface((10, 10))))), \
         patch('src.editor.pixle_art_editor.tk.Tk') as mock_tk, \
         patch('src.editor.pixle_art_editor.filedialog.askopenfilename') as mock_askopenfilename, \
         patch('src.editor.pixle_art_editor.colorchooser.askcolor') as mock_askcolor:

        # Configure the tk.Tk mock if needed (e.g., mock withdraw method)
        mock_tk.return_value.withdraw = MagicMock()

        # --- Assign mock data to config BEFORE editor init --- 
        config.monsters = mock_monster_data 

        original_sprite_dir = config.SPRITE_DIR
        config.SPRITE_DIR = temp_sprite_dir
        try:
            # Mock load_backgrounds BEFORE Editor init if it affects choose_background_action logic
            with patch('src.editor.pixle_art_editor.Editor.load_backgrounds', return_value=[('existing_bg.png', pygame.Surface((10,10)))]) as mock_load_bgs:
                editor = Editor()
            # Initial state should be dialog_mode = 'choose_edit_mode'
            # edit_mode should be None
            # No buttons should be created yet
            
            # Attach mocks if needed for assertions later in tests
            editor.mock_tk = mock_tk
            editor.mock_askopenfilename = mock_askopenfilename
            editor.mock_askcolor = mock_askcolor
            yield editor
        finally:
            config.SPRITE_DIR = original_sprite_dir
            # Clean up config.monsters if necessary
            if hasattr(config, 'monsters'):
                 del config.monsters

# Helper function to simulate clicking a button in a list (UI or Dialog)
def simulate_button_click(editor, button_list, button_text):
    """Helper to simulate clicking a button within a SPECIFIC list."""
    target_button = None
    for btn in button_list: # Search ONLY the provided list
         if isinstance(btn, Button) and btn.text == button_text:
              target_button = btn
              break # Found it
              
    assert target_button is not None, f"Button '{button_text}' not found in the provided list for simulation."
    # Use the found button's rect center
    mock_event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=target_button.rect.center)
    editor.event_handler.process_event(mock_event)

# --- Tests for POKE-3 --- 

# TODO: Add tests for SpriteEditor load/save behavior BEFORE refactoring
def test_sprite_editor_save_current_behavior(mock_editor, temp_sprite_dir):
    """ 
    Tests the current (incorrect) save behavior where the sprite is scaled up.
    This test is expected to FAIL after POKE-3 is correctly implemented.
    """
    # Arrange
    sprite_editor = mock_editor.sprites['front'] # Get the front sprite editor
    # Directly use the mock monster name defined in the fixture
    monster_name = 'TestMon' 
    original_filepath = os.path.join(temp_sprite_dir, f"{monster_name}_front.png")

    # Create a dummy native-size sprite file to load
    dummy_surface = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
    dummy_surface.fill((10, 20, 30, 255)) # Use a distinct color
    pygame.image.save(dummy_surface, original_filepath)

    # Act
    sprite_editor.load_sprite(monster_name) # Load the dummy sprite
    # Manually set the editor's current monster index for saving
    mock_editor.current_monster_index = 0 
    # Patch the global `monsters` variable specifically for the save call
    mock_monster_data = [{'name': monster_name, 'type': 'Test', 'max_hp': 10, 'moves': []}]
    with patch('src.editor.pixle_art_editor.monsters', mock_monster_data):
        # Pass monster_name to save_sprite
        sprite_editor.save_sprite(monster_name) # Save (this is the method being tested)

    # Assert - Check the dimensions of the *saved* file
    # The current save_sprite scales UP, so the saved file should NOT match native res
    saved_surface = pygame.image.load(original_filepath).convert_alpha()
    
    # Calculate the expected (incorrect) scaled-up size
    # This depends on how save_sprite worked *before* POKE-3 (it doesn't scale anymore)
    # Let's assume the old behavior saved at native resolution (as it should now)
    # If the old behavior *did* scale up, this assertion would need to change.
    expected_dimensions = config.NATIVE_SPRITE_RESOLUTION 
    # We actually want to assert the current (correct) behavior here to see if it passes *now*
    # This test name is slightly misleading now, it tests the *desired* behavior.
    assert saved_surface.get_size() == expected_dimensions, \
           f"Saved sprite should have native dimensions {expected_dimensions}, but got {saved_surface.get_size()}"
    
    # Optional: Check content if needed (e.g., check a pixel color)
    assert saved_surface.get_at((0, 0)) == (10, 20, 30, 255), "Pixel color mismatch"


# TODO: Add tests for SpriteEditor load/save behavior AFTER refactoring

def test_sprite_editor_load_behavior(mock_editor, temp_sprite_dir):
    """Tests that load_sprite stores the image at native resolution in self.frame."""
    # Arrange
    sprite_editor = mock_editor.sprites['front']
    monster_name = 'TestMon'
    filepath = os.path.join(temp_sprite_dir, f"{monster_name}_front.png")

    # Create a sprite file with native resolution
    native_surface = pygame.Surface(config.NATIVE_SPRITE_RESOLUTION, pygame.SRCALPHA)
    native_surface.fill((50, 100, 150, 200))
    pygame.image.save(native_surface, filepath)

    # Act
    sprite_editor.load_sprite(monster_name)

    # Assert
    assert sprite_editor.frame.get_size() == config.NATIVE_SPRITE_RESOLUTION, \
           f"Frame buffer should have native dimensions {config.NATIVE_SPRITE_RESOLUTION}, but got {sprite_editor.frame.get_size()}"
    assert sprite_editor.frame.get_at((0, 0)) == (50, 100, 150, 200), "Pixel color mismatch in frame buffer"

def test_sprite_editor_load_scales_down(mock_editor, temp_sprite_dir):
    """Tests that load_sprite scales down an oversized image to native resolution."""
    # Arrange
    sprite_editor = mock_editor.sprites['front']
    monster_name = 'TestMon'
    filepath = os.path.join(temp_sprite_dir, f"{monster_name}_front.png")

    # Create an oversized sprite file
    oversized_dims = (config.NATIVE_SPRITE_RESOLUTION[0] * 2, config.NATIVE_SPRITE_RESOLUTION[1] * 2)
    oversized_surface = pygame.Surface(oversized_dims, pygame.SRCALPHA)
    oversized_surface.fill((255, 0, 0, 255))
    pygame.image.save(oversized_surface, filepath)

    # Act
    sprite_editor.load_sprite(monster_name) # This should print a warning

    # Assert
    assert sprite_editor.frame.get_size() == config.NATIVE_SPRITE_RESOLUTION, \
           f"Frame buffer should be scaled down to native {config.NATIVE_SPRITE_RESOLUTION}, but got {sprite_editor.frame.get_size()}"
    # Note: Checking pixel color after scaling might be unreliable due to smoothscale interpolation.
    # We primarily care about the dimensions here.

# --- Tests for POKE-21 (Tool Activation Bug) ---

def find_button(editor, text):
    """Helper to find a button by its text."""
    for button in editor.buttons:
        # Handle cases where button text might change (e.g., "Eraser" / "Brush")
        if button.text.startswith(text):
            return button
    return None

def simulate_monster_mode_choice(editor):
    """Helper to simulate choosing 'Monster' mode from the initial dialog."""
    if editor.dialog_mode == 'choose_edit_mode':
        monster_option = next((opt for opt in editor.dialog_options if opt.text == "Monster"), None)
        assert monster_option is not None, "(Helper) Monster dialog option not found"
        editor._handle_dialog_choice(monster_option.value)
        assert editor.edit_mode == 'monster', "(Helper) Failed to set monster mode"
        assert editor.dialog_mode is None, "(Helper) Dialog mode not cleared after monster choice"

def test_toggle_eraser_mode(mock_editor):
    """Tests toggling the eraser mode via its button."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    eraser_button = find_button(editor, "Eraser")
    assert eraser_button is not None, "Eraser button not found (after mode choice)"

    # Initial state check (after mode choice, should be False)
    assert not editor.eraser_mode

    # Click 1: Activate Eraser
    click_pos = eraser_button.rect.center
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert editor.eraser_mode, "Eraser mode should be True after first click"
    assert not editor.fill_mode, "Fill mode should be False when Eraser is active"

    # Click 2: Deactivate Eraser
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert not editor.eraser_mode, "Eraser mode should be False after second click"

def test_toggle_fill_mode(mock_editor):
    """Tests toggling the fill mode via its button."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    fill_button = find_button(editor, "Fill")
    assert fill_button is not None, "Fill button not found (after mode choice)"

    # Initial state check
    assert not editor.fill_mode

    # Click 1: Activate Fill
    click_pos = fill_button.rect.center
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert editor.fill_mode, "Fill mode should be True after first click"
    assert not editor.eraser_mode, "Eraser mode should be False when Fill is active"

    # Click 2: Deactivate Fill
    event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos})
    editor.handle_event(event)
    assert not editor.fill_mode, "Fill mode should be False after second click"

def test_tool_persistence_on_canvas_click(mock_editor):
    """Tests if Eraser/Fill mode persists after clicking the canvas (BUG FIX TEST)."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    eraser_button = find_button(editor, "Eraser")
    fill_button = find_button(editor, "Fill")
    assert eraser_button is not None # Re-assert after mode choice
    assert fill_button is not None
    sprite_editor_rect = editor.sprites['front'].frame.get_rect(topleft=editor.sprites['front'].position)
    canvas_click_pos = sprite_editor_rect.center

    # Test Eraser Persistence
    editor.eraser_mode = False # Ensure starting state
    event_eraser = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': eraser_button.rect.center})
    editor.handle_event(event_eraser)
    assert editor.eraser_mode, "Eraser should be active after button click"
    # Simulate click on canvas *after* activating tool
    event_canvas = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': canvas_click_pos})
    editor.handle_event(event_canvas)
    assert editor.eraser_mode, "BUG: Eraser mode deactivated after clicking canvas"

    # Test Fill Persistence
    editor.fill_mode = False # Ensure starting state
    editor.eraser_mode = False # Ensure eraser is off
    event_fill = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': fill_button.rect.center})
    editor.handle_event(event_fill)
    assert editor.fill_mode, "Fill should be active after button click"
    # Simulate click on canvas *after* activating tool
    event_canvas = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': canvas_click_pos})
    editor.handle_event(event_canvas)
    assert editor.fill_mode, "BUG: Fill mode deactivated after clicking canvas"

def test_tool_deactivation_on_palette_click(mock_editor):
    """Tests if Eraser/Fill mode deactivates correctly when palette is clicked."""
    editor = mock_editor
    simulate_monster_mode_choice(editor)
    eraser_button = find_button(editor, "Eraser")
    fill_button = find_button(editor, "Fill")
    assert eraser_button is not None # Re-assert
    assert fill_button is not None
    # Use a known palette color for the direct call (use global PALETTE)
    test_color = PALETTE[1] if len(PALETTE) > 1 else PALETTE[0]

    # Test Eraser Deactivation
    editor.eraser_mode = False
    # Activate eraser via button click simulation
    event_eraser = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': eraser_button.rect.center})
    editor.handle_event(event_eraser) # Activate eraser
    assert editor.eraser_mode, "Eraser should be active after button click"

    # Directly call select_color instead of simulating palette click event
    print(f"Directly calling select_color({test_color})")
    editor.select_color(test_color) # Directly select a color

    # Assert deactivation after direct call
    assert not editor.eraser_mode, "FAIL: Eraser mode should deactivate after DIRECTLY calling select_color"

    # Test Fill Deactivation
    editor.fill_mode = False
    editor.eraser_mode = False # Ensure eraser is off
    # Activate fill via button click simulation
    event_fill = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': fill_button.rect.center})
    editor.handle_event(event_fill) # Activate fill
    assert editor.fill_mode, "Fill should be active after button click"

    # Directly call select_color instead of simulating palette click event
    print(f"Directly calling select_color({test_color}) for fill test")
    editor.select_color(test_color) # Directly select a color

    # Assert deactivation after direct call
    assert not editor.fill_mode, "FAIL: Fill mode should deactivate after DIRECTLY calling select_color"

def test_placeholder():
    """Placeholder test to ensure the file runs."""
    assert True

# --- Tests for POKE-9 (Dialog System) ---

def test_editor_starts_in_choose_mode_dialog(mock_editor):
    """Tests that the editor starts in the correct initial dialog mode."""
    editor = mock_editor
    # Editor.__init__ calls choose_edit_mode(), which sets the dialog state
    assert editor.dialog_mode == 'choose_edit_mode', "Editor should start in choose_edit_mode dialog"
    assert editor.edit_mode is None, "Editor should start with no edit mode selected"
    assert editor.dialog_callback is not None, "Dialog callback should be set"
    assert len(editor.dialog_options) == 2, "Should have two dialog options"

def test_choose_edit_mode_monster(mock_editor):
    """
    Tests selecting 'Monster' from the initial edit mode dialog.
    Ensures it sets the edit_mode correctly, clears the dialog,
    and creates the appropriate UI buttons.
    """
    editor = mock_editor
    # Editor starts in 'choose_edit_mode' dialog (verified by test_editor_starts_in_choose_mode_dialog)
    assert editor.dialog_mode == 'choose_edit_mode'
    assert editor.edit_mode is None
    assert len(editor.dialog_options) == 2

    # Find the 'Monster' option in the dialog options
    monster_option = next((opt for opt in editor.dialog_options if opt.text == "Monster"), None)
    assert monster_option is not None, "Monster dialog option not found"

    # Simulate choosing the 'Monster' option by directly calling the handler
    # This bypasses event processing and directly tests the choice logic
    editor._handle_dialog_choice(monster_option.value) # value should be 'monster'

    # Assert the state AFTER the choice and callback (_set_edit_mode_and_continue)
    assert editor.edit_mode == 'monster', "Edit mode should be set to 'monster'"
    assert editor.dialog_mode is None, "Dialog mode should be cleared"
    assert editor.dialog_options == [], "Dialog options should be cleared"
    assert editor.dialog_callback is None, "Dialog callback should be cleared"

    # Assert that the correct UI buttons for monster mode are now present
    button_texts = {btn.text for btn in editor.buttons}
    # Define expected buttons more accurately based on create_buttons logic for monster mode
    expected_buttons = {
        "Save", "Load", "Clear", "Color Picker", "Eraser", "Fill", "Select",
        "Copy", "Paste", "Mirror", "Rotate", "Undo", "Redo", "Load Ref Img",
        "Clear Ref Img", "Prev Monster", "Next Monster", "Switch Sprite"
    }
    missing_buttons = expected_buttons - button_texts
    extra_buttons = button_texts - expected_buttons
    assert not missing_buttons, f"Missing expected monster mode buttons: {missing_buttons}"
    assert not extra_buttons, f"Found unexpected buttons: {extra_buttons}"

    # Also check that the sprite editors were initialized (part of monster mode setup)
    assert 'front' in editor.sprites
    assert 'back' in editor.sprites
    # Ensure current_sprite is set (might be 'front' by default in load_monster)
    assert editor.current_sprite is not None 


def test_choose_edit_mode_background_leads_to_action_dialog(mock_editor):
    """
    Tests selecting 'Background' from the initial edit mode dialog.
    Ensures it clears the initial dialog and presents the 'new'/'edit' background dialog.
    """
    editor = mock_editor
    # Editor starts in 'choose_edit_mode' dialog
    assert editor.dialog_mode == 'choose_edit_mode'
    assert editor.edit_mode is None
    assert len(editor.dialog_options) == 2

    # Find the 'Background' option
    background_option = next((opt for opt in editor.dialog_options if opt.text == "Background"), None)
    assert background_option is not None, "Background dialog option not found"

    # Simulate choosing the 'Background' option
    # No need to patch _get_background_files here now, load_backgrounds is mocked
    editor._handle_dialog_choice(background_option.value) # value should be 'background'

    # Assert the state AFTER the choice and callback (_set_edit_mode_and_continue)
    assert editor.edit_mode == 'background', "Edit mode should be set to 'background'"
    # Choosing background should lead to 'choose_bg_action' because load_backgrounds was mocked
    assert editor.dialog_mode == 'choose_bg_action', "Should be in the 'choose_bg_action' dialog"
    assert editor.dialog_callback is not None, "A new dialog callback should be set"
    assert len(editor.dialog_options) == 2, "Should have two options (New, Edit Existing)"
    option_texts = {opt.text for opt in editor.dialog_options}
    assert option_texts == {"New", "Edit Existing"}, "Dialog options should be 'New' and 'Edit Existing'"
    button_texts = {btn.text for btn in editor.buttons}
    assert "Save" not in button_texts, "Main UI buttons should not be created yet"


@patch('os.path.exists', return_value=False) # Assume background file does NOT exist
def test_choose_background_action_new_leads_to_input(mock_exists, mock_editor):
    """
    Tests choosing 'New' from the background action dialog when no file exists.
    Simulates: Initial Dialog -> Background -> New -> Input Dialog.
    """
    editor = mock_editor
    # Ensure backgrounds list is empty for this specific test path
    editor.backgrounds = []
    editor.current_background_index = -1 # Ensure index reflects empty list

    # 1. Simulate getting into background mode first
    editor.dialog_mode = 'choose_edit_mode' # Reset to initial state if needed
    editor.edit_mode = None
    editor.choose_edit_mode() # Set up the initial dialog state again
    background_option = next((opt for opt in editor.dialog_options if opt.text == "Background"), None)
    assert background_option is not None
    editor._handle_dialog_choice(background_option.value)

    # State check: Should directly go to 'input_text' because backgrounds is empty
    print(f"DEBUG TEST: editor.dialog_mode = {editor.dialog_mode}")
    assert editor.dialog_mode == 'input_text', "Should be in 'input_text' dialog mode because no backgrounds exist"
    assert editor.edit_mode == 'background' # edit_mode is set before choose_background_action

    # Check prompt and default text
    assert editor.dialog_prompt == "Enter filename for new background (.png):"
    assert editor.dialog_input_text == "new_background.png"
    assert editor.dialog_callback == editor._create_new_background_callback, "Incorrect callback for new background input"
    option_texts = {opt.text for opt in editor.dialog_options}
    assert option_texts == {"Save", "Cancel"}, "Input dialog options incorrect"
    button_texts = {btn.text for btn in editor.buttons}
    assert "Save" not in button_texts, "Main UI buttons should not be created yet"


@patch('pygame.image.save') # Mock save to avoid actual file writing
def test_input_text_dialog_save(mock_save, mock_editor):
    """Tests clicking OK in the input text dialog (e.g., for new background name)."""
    editor = mock_editor
    # Background mode needs to be set for create_buttons to work correctly in the callback
    editor.edit_mode = 'background' 
    editor.dialog_mode = 'input_text'
    editor.input_prompt = "Test Prompt"
    editor.input_text = "test_name"
    editor.dialog_callback = editor._create_new_background_callback
    editor.dialog_options = [
        Button((0,0, 50, 30), "Save", value="test_name"),
        Button((0,0, 50, 30), "Cancel", value=None)
    ]
    save_button = next((opt for opt in editor.dialog_options if opt.text == "Save"), None)
    assert save_button is not None
    editor._handle_dialog_choice(save_button.value)
    mock_save.assert_called_once()
    expected_save_path = os.path.join(config.BACKGROUND_DIR, "test_name.png")
    saved_path_arg = mock_save.call_args[0][1] # Correct index for filename
    assert isinstance(saved_path_arg, str), f"Expected filename string, got {type(saved_path_arg)}"
    assert os.path.normpath(saved_path_arg) == os.path.normpath(expected_save_path), \
           f"Saved path mismatch. Expected {expected_save_path}, got {saved_path_arg}"
    assert editor.dialog_mode is None
    assert editor.dialog_options == []
    assert editor.dialog_callback is None
    # Assert edit_mode is now correctly set
    assert editor.edit_mode == 'background' 
    button_texts = {btn.text for btn in editor.buttons}
    assert "Save" in button_texts # Should now have background buttons
    assert editor.current_background is not None

def test_input_text_dialog_cancel(mock_editor):
    """Tests clicking Cancel in the input text dialog."""
    editor = mock_editor
    editor.dialog_mode = 'input_text'
    editor.input_prompt = "Test Prompt"
    editor.input_text = "some_text" 
    editor.dialog_callback = MagicMock() # Callback not called on cancel
    editor.dialog_options = [
        Button((0,0, 50, 30), "Save", value="some_text"),
        Button((0,0, 50, 30), "Cancel", value=None)
    ]
    cancel_button = next((opt for opt in editor.dialog_options if opt.text == "Cancel"), None)
    assert cancel_button is not None
    editor._handle_dialog_choice(cancel_button.value)

    # Dialog should be cleared
    assert editor.dialog_mode is None
    # Assert that the callback attribute is now None
    assert editor.dialog_callback is None, "Callback should be cleared on cancel"
    assert editor.dialog_input_text == "", "Dialog input text should be cleared on cancel"

@pytest.mark.skip(reason="Skipping tests that trigger native file dialog via button")
def test_load_background_dialog_trigger(mock_editor):
    # This test clicks the main "Load" button which internally calls trigger_load_background_dialog
    # which might eventually call _ensure_tkinter_root if not fully Pygame UI.
    # Skip for now to avoid Tkinter issues.
    pass

@pytest.mark.skip(reason="Skipping tests involving native file dialog interactions")
def test_file_select_dialog_load(mock_editor):
    # This test directly manipulates dialog state related to file loading
    # and simulates button clicks that rely on the mocked filedialog.
    # Skip for now.
    pass

@pytest.mark.skip(reason="Skipping tests involving native file dialog interactions")
def test_file_select_dialog_cancel(mock_editor):
    # Similar to above, skip for now.
    pass

@pytest.mark.skip(reason="Skipping tests that trigger native color picker")
def test_color_picker_dialog_trigger(mock_editor):
    # This test simulates clicking the 'Color Picker' button, which calls open_color_picker,
    # which calls _ensure_tkinter_root, triggering the problematic tk.Tk()
    editor = mock_editor
    editor.dialog_mode = None # Ensure no dialog active

    picker_button = find_button(editor, "Color Picker")
    assert picker_button is not None
    # This click would eventually call tk.Tk() via _ensure_tkinter_root
    # simulate_button_click(editor, [picker_button], "Color Picker") # Skip the click
    
    # Instead assert that the button exists, skipping the interaction part
    assert True # Replace with skip or remove test if button doesn't exist anymore

@pytest.mark.skip(reason="Skipping tests involving native color picker interactions")
def test_color_picker_dialog_ok(mock_editor):
    # Skip for now
    pass

@pytest.mark.skip(reason="Skipping tests involving native color picker interactions")
def test_color_picker_dialog_cancel(mock_editor):
    # Skip for now
    pass

# --- Test Reference Image Feature (Modify/Skip) ---

class TestReferenceImage(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Ensure necessary directories exist before tests run
        os.makedirs(config.SPRITE_DIR, exist_ok=True)
        os.makedirs(config.BACKGROUND_DIR, exist_ok=True)
        os.makedirs(config.DATA_DIR, exist_ok=True)
        # Ensure test assets dir exists (though created earlier)
        os.makedirs(os.path.join("tests", "assets"), exist_ok=True)
        # Create dummy monster/moves data if needed for Editor init
        if not os.path.exists(os.path.join(config.DATA_DIR, 'monsters.json')):
            with open(os.path.join(config.DATA_DIR, 'monsters.json'), 'w') as f:
                json.dump([{"name": "TestMon", "type": "Normal", "max_hp": 100, "attack": 10, "defense": 10, "moves": []}], f)
        # Add dummy moves.json if needed

    def setUp(self):
        """Set up a fresh Editor instance for each test.
           REMOVED patches here, apply them per test method.
        """
        # Basic editor setup without problematic patches
        # Mock choose_edit_mode directly during init maybe?
        # Or just manually set states after init.
        with patch('src.editor.pixle_art_editor.tk.Tk', return_value=mock_root), \
             patch('src.editor.pixle_art_editor.Editor.choose_edit_mode', return_value='monster'), \
             patch('src.editor.pixle_art_editor.load_monsters', return_value=[{"name": "TestMon", "type": "Normal", "max_hp": 100, "attack": 10, "defense": 10, "moves": []}]), \
             patch('pygame.image.load', side_effect=self.mock_pygame_load_basic): # Basic mock for init
                 self.editor = Editor()

        # Manually set required states after init
        self.editor.edit_mode = 'monster'
        self.editor.sprites = {
            'front': SpriteEditor((0, 0), 'front', config.SPRITE_DIR),
            'back': SpriteEditor((100, 0), 'back', config.SPRITE_DIR)
        }
        self.editor.current_sprite = 'front'
        # Resetting global mock is no longer needed here
        # mock_filedialog.reset_mock()
        # mock_filedialog.askopenfilename.reset_mock()

    def mock_pygame_load_basic(self, path):
        """Basic mock for pygame load used during setup, returns dummy surface."""
        return pygame.Surface((config.NATIVE_SPRITE_RESOLUTION[0], config.NATIVE_SPRITE_RESOLUTION[1]), pygame.SRCALPHA)

    def mock_pygame_load_for_ref_test(self, path):
        """Specific mock for pygame load used in reference image tests."""
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        if path == test_image_path:
            surf = pygame.Surface((16, 16), pygame.SRCALPHA)
            surf.fill((100, 150, 200, 255))
            return surf
        else:
            # For sprite loading during these specific tests
            return pygame.Surface((config.NATIVE_SPRITE_RESOLUTION[0], config.NATIVE_SPRITE_RESOLUTION[1]), pygame.SRCALPHA)

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_load_reference_image(self, mock_load, mock_filedialog_arg):
        """Test loading a reference image."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path

        self.assertIsNone(self.editor.reference_image)
        self.assertIsNone(self.editor.scaled_reference_image)
        self.assertIsNone(self.editor.reference_image_path)

        self.editor.load_reference_image()

        # Assert call on the mock passed as argument
        mock_filedialog_arg.askopenfilename.assert_called_once()
        mock_load.assert_called_with(test_image_path)
        self.assertIsNotNone(self.editor.reference_image, "Reference image should be loaded")
        self.assertIsNotNone(self.editor.scaled_reference_image, "Scaled reference image should exist after load")
        self.assertEqual(self.editor.reference_image_path, test_image_path)
        self.assertNotEqual(self.editor.reference_image.get_size(), 
                          self.editor.scaled_reference_image.get_size(),
                          "Original and scaled images should have different sizes due to scaling")
        self.assertEqual(self.editor.scaled_reference_image.get_width(), 
                         self.editor.sprites['front'].display_width,
                         "Scaled image width should match editor display width")

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_clear_reference_image(self, mock_load, mock_filedialog_arg):
        """Test clearing the loaded reference image."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        # First, load an image (patches are active)
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path
        self.editor.load_reference_image()
        self.assertIsNotNone(self.editor.reference_image)

        # Now, clear it
        self.editor.clear_reference_image()
        self.assertIsNone(self.editor.reference_image, "Reference image should be None after clear")
        self.assertIsNone(self.editor.scaled_reference_image, "Scaled reference image should be None after clear")
        self.assertIsNone(self.editor.reference_image_path, "Reference image path should be None after clear")

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_set_reference_alpha(self, mock_load, mock_filedialog_arg):
        """Test setting the alpha value."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        initial_alpha = self.editor.reference_alpha
        
        # Load image first (patches are active)
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path
        self.editor.load_reference_image()
        self.assertIsNotNone(self.editor.scaled_reference_image, "Scaled image needed for alpha test")

        # Test setting valid alpha
        test_alpha = 50
        self.editor.set_reference_alpha(test_alpha)
        self.assertEqual(self.editor.reference_alpha, test_alpha)
        self.assertEqual(self.editor.scaled_reference_image.get_alpha(), test_alpha, "Surface alpha should match set alpha")

        # Test clamping (below 0)
        self.editor.set_reference_alpha(-100)
        self.assertEqual(self.editor.reference_alpha, 0)
        self.assertEqual(self.editor.scaled_reference_image.get_alpha(), 0)
        
        # Test clamping (above 255)
        self.editor.set_reference_alpha(500)
        self.assertEqual(self.editor.reference_alpha, 255)
        self.assertEqual(self.editor.scaled_reference_image.get_alpha(), 255)

    @pytest.mark.skip(reason="Skipping test dependent on native file dialog")
    @patch('src.editor.pixle_art_editor.filedialog')
    @patch('pygame.image.load')
    def test_alpha_slider_interaction(self, mock_load, mock_filedialog_arg):
        """Simulate interacting with the alpha slider."""
        mock_load.side_effect = self.mock_pygame_load_for_ref_test
        # Load image first (patches are active)
        test_image_path = os.path.abspath(os.path.join("tests", "assets", "test_ref_image.png"))
        # Configure the mock passed as argument
        mock_filedialog_arg.askopenfilename.return_value = test_image_path
        self.editor.load_reference_image()
        self.assertIsNotNone(self.editor.scaled_reference_image)

        slider_rect = self.editor.ref_alpha_slider_rect
        knob_rect = self.editor.ref_alpha_knob_rect
        slider_width_effective = slider_rect.width - knob_rect.width
        if slider_width_effective <= 0: slider_width_effective = 1 # Prevent division by zero

        # Simulate clicking near the start (should result in low alpha)
        click_pos_start = (slider_rect.x + 5, slider_rect.centery)
        event_down_start = pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'button': 1, 'pos': click_pos_start})
        self.editor.handle_event(event_down_start)
        self.assertTrue(self.editor.adjusting_alpha)
        expected_alpha_start = int((5 / slider_width_effective) * 255)
        self.assertEqual(self.editor.reference_alpha, max(0, min(255, expected_alpha_start)))
        
        # Simulate dragging near the end (should result in high alpha)
        drag_pos_end = (slider_rect.right - 5, slider_rect.centery)
        event_motion_end = pygame.event.Event(pygame.MOUSEMOTION, {'buttons': (1, 0, 0), 'pos': drag_pos_end})
        self.editor.handle_event(event_motion_end)
        expected_alpha_end = int(((slider_rect.width - 5) / slider_width_effective) * 255)
        self.assertEqual(self.editor.reference_alpha, max(0, min(255, expected_alpha_end)))

        # Simulate releasing the mouse
        event_up_end = pygame.event.Event(pygame.MOUSEBUTTONUP, {'button': 1, 'pos': drag_pos_end})
        self.editor.handle_event(event_up_end)
        self.assertFalse(self.editor.adjusting_alpha)

# --- Tests for EventHandler (Should mostly pass now) ---

@pytest.fixture
def event_handler(mock_editor):
    """Fixture to get the EventHandler instance."""
    # Access the handler created within the mocked editor
    return mock_editor.event_handler

class TestEventHandler:
    # Test methods use event_handler fixture
    def test_mouse_down_left_on_button(self, event_handler, mock_editor):
        """Test clicking a UI button calls its action."""
        editor = mock_editor
        simulate_monster_mode_choice(editor)

        mock_button_action = MagicMock()
        # Find a real button and assign the mock action
        # Use 'Clear' button for simplicity
        target_button = find_button(editor, "Clear")
        assert target_button is not None, "Could not find 'Clear' button to test"
        original_action = target_button.action
        target_button.action = mock_button_action

        mock_event = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=target_button.rect.center)

        # The handler should process the event and call the button's action
        result = event_handler.process_event(mock_event)

        assert result is True # Event should be handled
        mock_button_action.assert_called_once()

        # Restore original action (optional, good practice)
        target_button.action = original_action

    def test_select_button_then_canvas_click_no_crash(self, event_handler, mock_editor):
        """Tests clicking Select button then clicking canvas starts selection."""
        editor = mock_editor
        simulate_monster_mode_choice(editor)
        select_button = find_button(editor, "Select")
        assert select_button is not None, "Select button not found (after mode choice)"

        # Click Select Button -> sets mode='select', selection.selecting=True
        event_button = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=select_button.rect.center)
        event_handler.process_event(event_button)
        assert editor.mode == 'select'
        assert editor.selection.selecting is True, "Toggle should set selecting=True"
        assert editor.selection.start_pos is None, "Start pos should be None after toggle"

        # Click Canvas -> should call selection.start
        canvas_pos = editor.sprites['front'].position
        event_canvas = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=canvas_pos)

        try:
            # Patch get_grid_position, but NOT selection.start
            with patch.object(editor.sprites['front'], 'get_grid_position', return_value=(5,5)) as mock_grid_pos:
                event_handler.process_event(event_canvas)
            
            # Assert that selection has started correctly
            assert editor.selection.start_pos == (5,5), "Selection start_pos not set correctly"
            assert editor.selection.end_pos == (5,5), "Selection end_pos not set correctly"
            # selecting flag remains True during the drag
            assert editor.selection.selecting is True, "Selection selecting flag should remain True"
            assert editor.selection.active is False, "Selection active flag should be False until mouse up"
        except TypeError as e:
            pytest.fail(f"TypeError occurred during canvas click after selecting: {e}")
        except Exception as e:
             pytest.fail(f"An unexpected error occurred: {e}")

    def test_select_button_does_not_start_selection(self, event_handler, mock_editor):
        """Tests that clicking the Select button ONLY changes mode, doesn't call selection.start."""
        editor = mock_editor
        simulate_monster_mode_choice(editor)
        select_button = find_button(editor, "Select")
        assert select_button is not None, "Select button not found (after mode choice)"

        # Patch the start method of the specific selection instance
        with patch.object(editor.selection, 'start', wraps=editor.selection.start) as mock_selection_start:
            # Click Select Button
            event_button = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=select_button.rect.center)
            event_handler.process_event(event_button)

            # Assert mode changed but start was NOT called by this event
            assert editor.mode == 'select'
            mock_selection_start.assert_not_called()

    # ... rest of TestEventHandler tests ...

# --- Tests for Editor Drawing --- 

@patch('pygame.display.flip') # Mock flip as it's called in run loop
@patch('pygame.event.get', return_value=[pygame.event.Event(pygame.QUIT)]) # Mock events
class TestEditorDrawing:

    def test_draw_ui_calls_selection_draw_correctly(self, mock_event_get, mock_flip, mock_editor):
        """Tests if Editor.draw_ui calls SelectionTool.draw with correct arguments in select mode."""
        editor = mock_editor
        # Set editor to monster mode and ensure dialog is cleared
        simulate_monster_mode_choice(editor)
        editor.mode = 'select' # Now set select mode
        editor.current_sprite = 'front' # Ensure a current sprite is set
        # Ensure selection is active for draw to be called
        editor.selection.active = True
        editor.selection.rect = pygame.Rect(1,1,2,2) # Needs a non-zero rect

        # Get the expected position
        active_sprite_editor = editor.sprites.get(editor.current_sprite)
        assert active_sprite_editor is not None
        expected_position = active_sprite_editor.position

        # Patch the draw method on the specific instance editor.selection
        with patch.object(editor.selection, 'draw') as mock_selection_draw:
            # Call draw_ui
            editor.draw_ui()

            # Assert that SelectionTool.draw was called
            mock_selection_draw.assert_called_once()

            # Get the arguments passed to the mock
            args, kwargs = mock_selection_draw.call_args
            
            # Assert the arguments
            assert isinstance(args[0], pygame.Surface) # Check screen surface
            assert args[1] == expected_position # Check sprite position

# --- Tests for Tkinter Initialization and Usage --- 

@patch('tkinter.Tk') # Mock Tkinter root creation
class TestTkinterIntegration:

    # Test that ensures _ensure_tkinter_root doesn't crash when tk_root is mocked
    def test_ensure_tkinter_root_no_crash_mocked(self, mock_tk, mock_editor):
        """Tests _ensure_tkinter_root executes without error when Tk is mocked."""
        editor = mock_editor
        try:
            # Simulate the global root having been mocked successfully (or failed gracefully)
            # The fixture likely already handles this, but we call the check method
            result = editor._ensure_tkinter_root()
            # We expect True if the global mock worked, or False if it failed gracefully
            # The main point is no crash occurs here.
            assert isinstance(result, bool)
        except Exception as e:
            pytest.fail(f"_ensure_tkinter_root raised an unexpected exception: {e}")

    # Test calling open_color_picker (mocks the actual dialog)
    @patch('src.editor.pixle_art_editor.colorchooser.askcolor')
    def test_open_color_picker_no_crash(self, mock_askcolor, mock_tk, mock_editor):
        """Tests calling open_color_picker doesn't crash (dialog is mocked)."""
        editor = mock_editor
        # Assume global tk_root mock setup worked via fixture
        
        # ---> Configure the mock return value <---
        mock_askcolor.return_value = ((100, 150, 200), '#6496c8') # Example valid return

        try:
            editor.open_color_picker()
            # Assert the mocked askcolor was called (ensures the function ran)
            mock_askcolor.assert_called_once()
        except Exception as e:
            pytest.fail(f"open_color_picker raised an unexpected exception: {e}")

    # Test calling load_reference_image (mocks the actual dialog)
    @patch('src.editor.pixle_art_editor.filedialog.askopenfilename')
    def test_load_reference_image_no_crash(self, mock_askopenfilename, mock_tk, mock_editor):
        """Tests calling load_reference_image doesn't crash (dialog is mocked)."""
        editor = mock_editor
        # Assume global tk_root mock setup worked via fixture

        try:
            editor.load_reference_image()
             # Assert the mocked askopenfilename was called
            mock_askopenfilename.assert_called_once()
        except Exception as e:
            pytest.fail(f"load_reference_image raised an unexpected exception: {e}")

# --- Tests for Selection Logic --- 

def test_selection_click_drag_release(mock_editor):
    """Tests the click-drag-release sequence for making a selection."""
    editor = mock_editor
    simulate_monster_mode_choice(editor) # Get into monster mode
    
    # Find the Select button and click it
    select_button = find_button(editor, "Select")
    assert select_button is not None, "Select button not found"
    event_button = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=select_button.rect.center)
    editor.handle_event(event_button)
    assert editor.mode == 'select', "Editor should be in select mode"
    assert editor.selection.selecting is True, "SelectionTool should be in selecting state after toggle"
    assert editor.selection.active is False, "Selection should not be active initially"

    # Simulate mouse down on canvas (start selection drag)
    start_grid_pos = (5, 10)
    start_screen_pos = (editor.sprites['front'].position[0] + start_grid_pos[0] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2,
                          editor.sprites['front'].position[1] + start_grid_pos[1] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2)
    with patch.object(editor.sprites['front'], 'get_grid_position', return_value=start_grid_pos):
        event_down = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=start_screen_pos)
        editor.handle_event(event_down)
    
    assert editor.selection.start_pos == start_grid_pos, f"Selection start_pos mismatch after down. Got {editor.selection.start_pos}"
    assert editor.selection.end_pos == start_grid_pos, f"Selection end_pos mismatch after down. Got {editor.selection.end_pos}"
    assert editor.selection.selecting is True, "SelectionTool should still be selecting during drag"
    assert editor.selection.active is False, "Selection should not be active during drag"
    expected_rect_down = pygame.Rect(start_grid_pos[0], start_grid_pos[1], 1, 1)
    assert editor.selection.rect == expected_rect_down, f"Selection rect incorrect after down. Got {editor.selection.rect}"

    # Simulate mouse motion (dragging)
    drag_grid_pos = (15, 20)
    drag_screen_pos = (editor.sprites['front'].position[0] + drag_grid_pos[0] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2,
                         editor.sprites['front'].position[1] + drag_grid_pos[1] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2)
    with patch.object(editor.sprites['front'], 'get_grid_position', return_value=drag_grid_pos):
        event_motion = pygame.event.Event(pygame.MOUSEMOTION, buttons=(1, 0, 0), pos=drag_screen_pos)
        editor.handle_event(event_motion)

    assert editor.selection.start_pos == start_grid_pos, "Selection start_pos should not change during drag"
    assert editor.selection.end_pos == drag_grid_pos, f"Selection end_pos mismatch after drag. Got {editor.selection.end_pos}"
    assert editor.selection.selecting is True, "SelectionTool should still be selecting during drag"
    assert editor.selection.active is False, "Selection should not be active during drag"
    expected_rect_drag = pygame.Rect(start_grid_pos[0], start_grid_pos[1], 
                                     drag_grid_pos[0] - start_grid_pos[0] + 1,
                                     drag_grid_pos[1] - start_grid_pos[1] + 1)
    assert editor.selection.rect == expected_rect_drag, f"Selection rect incorrect after drag. Got {editor.selection.rect}"

    # Simulate mouse up (end selection drag)
    end_grid_pos = (18, 22) # Can be slightly different from last motion pos
    end_screen_pos = (editor.sprites['front'].position[0] + end_grid_pos[0] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2,
                        editor.sprites['front'].position[1] + end_grid_pos[1] * config.EDITOR_PIXEL_SIZE + config.EDITOR_PIXEL_SIZE // 2)
    with patch.object(editor.sprites['front'], 'get_grid_position', return_value=end_grid_pos):
        event_up = pygame.event.Event(pygame.MOUSEBUTTONUP, button=1, pos=end_screen_pos)
        editor.handle_event(event_up)

    assert editor.selection.start_pos == start_grid_pos, "Selection start_pos should persist after up"
    assert editor.selection.end_pos == end_grid_pos, f"Selection end_pos mismatch after up. Got {editor.selection.end_pos}"
    assert editor.selection.selecting is False, "SelectionTool should stop selecting after mouse up"
    assert editor.selection.active is True, "Selection should be active after mouse up"
    expected_rect_up = pygame.Rect(start_grid_pos[0], start_grid_pos[1], 
                                   end_grid_pos[0] - start_grid_pos[0] + 1,
                                   end_grid_pos[1] - start_grid_pos[1] + 1)
    assert editor.selection.rect == expected_rect_up, f"Selection rect incorrect after up. Got {editor.selection.rect}"

# --- Tests for Background Editing --- 

def test_background_draw_erase(mock_editor):
    """Tests drawing and erasing on the background canvas."""
    editor = mock_editor
    
    # --- Manually Set Up Background Mode State --- 
    # Bypass dialogs for this specific test
    editor.edit_mode = 'background'
    # Use default dimensions from config for the test canvas
    canvas_width = config.DEFAULT_BACKGROUND_WIDTH 
    canvas_height = config.DEFAULT_BACKGROUND_HEIGHT
    editor.canvas_rect = pygame.Rect(50, 100, canvas_width, canvas_height) # Example position
    # Create a plain white background for testing
    editor.current_background = pygame.Surface((canvas_width, canvas_height))
    editor.current_background.fill(config.WHITE)
    # Ensure background buttons are created
    editor.buttons = editor.create_buttons()
    # Ensure dialog mode is off
    editor.dialog_mode = None 
    # --- End Manual Setup ---

    # Define test parameters
    test_color = config.RED # (255, 0, 0)
    editor.select_color(test_color) # Set current color, also disables eraser/fill
    editor.brush_size = 5 # Use a brush size > 1
    click_canvas_rel_pos = (50, 60) # Relative position within the background surface
    click_screen_pos = (editor.canvas_rect.x + click_canvas_rel_pos[0], 
                        editor.canvas_rect.y + click_canvas_rel_pos[1])
    
    # Check initial color (should be white)
    initial_color = editor.current_background.get_at(click_canvas_rel_pos)
    assert initial_color == config.WHITE, f"Initial background pixel color mismatch. Expected WHITE, got {initial_color}"

    # --- Test Drawing --- 
    editor.eraser_mode = False # Ensure eraser is off
    event_draw = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=click_screen_pos)
    # Need to save state manually if not done by event handler in this test setup
    editor.save_state() 
    handled = editor.handle_event(event_draw)
    assert handled is True, "Draw event was not handled"

    # Check pixel color after drawing (should be red near the center)
    # _handle_canvas_click draws a circle based on brush_size
    color_after_draw = editor.current_background.get_at(click_canvas_rel_pos)
    assert color_after_draw == test_color[:3], f"Pixel color after draw mismatch. Expected {test_color[:3]}, got {color_after_draw}"
    
    # --- Test Erasing --- 
    editor.eraser_mode = True # Turn eraser on
    event_erase = pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1, pos=click_screen_pos)
    # Save state before erasing
    editor.save_state() 
    handled_erase = editor.handle_event(event_erase)
    assert handled_erase is True, "Erase event was not handled"

    # Check pixel color after erasing (should be white)
    color_after_erase = editor.current_background.get_at(click_canvas_rel_pos)
    assert color_after_erase == config.WHITE[:3], f"Pixel color after erase mismatch. Expected {config.WHITE[:3]}, got {color_after_erase}"

# --- Main execution for unittest --- (if using unittest classes)

if __name__ == '__main__':
    # You might need to create a test suite and add all test classes
    suite = unittest.TestSuite()
    # Add existing tests (assuming they are named like TestSpriteLoadingSaving, etc.)
    # suite.addTest(unittest.makeSuite(TestSpriteLoadingSaving))
    # suite.addTest(unittest.makeSuite(TestUndoRedo)) 
    # ... add other existing test classes ...
    
    # Add the new test class
    suite.addTest(unittest.makeSuite(TestReferenceImage))

    runner = unittest.TextTestRunner()
    runner.run(suite)
    # Alternatively, just run discovery if setup allows:
    # unittest.main() # This might run tests multiple times if not structured carefully

    # ... (Rest of the existing code) ... 


================================================
File: tests/test_battle_simulator.py
================================================
import unittest
import copy
import os
import sys # Import sys earlier for path adjustments if needed
import unittest.mock # Move import here
from src.core import config # Updated import
from unittest.mock import MagicMock

# Add project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Adjust path to import from the parent directory if tests are in a subfolder
# Assuming test_battle_simulator.py is in the root alongside battle_simulator.py
# If not, you might need path adjustments like sys.path.append('..')
from src.battle.battle_simulator import Creature, Move, load_creatures, apply_stat_change, create_default_sprite

# Mock Pygame functionalities needed for loading if not running full Pygame init
class MockSurface:
    def __init__(self, size):
        self._size = size
    def get_size(self):
        return self._size
    def convert_alpha(self):
        return self
    def fill(self, color):
        pass
    def blit(self, source, dest, area=None, special_flags=0):
        # We don't need to simulate blitting, just accept the call
        pass

pygame_transform_scale_orig = None

def setup_mocks():
    global pygame_transform_scale_orig
    if hasattr(unittest.mock, 'patch'): # Check if mock is available
        try:
            # Mock pygame.transform.scale if it exists
            if 'pygame' in sys.modules and hasattr(sys.modules['pygame'], 'transform') and hasattr(sys.modules['pygame'].transform, 'scale'):
                pygame_transform_scale_orig = sys.modules['pygame'].transform.scale
                sys.modules['pygame'].transform.scale = lambda surface, size: MockSurface(size)
            else:
                print("Warning: Pygame or pygame.transform.scale not fully available for mocking.")
        except Exception as e:
            print(f"Warning: Could not set up Pygame mocks - {e}")

def teardown_mocks():
    global pygame_transform_scale_orig
    if pygame_transform_scale_orig and 'pygame' in sys.modules and hasattr(sys.modules['pygame'], 'transform'):
         sys.modules['pygame'].transform.scale = pygame_transform_scale_orig

# Mock the sprite loading part to avoid Pygame dependency during test
original_create_sprite_from_file = None
def mock_create_sprite_from_file(filename):
    """Mocks sprite creation to return a dummy surface."""
    # Return an instance of our mock surface, not a real one
    return MockSurface(config.NATIVE_SPRITE_RESOLUTION) 

class TestBattleSimulator(unittest.TestCase): # Renamed class for broader scope

    @classmethod
    def setUpClass(cls):
        """Set up mocks before tests run."""
        # Ensure data directory exists for loading
        if not os.path.exists('data'):
             raise FileNotFoundError("Data directory not found. Make sure tests run from project root.")
        if not os.path.exists('data/monsters.json'):
             raise FileNotFoundError("monsters.json not found in data directory.")
        if not os.path.exists('data/moves.json'):
            raise FileNotFoundError("moves.json not found in data directory.")
        if not os.path.exists('data/type_chart.json'):
            raise FileNotFoundError("type_chart.json not found in data directory.")

        # Mock sprite creation globally for this test class
        global original_create_sprite_from_file
        import src.battle.battle_simulator
        original_create_sprite_from_file = src.battle.battle_simulator.create_sprite_from_file
        src.battle.battle_simulator.create_sprite_from_file = mock_create_sprite_from_file

        # Set up general Pygame mocks
        setup_mocks()

    @classmethod
    def tearDownClass(cls):
        """Restore original functions after tests."""
        # Restore original sprite creation
        global original_create_sprite_from_file
        if original_create_sprite_from_file:
            import src.battle.battle_simulator
            src.battle.battle_simulator.create_sprite_from_file = original_create_sprite_from_file

        # Tear down general Pygame mocks
        teardown_mocks()

    def setUp(self):
        """Create a default creature for tests that need one."""
        # Mock a default sprite without pygame dependency if possible
        mock_sprite = unittest.mock.Mock(spec=MockSurface)
        mock_sprite.get_size.return_value = (64, 64)
        mock_sprite.convert_alpha.return_value = mock_sprite

        self.default_creature = Creature(
            name="TestMon", type_="Normal", max_hp=100, attack=50, defense=50,
            moves=[], sprite=mock_sprite # Use the mock surface created above
        )

    def test_poke_6_stat_reset_with_deepcopy(self):
        """Verify that stat changes on a copy don't affect the original."""
        # 1. Load creatures (uses mocked sprite loading)
        all_creatures = load_creatures()
        self.assertTrue(len(all_creatures) > 0, "Creature loading failed or returned empty list.")
        original_creature = all_creatures[0]

        # 2. Store original stat
        original_attack = original_creature.attack
        original_defense = original_creature.defense
        original_hp = original_creature.current_hp
        original_max_hp = original_creature.max_hp

        # 3. Create a deep copy
        creature_copy = copy.deepcopy(original_creature)

        # 4. Apply stat change to the copy (e.g., increase attack)
        apply_stat_change(creature_copy, 'attack', 2) # Increase attack stage by 2
        # Apply damage to the copy
        creature_copy.current_hp -= 10

        # 5. Assert original creature's stats are unchanged
        self.assertEqual(original_creature.attack, original_attack,
                         f"Original attack changed! Expected {original_attack}, got {original_creature.attack}")
        self.assertEqual(original_creature.defense, original_defense,
                         f"Original defense changed! Expected {original_defense}, got {original_creature.defense}")
        self.assertEqual(original_creature.current_hp, original_hp,
                         f"Original current HP changed! Expected {original_hp}, got {original_creature.current_hp}")
        self.assertEqual(original_creature.max_hp, original_max_hp,
                         f"Original max HP changed! Expected {original_max_hp}, got {original_creature.max_hp}")

        # 6. Assert copy's stats ARE changed
        self.assertNotEqual(creature_copy.attack, original_attack,
                          "Copied creature's attack did not change as expected.")
        self.assertLess(creature_copy.current_hp, original_hp,
                        "Copied creature's HP did not decrease as expected.")
        # Check if max HP is unchanged in copy (it should be)
        self.assertEqual(creature_copy.max_hp, original_max_hp,
                         "Copied creature's max HP changed unexpectedly.")

    # --- Tests for POKE-7 --- 
    def test_apply_stat_change_attack_increase(self):
        """Test increasing attack stat."""
        creature = self.default_creature
        initial_attack = creature.attack
        # Expected: 50 * (1 + 0.66 / (2**(1-1))) = 50 * (1 + 0.66/1) = 50 * 1.66 = 83
        apply_stat_change(creature, "attack", 1)
        self.assertEqual(creature.attack, 83)
        # Expected: 83 * (1 + 0.66 / (2**(2-1))) = 83 * (1 + 0.66/2) = 83 * 1.33 = 110.39 -> 110
        apply_stat_change(creature, "attack", 2) # This applies stage 2 multiplier to current stat
        self.assertEqual(creature.attack, 110) # Note: The function applies change relative to current stat

    def test_apply_stat_change_attack_decrease(self):
        """Test decreasing attack stat."""
        creature = self.default_creature
        initial_attack = creature.attack
        # Expected: 50 / (1 + 0.66 / (2**(1-1))) = 50 / (1 + 0.66/1) = 50 / 1.66 = 30.12 -> 30
        apply_stat_change(creature, "attack", -1)
        self.assertEqual(creature.attack, 30)
        # Expected: 30 / (1 + 0.66 / (2**(2-1))) = 30 / (1 + 0.66/2) = 30 / 1.33 = 22.55 -> 22
        apply_stat_change(creature, "attack", -2) # Applies stage 2 reduction to current stat
        self.assertEqual(creature.attack, 22)

    def test_apply_stat_change_defense_increase(self):
        """Test increasing defense stat."""
        creature = self.default_creature
        initial_defense = creature.defense
        # Expected: 50 * 1.66 = 83
        apply_stat_change(creature, "defense", 1)
        self.assertEqual(creature.defense, 83)
        # Expected: 83 * 1.33 = 110.39 -> 110
        apply_stat_change(creature, "defense", 2)
        self.assertEqual(creature.defense, 110)

    def test_apply_stat_change_defense_decrease(self):
        """Test decreasing defense stat."""
        creature = self.default_creature
        initial_defense = creature.defense
        # Expected: 50 / 1.66 = 30.12 -> 30
        apply_stat_change(creature, "defense", -1)
        self.assertEqual(creature.defense, 30)
        # Expected: 30 / 1.33 = 22.55 -> 22
        apply_stat_change(creature, "defense", -2)
        self.assertEqual(creature.defense, 22)

    def test_apply_stat_change_invalid_stat(self):
        """Test applying change to an invalid stat name."""
        creature = self.default_creature
        initial_attack = creature.attack
        initial_defense = creature.defense
        apply_stat_change(creature, "speed", 1) # Should do nothing
        self.assertEqual(creature.attack, initial_attack)
        self.assertEqual(creature.defense, initial_defense)

    def test_apply_stat_change_zero_change(self):
        """Test applying a zero change."""
        creature = self.default_creature
        initial_attack = creature.attack
        # The current logic might break with change=0 due to 2**(0-1)
        # Let's test what happens (it should ideally do nothing)
        # apply_stat_change(creature, "attack", 0) # Raises Error: 2**-1 is 0.5
        # For now, we assume change is always non-zero based on usage
        # If 0 change is possible, the function needs adjustment
        pass # Skipping test for change=0 as it's not handled

    # --- Tests for POKE-4 --- 

    def test_creature_init_stores_native_sprite(self):
        """Test if Creature stores the sprite at native resolution initially."""
        # Arrange
        native_sprite = MockSurface(config.NATIVE_SPRITE_RESOLUTION)
        
        # Act
        creature = Creature(
            name="TestSpriteMon", type_="Normal", max_hp=100, attack=50, defense=50,
            moves=[], sprite=native_sprite
        )
        
        # Assert
        # Check if the stored sprite object is the one passed in (or a copy)
        # Most importantly, check its size remains native
        self.assertEqual(creature.sprite.get_size(), config.NATIVE_SPRITE_RESOLUTION,
                         f"Creature sprite should be initialized with native resolution {config.NATIVE_SPRITE_RESOLUTION}, "
                         f"but got {creature.sprite.get_size()}")

    @unittest.mock.patch('src.battle.battle_simulator.pygame.transform.scale')
    def test_draw_battle_scales_sprite_correctly(self, mock_scale):
        """Test if draw_battle calls pygame.transform.scale with the correct target size."""
        # Arrange
        # Create creatures with native sprites
        native_sprite1 = MockSurface(config.NATIVE_SPRITE_RESOLUTION)
        creature1 = Creature("Mon1", "Normal", 100, 50, 50, [], native_sprite1)
        
        native_sprite2 = MockSurface(config.NATIVE_SPRITE_RESOLUTION)
        creature2 = Creature("Mon2", "Fire", 100, 50, 50, [], native_sprite2)
        
        mock_buttons = [] # draw_battle needs buttons list
        mock_background = MockSurface((config.BATTLE_WIDTH, config.BATTLE_HEIGHT))
        mock_screen = MockSurface((config.BATTLE_WIDTH, config.BATTLE_HEIGHT))

        # Mock SCREEN object used within draw_battle if necessary
        with unittest.mock.patch('src.battle.battle_simulator.SCREEN', mock_screen):
            # Mock blit to avoid errors if SCREEN is not a real surface
             with unittest.mock.patch.object(mock_screen, 'blit') as mock_blit:
                # Mock font rendering: Patch the Font constructor instead of the render method
                mock_font_instance = MagicMock()
                mock_font_instance.render.return_value = MockSurface((10,10)) # Configure the mock render
                with unittest.mock.patch('src.battle.battle_simulator.pygame.font.Font', return_value=mock_font_instance) as mock_font_constructor:
                     # ALSO patch pygame.draw.rect to avoid TypeError with MockSurface
                     with unittest.mock.patch('src.battle.battle_simulator.pygame.draw.rect') as mock_draw_rect:
                         # Act
                         from src.battle.battle_simulator import draw_battle
                         draw_battle(creature1, creature2, mock_buttons, mock_background)

        # Assert
        # Check if pygame.transform.scale was called correctly for both creatures
        expected_size = config.BATTLE_SPRITE_DISPLAY_SIZE
        calls = [
            unittest.mock.call(native_sprite1, expected_size),
            unittest.mock.call(native_sprite2, expected_size)
        ]
        mock_scale.assert_has_calls(calls, any_order=True)
        assert mock_scale.call_count == 2

    # --- Tests for TEST-2 (Damage Calculation) ---

    def test_calculate_damage_super_effective(self):
        """Test damage calculation with super effective multiplier (2.0x)."""
        # Arrange
        attacker = Creature("Attacker", "Fire", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Nature", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("FireBlast", "Fire", 90)
        # Expected damage uses the formula: (10 * Att * Pow) / (30 * Def) + 2) * Eff * Rand
        # Base = (10 * 50 * 90) / (30 * 50) + 2 = (45000 / 1500) + 2 = 30 + 2 = 32
        # Expected Damage Range = (32 * 2.0) * [0.85, 1.0] = 64 * [0.85, 1.0] = [54.4, 64.0]
        # We'll check if the damage falls within this range (integer conversion included).
        expected_min_dmg = 54
        expected_max_dmg = 64

        # Act
        from src.battle.battle_simulator import calculate_damage # Import locally to use updated type_chart
        # Run multiple times to account for randomness
        damages = [calculate_damage(attacker, defender, move)[0] for _ in range(100)]

        # Assert
        for dmg in damages:
            self.assertTrue(expected_min_dmg <= dmg <= expected_max_dmg,
                            f"Super effective damage {dmg} out of range [{expected_min_dmg}, {expected_max_dmg}]")

    def test_calculate_damage_not_very_effective(self):
        """Test damage calculation with not very effective multiplier (0.5x)."""
        attacker = Creature("Attacker", "Fire", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Water", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("FireBlast", "Fire", 90)
        # Base = 32
        # Expected Damage Range = (32 * 0.5) * [0.85, 1.0] = 16 * [0.85, 1.0] = [13.6, 16.0]
        expected_min_dmg = 13
        expected_max_dmg = 16

        from src.battle.battle_simulator import calculate_damage
        damages = [calculate_damage(attacker, defender, move)[0] for _ in range(100)]

        for dmg in damages:
            self.assertTrue(expected_min_dmg <= dmg <= expected_max_dmg,
                            f"Not very effective damage {dmg} out of range [{expected_min_dmg}, {expected_max_dmg}]")

    def test_calculate_damage_neutral(self):
        """Test damage calculation with neutral multiplier (1.0x)."""
        attacker = Creature("Attacker", "Fire", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Electric", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("FireBlast", "Fire", 90)
        # Base = 32
        # Expected Damage Range = (32 * 1.0) * [0.85, 1.0] = 32 * [0.85, 1.0] = [27.2, 32.0]
        expected_min_dmg = 27
        expected_max_dmg = 32

        from src.battle.battle_simulator import calculate_damage
        damages = [calculate_damage(attacker, defender, move)[0] for _ in range(100)]

        for dmg in damages:
            self.assertTrue(expected_min_dmg <= dmg <= expected_max_dmg,
                            f"Neutral damage {dmg} out of range [{expected_min_dmg}, {expected_max_dmg}]")

    def test_calculate_damage_immune(self):
        """Test damage calculation with immunity (0.0x)."""
        attacker = Creature("Attacker", "Mind", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Shadow", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        move = Move("PsyBeam", "Mind", 65) # Mind attack
        # Expected Damage = 0

        from src.battle.battle_simulator import calculate_damage
        damage, effectiveness = calculate_damage(attacker, defender, move)

        self.assertEqual(damage, 0, f"Immune damage should be 0, got {damage}")
        # self.assertEqual(effectiveness, 0.0, "Effectiveness should be 0.0 for immunity") # Optional check

    def test_calculate_damage_stat_move(self):
        """Test that stat-changing moves deal 0 damage."""
        attacker = Creature("Attacker", "Normal", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        defender = Creature("Defender", "Normal", 100, 50, 50, [], MockSurface(config.NATIVE_SPRITE_RESOLUTION))
        # Assuming a stat move like Growl (Power 0, Effect: lower opponent attack)
        stat_move = Move("Growl", "Normal", 0, effect={'target': 'opponent', 'stat': 'attack', 'change': 1})

        from src.battle.battle_simulator import calculate_damage
        damage, effectiveness = calculate_damage(attacker, defender, stat_move)

        self.assertEqual(damage, 0, f"Stat move damage should be 0, got {damage}")


if __name__ == '__main__':
    # Need to import mock here if not already imported and handle potential absence
    # try:
    #     import unittest.mock  <- Remove from here
    # except ImportError:
    #     print("unittest.mock not available. Some mocking might not work.")

    # Mock Pygame init and display functions if they are called during imports
    try:
        # import sys <- Already imported at top
        if 'pygame' not in sys.modules:
            # If pygame hasn't been imported at all, create a dummy module
            class MockPygame:
                init = lambda: None
                quit = lambda: None
                display = unittest.mock.Mock()
                display.set_mode = lambda size: MockSurface(size)
                display.set_caption = lambda title: None
                transform = unittest.mock.Mock()
                transform.scale = lambda surface, size: MockSurface(size)
                font = unittest.mock.Mock()
                font.Font = lambda name, size: unittest.mock.Mock()
                Surface = MockSurface
                SRCALPHA = 0
                image = unittest.mock.Mock()
                image.load = lambda x: MockSurface((64,64))
                mixer = unittest.mock.Mock()
                mixer.init = lambda: None
                error = Exception

            sys.modules['pygame'] = MockPygame()
        else:
            # If pygame is imported, patch specific functions if needed
            pygame = sys.modules['pygame']
            if not hasattr(pygame, 'init'): pygame.init = lambda: None
            if not hasattr(pygame, 'quit'): pygame.quit = lambda: None
            if not hasattr(pygame, 'display'): pygame.display = unittest.mock.Mock()
            if not hasattr(pygame.display, 'set_mode'): pygame.display.set_mode = lambda size: MockSurface(size)
            if not hasattr(pygame.display, 'set_caption'): pygame.display.set_caption = lambda title: None
            # Add other necessary mocks if load_creatures triggers them

    except Exception as e:
        print(f"Warning: Could not set up full Pygame module mocks - {e}")

    unittest.main() 


================================================
File: tests/test_editor_ui.py
================================================
import unittest
from unittest.mock import MagicMock, patch
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
# Assuming editor_ui contains Button, Palette, PALETTE
from src.editor.editor_ui import Palette, PALETTE, Button # <<< Remove EditorUI
# Need Editor for type hinting and mocking structure
# from src.editor.pixle_art_editor import Editor 
# <<< Remove global initializer import >>>
# from src.editor.pixle_art_editor import _initialize_tkinter_globally 
# <<< Remove tkinter import >>>
# import tkinter
from src.editor.sprite_editor import SpriteEditor

class TestPalette(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Minimal Pygame setup needed for Font
        pygame.font.init()

    @classmethod
    def tearDownClass(cls):
        pygame.font.quit()

    def setUp(self):
        self.palette_pos = (50, 600)
        self.palette = Palette(self.palette_pos)
        # Mock the editor object that Palette.handle_click expects
        self.mock_editor = MagicMock()
        # We might need to mock specific editor attributes if handle_click uses them
        # For now, just mocking the select_color method is the primary need.
        # self.mock_editor.select_color = MagicMock()

    def test_initialization(self):
        """Test if the Palette initializes correctly."""
        self.assertEqual(self.palette.position, self.palette_pos)
        self.assertEqual(self.palette.scroll_offset, 0)
        self.assertTrue(hasattr(self.palette, 'font'))
        # Check if total_pages calculation seems reasonable
        expected_pages = (len(PALETTE) + self.palette.colors_per_page - 1) // self.palette.colors_per_page
        self.assertEqual(self.palette.total_pages, expected_pages)

    def test_handle_click_color_selection_first_page(self):
        """Test selecting a color block on the first page."""
        # Calculate the center position of the first color block (usually black)
        first_block_x = self.palette_pos[0] + self.palette.block_size // 2
        first_block_y = self.palette_pos[1] + self.palette.block_size // 2
        click_pos = (first_block_x, first_block_y)
        expected_color = PALETTE[0] # The first color

        self.palette.handle_click(click_pos, self.mock_editor)

        # Assert that the editor's select_color method was called once with the expected color
        self.mock_editor.select_color.assert_called_once_with(expected_color)

    def test_handle_click_scroll_down(self):
        """Test clicking the scroll down area."""
        initial_offset = self.palette.scroll_offset
        # Calculate a position within the approximate scroll down area
        scroll_x = self.palette_pos[0] + config.PALETTE_COLS * (self.palette.block_size + self.palette.padding) + 15
        scroll_y = self.palette_pos[1] + config.PALETTE_ROWS * (self.palette.block_size + self.palette.padding) - 10 # Near bottom
        click_pos = (scroll_x, scroll_y)

        # Only scroll if possible
        if self.palette.total_pages > 1:
            self.palette.handle_click(click_pos, self.mock_editor)
            self.assertEqual(self.palette.scroll_offset, initial_offset + 1)
            # Ensure select_color was NOT called
            self.mock_editor.select_color.assert_not_called()
        else:
            self.palette.handle_click(click_pos, self.mock_editor)
            self.assertEqual(self.palette.scroll_offset, initial_offset) # Should not change
            self.mock_editor.select_color.assert_not_called()

    def test_handle_click_scroll_up(self):
        """Test clicking the scroll up area."""
        # First, scroll down if possible to make scrolling up meaningful
        if self.palette.total_pages > 1:
            self.palette.scroll_offset = 1
        else:
             self.skipTest("Cannot test scroll up without multiple pages")
             
        initial_offset = self.palette.scroll_offset
        # Calculate a position within the approximate scroll up area
        scroll_x = self.palette_pos[0] + config.PALETTE_COLS * (self.palette.block_size + self.palette.padding) + 15
        scroll_y = self.palette_pos[1] + 10 # Near top
        click_pos = (scroll_x, scroll_y)

        self.palette.handle_click(click_pos, self.mock_editor)
        self.assertEqual(self.palette.scroll_offset, initial_offset - 1)
        self.mock_editor.select_color.assert_not_called()

    def test_handle_click_outside(self):
        """Test clicking outside the palette area."""
        click_pos = (self.palette_pos[0] - 10, self.palette_pos[1] - 10) # Clearly outside
        initial_offset = self.palette.scroll_offset

        self.palette.handle_click(click_pos, self.mock_editor)

        # Assert offset didn't change and select_color wasn't called
        self.assertEqual(self.palette.scroll_offset, initial_offset)
        self.mock_editor.select_color.assert_not_called()

    def test_draw_runs(self):
        """Test that the draw method runs without errors."""
        # We need a surface to draw on
        mock_surface = MagicMock(spec=pygame.Surface)
        # Need to mock surface methods if draw uses them (e.g., blit, draw.rect)
        mock_surface.blit = MagicMock()
        mock_surface.fill = MagicMock() # Palette draw might fill background?
        # Mock pygame.draw directly if needed
        with patch('pygame.draw.rect') as mock_draw_rect, \
             patch('pygame.draw.line') as mock_draw_line:
            try:
                # Pass a sample current color
                self.palette.draw(mock_surface, PALETTE[0])
            except Exception as e:
                self.fail(f"Palette.draw() raised exception unexpectedly: {e}")
            # Optionally, assert that drawing functions were called
            mock_draw_rect.assert_called()
            # mock_draw_line might be called for transparent colors
            # mock_surface.blit.assert_called() # For labels/arrows


# --- Add TestEditorUI Class ---
# <<< REMOVE TestEditorUI Class >>>
# @patch('pygame.draw.rect')
# @patch('pygame.draw.line')
# @patch('pygame.transform.scale')
# class TestEditorUI(unittest.TestCase):
#     @classmethod
#     @patch('tkinter.Tk') # <<< Patch tkinter.Tk for the whole class setup
#     def setUpClass(cls, mock_tk):
#         ...
#     @classmethod
#     def tearDownClass(cls):
#         ...
#     def setUp(self):
#         ...
#     ...
# <<< End Removal >>>

if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/test_event_handler.py
================================================
import unittest
from unittest.mock import MagicMock, patch
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
from src.core.event_handler import EventHandler
# Need Palette for position/size calculation, even if mocked
from src.editor.editor_ui import Palette, Button
from src.editor.tool_manager import ToolManager
from src.editor.sprite_editor import SpriteEditor


# Use a class decorator to patch pygame.key.get_mods for all tests in this class
# @patch('pygame.key.get_mods', return_value=0) # Mock get_mods to return 0 (no mods pressed)
class TestEventHandlerPaletteInteraction(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Minimal Pygame setup needed for Rect/Event/Font
        pygame.font.init() 

    @classmethod
    def tearDownClass(cls):
        pygame.font.quit()

    def setUp(self):
        # Mock the Editor
        self.mock_editor = MagicMock()
        self.mock_editor.dialog_mode = None # Ensure no dialog is active

        # --- Mock Palette --- 
        self.mock_editor.palette = MagicMock(spec=Palette)
        self.palette_pos = (50, 600) 
        self.mock_editor.palette.position = self.palette_pos
        self.mock_editor.palette.block_size = getattr(config, 'PALETTE_BLOCK_SIZE', 15)
        self.mock_editor.palette.padding = getattr(config, 'PALETTE_PADDING', 2)

        # --- Mock Sliders (to prevent EventHandler from handling clicks on them) ---
        # Mock ref alpha slider rect
        self.mock_editor.ref_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.ref_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.ref_alpha_slider_rect.width = 150 # Provide a width for comparison
        
        # Mock subject alpha slider rect (even if not always used, safer for the check)
        self.mock_editor.subj_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.subj_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.subj_alpha_slider_rect.width = 150 # Provide a width

        # Mock edit_mode for slider checks in EventHandler
        self.mock_editor.edit_mode = 'monster' # Assume monster mode for simplicity

        # The handle_click method on the mock palette is automatically a MagicMock

        # Create the real EventHandler instance with the mock Editor
        self.event_handler = EventHandler(self.mock_editor)

    def test_handle_mouse_down_calls_palette_click_correctly(self):
        """Verify EventHandler calls Palette.handle_click with correct args on palette click."""
        # Calculate a click position within the mocked palette area
        # (Simplified - assumes top-left block is clickable)
        click_x = self.palette_pos[0] + self.mock_editor.palette.block_size // 2
        click_y = self.palette_pos[1] + self.mock_editor.palette.block_size // 2
        click_pos = (click_x, click_y)

        # Create a mock MOUSEBUTTONDOWN event
        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEBUTTONDOWN
        mock_event.button = 1 # Left click
        mock_event.pos = click_pos

        # Call the method under test (can call process_event or the specific handler)
        # Calling process_event is slightly more integrated
        self.event_handler.process_event(mock_event)
        # Or: self.event_handler._handle_mouse_button_down(mock_event)

        # Assert: palette.handle_click was called once with (event.pos, editor)
        self.mock_editor.palette.handle_click.assert_called_once_with(click_pos, self.mock_editor)

# TODO: Add more tests for EventHandler logic (button clicks, canvas clicks, key presses etc.)

# Use a class decorator to patch pygame.key.get_mods for all tests in this class
# @patch('pygame.key.get_mods', return_value=0) # Mock get_mods to return 0 (no mods pressed)
class TestEventHandlerOtherInteractions(unittest.TestCase):
    # Separate class for different setup/focus

    @classmethod
    def setUpClass(cls):
        pygame.font.init()

    @classmethod
    def tearDownClass(cls):
        pygame.font.quit()

    def setUp(self):
        self.mock_editor = MagicMock()
        self.mock_editor.dialog_mode = None
        self.mock_editor.edit_mode = 'monster' # Default to monster

        # Mock ToolManager
        self.mock_editor.tool_manager = MagicMock(spec=ToolManager)

        # Mock Buttons (list of mock buttons)
        self.mock_button_action = MagicMock() # Action for the button
        self.mock_button = MagicMock(spec=Button)
        self.mock_button.rect = pygame.Rect(500, 10, 100, 30)
        self.mock_button.action = self.mock_button_action
        # Mock is_clicked behavior
        # We'll control its return value in the test
        self.mock_button.is_clicked = MagicMock(return_value=False) 
        self.mock_editor.buttons = [self.mock_button]

        # Mock SpriteEditor related things for canvas click
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_editor._get_sprite_editor_at_pos = MagicMock(return_value=None) # Default to miss
        
        # Mock Background related things for canvas click
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=False) # Default to miss

        # Mock Selection related things
        self.mock_editor.mode = 'draw' # Default to draw mode
        self.mock_editor.selection = MagicMock()
        self.mock_editor.selection.selecting = False

        # Mock sliders to prevent interference
        self.mock_editor.ref_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.ref_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.ref_alpha_slider_rect.width = 150 # Provide a width
        self.mock_editor.subj_alpha_slider_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.subj_alpha_slider_rect.collidepoint.return_value = False
        self.mock_editor.subj_alpha_slider_rect.width = 150 # Provide a width
        self.mock_editor.adjusting_alpha = False # <<< Add mock attribute
        self.mock_editor.adjusting_subject_alpha = False # <<< Add mock attribute

        # Mock Palette interaction to prevent interference
        self.mock_editor.palette = MagicMock(spec=Palette)
        # Need to mock the rect calculation used in EventHandler
        # Or ensure the test click pos is outside the palette rect
        self.mock_editor.palette.position = (1000, 1000) # Position it off-screen
        self.mock_editor.palette.block_size = 15
        self.mock_editor.palette.padding = 2
        
        # Create EventHandler
        self.event_handler = EventHandler(self.mock_editor)

    def test_button_click_calls_action(self):
        """Verify clicking a button calls its action."""
        click_pos = self.mock_button.rect.center
        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEBUTTONDOWN
        mock_event.button = 1
        mock_event.pos = click_pos

        # Configure the mock button's is_clicked to return True for this event
        self.mock_button.is_clicked.return_value = True 

        # Process the event
        self.event_handler.process_event(mock_event)

        # Assert
        self.mock_button.is_clicked.assert_called_once_with(mock_event)
        self.mock_button_action.assert_called_once()

    def test_canvas_click_calls_tool_manager(self):
        """Verify clicking the canvas calls tool_manager.handle_click."""
        # Simulate clicking on a sprite editor
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        click_pos = (60, 60) # Assume this hits the sprite editor
        self.mock_editor.mode = 'draw' # Ensure not in select mode

        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEBUTTONDOWN
        mock_event.button = 1
        mock_event.pos = click_pos
        
        self.event_handler.process_event(mock_event)

        # Assert tool manager was called
        self.mock_editor.tool_manager.handle_click.assert_called_once_with(click_pos)
        # Ensure save_state was called (since not in select mode)
        self.mock_editor.save_state.assert_called_once()

    def test_canvas_drag_calls_tool_manager(self):
        """Verify dragging on the canvas calls tool_manager.handle_drag."""
        drag_pos = (70, 70)
        self.mock_editor.mode = 'draw' # Ensure not in select mode
        
        # Simulate mouse button being down before motion
        self.event_handler.left_mouse_button_down = True

        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEMOTION
        mock_event.buttons = (1, 0, 0) # Left button held
        mock_event.pos = drag_pos
        
        self.event_handler.process_event(mock_event)

        # Assert tool manager drag was called
        self.mock_editor.tool_manager.handle_drag.assert_called_once_with(drag_pos)

    def test_canvas_drag_ignored_in_select_mode(self):
        """Verify canvas drag is ignored by tool manager in select mode."""
        drag_pos = (70, 70)
        self.mock_editor.mode = 'select' # In select mode
        
        # Simulate mouse button being down before motion
        self.event_handler.left_mouse_button_down = True
        
        mock_event = MagicMock(spec=pygame.event.Event)
        mock_event.type = pygame.MOUSEMOTION
        mock_event.buttons = (1, 0, 0) # Left button held
        mock_event.pos = drag_pos
        
        self.event_handler.process_event(mock_event)

        # Assert tool manager drag was NOT called
        self.mock_editor.tool_manager.handle_drag.assert_not_called()


if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/test_main_menu.py
================================================
import os
import sys
import unittest
from unittest import mock

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

from src.ui import main_menu


class TestMainMenu(unittest.TestCase):
    def test_menu_options_include_required_entries(self):
        labels = [label for label, _ in main_menu.MENU_OPTIONS]
        self.assertIn("Overworld", labels)
        self.assertIn("Battle Simulator", labels)
        self.assertIn("Pixel Art Editor", labels)
        self.assertIn("Quit", labels)

    def test_quit_option_has_no_module(self):
        quit_entries = [entry for entry in main_menu.MENU_OPTIONS if entry[0] == "Quit"]
        self.assertTrue(quit_entries, "Quit option missing from menu.")
        self.assertIsNone(quit_entries[0][1])

    def test_run_module_invokes_runpy(self):
        with mock.patch.object(main_menu.runpy, "run_module") as mock_run:
            main_menu.run_module("src.overworld.overworld")
            mock_run.assert_called_once_with("src.overworld.overworld", run_name="__main__")

    def test_run_module_swallows_system_exit(self):
        with mock.patch.object(main_menu.runpy, "run_module", side_effect=SystemExit(0)):
            main_menu.run_module("src.overworld.overworld")



================================================
File: tests/test_overworld_state.py
================================================
import os
import sys
import unittest

project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.insert(0, project_root)

from src.core.tileset import TileDefinition, TileSet
from src.overworld.state import (
    CellOverride,
    Connection,
    EntityDef,
    MapData,
    MapLayer,
    OverworldSession,
    TriggerDef,
)


class FakeAudio:
    def __init__(self):
        self.played = []
        self.stopped = False

    def play_music(self, music_id):
        self.played.append(music_id)

    def stop_music(self):
        self.stopped = True

    def play_sound(self, sound_id):
        self.played.append(f"sound:{sound_id}")


def build_tileset():
    tileset = TileSet("test", "Test", tile_size=32)
    tileset.tiles = [
        TileDefinition(id="floor", name="floor", filename="floor.png", properties={"walkable": True}),
        TileDefinition(id="wall", name="wall", filename="wall.png", properties={"walkable": False}),
    ]
    return tileset


def build_basic_map(map_id="map1", music_id=None):
    return MapData(
        map_id=map_id,
        name=map_id,
        version="1.0.0",
        tile_size=32,
        dimensions=(3, 3),
        tileset_id="test",
        layers=[
            MapLayer(
                name="ground",
                tiles=[
                    ["floor", "floor", "floor"],
                    ["floor", "floor", "floor"],
                    ["floor", "floor", "floor"],
                ],
            ),
            MapLayer(
                name="overlay",
                tiles=[
                    [None, None, None],
                    [None, None, None],
                    [None, None, None],
                ],
            ),
        ],
        connections=[],
        entities=[],
        triggers=[],
        overrides={},
        music_id=music_id,
        spawn={"x": 1, "y": 1},
    )


class TestOverworldSession(unittest.TestCase):
    def test_collision_and_override(self):
        tileset = build_tileset()
        world = build_basic_map()
        world.layers[0].tiles[0][1] = "wall"
        session = OverworldSession(world, tileset=tileset, audio_controller=FakeAudio())

        moved = session.move("up")  # into wall at (1,0)
        self.assertFalse(moved, "Movement should block on non-walkable tile.")
        # Make wall walkable via override
        world.set_override(1, 0, CellOverride(walkable=True))
        moved = session.move("up")
        self.assertTrue(moved, "Override should allow movement.")
        self.assertEqual((session.player.x, session.player.y), (1, 0))

    def test_entity_then_trigger_order(self):
        tileset = build_tileset()
        world = build_basic_map()
        world.entities.append(
            EntityDef(
                id="npc1",
                type="npc",
                name="NPC",
                sprite_id="npc_sprite",
                position={"x": 1, "y": 0},
                actions=[{"kind": "showText", "text": "Entity first"}],
            )
        )
        world.triggers.append(
            TriggerDef(
                id="t1",
                type="onInteract",
                position={"x": 1, "y": 0},
                actions=[{"kind": "showText", "text": "Trigger second"}],
                repeatable=True,
            )
        )
        session = OverworldSession(world, tileset=tileset, audio_controller=FakeAudio())
        session.player.x, session.player.y, session.player.facing = 1, 1, "up"

        session.interact()
        self.assertEqual(session.active_message, "Entity first")
        session.acknowledge_message()
        self.assertEqual(session.active_message, "Trigger second")

    def test_on_enter_trigger_consumes_repeatable(self):
        tileset = build_tileset()
        world = build_basic_map()
        world.triggers.append(
            TriggerDef(
                id="enter_once",
                type="onEnter",
                position={"x": 1, "y": 0},
                actions=[{"kind": "showText", "text": "Hello"}],
                repeatable=False,
            )
        )
        session = OverworldSession(world, tileset=tileset, audio_controller=FakeAudio())
        session.player.x, session.player.y = 1, 1
        session.move("up")
        self.assertEqual(session.active_message, "Hello")
        session.acknowledge_message()
        session.move("down")
        session.move("up")
        self.assertIsNone(session.active_message, "Non-repeatable trigger should not fire twice.")

    def test_edge_connection_switches_map_and_music(self):
        tileset = build_tileset()
        map_one = build_basic_map("map_one", music_id="song1")
        map_two = build_basic_map("map_two", music_id="song2")
        map_one.connections.append(
            Connection(
                id="north_exit",
                type="edge",
                from_ref="up",
                to={"mapId": "map_two", "spawn": {"x": 1, "y": 2}, "facing": "south"},
                condition=None,
                extra={},
            )
        )

        # Persist maps to disk so the loader path in session works
        map_one.save()
        map_two.save()

        audio = FakeAudio()
        session = OverworldSession(map_one, tileset=tileset, audio_controller=audio)
        session.player.x, session.player.y = 1, 0  # Move off north edge
        moved = session.move("up")

        self.assertTrue(moved, "Edge connection should allow movement to target map.")
        self.assertEqual(session.map.id, "map_two")
        self.assertEqual((session.player.x, session.player.y), (1, 2))
        self.assertEqual(audio.played[0], "song1")
        self.assertEqual(audio.played[-1], "song2")


if __name__ == "__main__":
    unittest.main()



================================================
File: tests/test_sprite_editor.py
================================================
import unittest
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
from src.editor.sprite_editor import SpriteEditor

class TestSpriteEditor(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        # Initialize Pygame minimally if needed for Surface creation
        # We might be able to avoid full pygame.init()
        # pygame.display.init() # <<< REMOVE THIS LINE
        pass # Keep setUpClass structure if needed later

    @classmethod
    def tearDownClass(cls):
        pygame.quit()

    def setUp(self):
        # Create a SpriteEditor instance for each test
        # Position doesn't really matter for these unit tests
        self.sprite_editor = SpriteEditor(position=(0, 0), name="test", sprite_dir="./temp_test_sprites")
        # Ensure the temp dir exists if needed for save/load tests later
        # os.makedirs("./temp_test_sprites", exist_ok=True)

    # def tearDown(self):
        # Clean up temp files/dirs if save/load tests are added
        # import shutil
        # if os.path.exists("./temp_test_sprites"):
        #     shutil.rmtree("./temp_test_sprites")

    def test_initialization(self):
        """Test if the SpriteEditor initializes correctly."""
        self.assertEqual(self.sprite_editor.frame.get_size(), config.NATIVE_SPRITE_RESOLUTION, "Frame size should match native resolution")
        # Check if it's transparent initially
        initial_color = self.sprite_editor.frame.get_at((0, 0))
        self.assertEqual(initial_color, (*config.BLACK[:3], 0), "Initial frame should be transparent black")
        self.assertEqual(self.sprite_editor.display_width, config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE)
        self.assertEqual(self.sprite_editor.display_height, config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE)

    def test_draw_pixel_within_bounds(self):
        """Test drawing a single pixel within the frame boundaries."""
        test_pos = (10, 15)
        test_color = (255, 0, 0, 255) # Opaque Red
        self.sprite_editor.draw_pixel(test_pos, test_color)
        drawn_color = self.sprite_editor.frame.get_at(test_pos)
        self.assertEqual(drawn_color, test_color, "Pixel color should match the drawn color")

    def test_draw_pixel_outside_bounds(self):
        """Test attempting to draw a pixel outside the frame boundaries."""
        # Test outside X
        test_pos_x = (config.NATIVE_SPRITE_RESOLUTION[0], 5)
        # Test outside Y
        test_pos_y = (5, config.NATIVE_SPRITE_RESOLUTION[1])
        test_color = (0, 255, 0, 255) # Opaque Green

        # Get initial color at a known valid position to check against later
        initial_color_check = self.sprite_editor.frame.get_at((0, 0))

        # Try drawing outside bounds - should have no effect
        self.sprite_editor.draw_pixel(test_pos_x, test_color)
        self.sprite_editor.draw_pixel(test_pos_y, test_color)

        # Check if a known valid pixel remained unchanged
        current_color_check = self.sprite_editor.frame.get_at((0, 0))
        self.assertEqual(current_color_check, initial_color_check, "Drawing outside bounds should not change pixels within bounds")
        # Pygame's set_at outside bounds raises IndexError, SpriteEditor handles this check
        # We are implicitly testing that no error is raised

    def test_get_pixel_color_within_bounds(self):
        """Test getting the color of a pixel within bounds."""
        test_pos = (5, 5)
        test_color = (0, 0, 255, 255) # Opaque Blue
        self.sprite_editor.draw_pixel(test_pos, test_color)
        retrieved_color = self.sprite_editor.get_pixel_color(test_pos)
        self.assertEqual(retrieved_color, test_color, "Retrieved color should match drawn color")

    def test_get_pixel_color_transparent(self):
        """Test getting the color of an un-drawn (transparent) pixel."""
        test_pos = (1, 1) # Assume this hasn't been drawn on
        retrieved_color = self.sprite_editor.get_pixel_color(test_pos)
        expected_transparent = (*config.BLACK[:3], 0)
        self.assertEqual(retrieved_color, expected_transparent, "Un-drawn pixel should be transparent black")

    def test_get_pixel_color_outside_bounds(self):
        """Test getting the color of a pixel outside bounds."""
        # Test outside X
        retrieved_color_x = self.sprite_editor.get_pixel_color((config.NATIVE_SPRITE_RESOLUTION[0], 5))
        # Test outside Y
        retrieved_color_y = self.sprite_editor.get_pixel_color((5, config.NATIVE_SPRITE_RESOLUTION[1]))
        self.assertIsNone(retrieved_color_x, "Getting color outside X bounds should return None")
        self.assertIsNone(retrieved_color_y, "Getting color outside Y bounds should return None")

    def test_get_grid_position_within_bounds(self):
        """Test converting screen coordinates within the visual editor bounds."""
        # Top-left corner pixel
        screen_pos_tl = (self.sprite_editor.position[0], self.sprite_editor.position[1])
        grid_pos_tl = self.sprite_editor.get_grid_position(screen_pos_tl)
        self.assertEqual(grid_pos_tl, (0, 0))

        # A position within the first pixel
        screen_pos_in_pixel = (self.sprite_editor.position[0] + config.EDITOR_PIXEL_SIZE // 2, self.sprite_editor.position[1] + config.EDITOR_PIXEL_SIZE // 2)
        grid_pos_in_pixel = self.sprite_editor.get_grid_position(screen_pos_in_pixel)
        self.assertEqual(grid_pos_in_pixel, (0, 0))

        # Center of the editor grid (approx)
        center_x_grid = config.EDITOR_GRID_SIZE // 2
        center_y_grid = config.EDITOR_GRID_SIZE // 2
        screen_pos_center = (self.sprite_editor.position[0] + center_x_grid * config.EDITOR_PIXEL_SIZE, 
                             self.sprite_editor.position[1] + center_y_grid * config.EDITOR_PIXEL_SIZE)
        grid_pos_center = self.sprite_editor.get_grid_position(screen_pos_center)
        self.assertEqual(grid_pos_center, (center_x_grid, center_y_grid))

        # Bottom-right corner pixel (test edge)
        br_x_grid = config.EDITOR_GRID_SIZE - 1
        br_y_grid = config.EDITOR_GRID_SIZE - 1
        screen_pos_br = (self.sprite_editor.position[0] + br_x_grid * config.EDITOR_PIXEL_SIZE, 
                           self.sprite_editor.position[1] + br_y_grid * config.EDITOR_PIXEL_SIZE)
        grid_pos_br = self.sprite_editor.get_grid_position(screen_pos_br)
        self.assertEqual(grid_pos_br, (br_x_grid, br_y_grid))

    def test_get_grid_position_outside_bounds(self):
        """Test converting screen coordinates outside the visual editor bounds."""
        # Just outside left
        screen_pos_left = (self.sprite_editor.position[0] - 1, self.sprite_editor.position[1])
        grid_pos_left = self.sprite_editor.get_grid_position(screen_pos_left)
        self.assertIsNone(grid_pos_left, "Position outside left bound should return None")

        # Just outside right
        screen_pos_right = (self.sprite_editor.position[0] + self.sprite_editor.display_width, self.sprite_editor.position[1])
        grid_pos_right = self.sprite_editor.get_grid_position(screen_pos_right)
        self.assertIsNone(grid_pos_right, "Position outside right bound should return None")

        # Just outside top
        screen_pos_top = (self.sprite_editor.position[0], self.sprite_editor.position[1] - 1)
        grid_pos_top = self.sprite_editor.get_grid_position(screen_pos_top)
        self.assertIsNone(grid_pos_top, "Position outside top bound should return None")

        # Just outside bottom
        screen_pos_bottom = (self.sprite_editor.position[0], self.sprite_editor.position[1] + self.sprite_editor.display_height)
        grid_pos_bottom = self.sprite_editor.get_grid_position(screen_pos_bottom)
        self.assertIsNone(grid_pos_bottom, "Position outside bottom bound should return None")

    # TODO: Add tests for load_sprite (requires mocking os.path.exists, pygame.image.load)
    # TODO: Add tests for save_sprite (requires mocking pygame.image.save, maybe os.makedirs)
    # TODO: Add tests for draw_background, draw_pixels, draw_highlight (verify calls/surface content?)

if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/test_tool_manager.py
================================================
import unittest
from unittest.mock import MagicMock, patch
import pygame
import os
import sys

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Now import the necessary modules
from src.core import config
from src.editor.tool_manager import DrawTool, FillTool, PasteTool, ToolManager
from src.editor.sprite_editor import SpriteEditor
from src.editor.selection_manager import SelectionTool

class TestDrawTool(unittest.TestCase):

    def setUp(self):
        self.draw_tool = DrawTool()
        self.mock_editor = MagicMock()
        # Common editor attributes needed by DrawTool
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor.current_color = (255, 0, 0, 255) # Red
        self.mock_editor.eraser_mode = False
        self.mock_editor.brush_size = 1
        # Mock SpriteEditor related things
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_sprite_editor.position = (50, 50) # Example position
        self.mock_sprite_editor.display_width = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE
        self.mock_sprite_editor.display_height = config.EDITOR_GRID_SIZE * config.EDITOR_PIXEL_SIZE
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = (10, 10) # Mock grid pos
        
        # Mock Background related things - Make canvas_rect a MagicMock
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        # Set necessary Rect attributes used by the code (optional but safer)
        self.mock_editor.canvas_rect.x = 100
        self.mock_editor.canvas_rect.y = 100
        self.mock_editor.canvas_rect.width = 200
        self.mock_editor.canvas_rect.height = 200
        # We will set collidepoint's return value in specific tests
        
        self.mock_editor.current_background = MagicMock(spec=pygame.Surface)
        self.mock_editor.current_background.get_size.return_value = (400, 400) # Example size
        self.mock_editor.view_offset_x = 0
        self.mock_editor.view_offset_y = 0
        self.mock_editor.editor_zoom = 1.0

    # --- Tests for _get_target ---
    def test_get_target_monster_mode_hit(self):
        """Test _get_target returns sprite editor in monster mode."""
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        target = self.draw_tool._get_target(self.mock_editor, (60, 60)) # Pos within mock sprite editor
        self.assertEqual(target, self.mock_sprite_editor)

    def test_get_target_monster_mode_miss(self):
        """Test _get_target returns None in monster mode if no sprite editor hit."""
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor._get_sprite_editor_at_pos.return_value = None
        target = self.draw_tool._get_target(self.mock_editor, (10, 10)) # Pos outside mock sprite editor
        self.assertIsNone(target)

    def test_get_target_background_mode_hit(self):
        """Test _get_target returns background surface in background mode."""
        self.mock_editor.edit_mode = 'background'
        # Mock canvas_rect.collidepoint to return True
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=True)
        target = self.draw_tool._get_target(self.mock_editor, (150, 150)) # Pos within mock canvas
        self.assertEqual(target, self.mock_editor.current_background)
        self.mock_editor.canvas_rect.collidepoint.assert_called_once_with((150, 150))

    def test_get_target_background_mode_miss(self):
        """Test _get_target returns None in background mode if outside canvas."""
        self.mock_editor.edit_mode = 'background'
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=False)
        target = self.draw_tool._get_target(self.mock_editor, (10, 10)) # Pos outside mock canvas
        self.assertIsNone(target)
        self.mock_editor.canvas_rect.collidepoint.assert_called_once_with((10, 10))

    # --- Tests for _draw_on_sprite ---
    def test_draw_on_sprite_single_pixel(self):
        """Test drawing a single pixel on sprite."""
        grid_pos = (5, 5)
        self.mock_editor.brush_size = 1
        self.mock_editor.eraser_mode = False
        self.draw_tool._draw_on_sprite(self.mock_editor, self.mock_sprite_editor, grid_pos)
        self.mock_sprite_editor.draw_pixel.assert_called_once_with(grid_pos, self.mock_editor.current_color)

    def test_erase_on_sprite_single_pixel(self):
        """Test erasing a single pixel on sprite."""
        grid_pos = (6, 6)
        self.mock_editor.brush_size = 1
        self.mock_editor.eraser_mode = True
        expected_erase_color = (*config.BLACK[:3], 0)
        self.draw_tool._draw_on_sprite(self.mock_editor, self.mock_sprite_editor, grid_pos)
        self.mock_sprite_editor.draw_pixel.assert_called_once_with(grid_pos, expected_erase_color)

    def test_draw_on_sprite_brush_size_3(self):
        """Test drawing with brush size 3 on sprite."""
        grid_pos = (10, 10)
        self.mock_editor.brush_size = 3
        self.mock_editor.eraser_mode = False
        self.draw_tool._draw_on_sprite(self.mock_editor, self.mock_sprite_editor, grid_pos)
        # Expect 3x3 = 9 calls
        self.assertEqual(self.mock_sprite_editor.draw_pixel.call_count, 9)
        # Check one of the calls (e.g., center)
        self.mock_sprite_editor.draw_pixel.assert_any_call(grid_pos, self.mock_editor.current_color)
        # Check another call (e.g., top-left of brush)
        self.mock_sprite_editor.draw_pixel.assert_any_call((9, 9), self.mock_editor.current_color)

    # --- Tests for _draw_on_background ---
    @patch('pygame.draw.circle')
    def test_draw_on_background_no_zoom(self, mock_draw_circle):
        """Test drawing on background with default zoom/pan."""
        screen_pos = (150, 150) # Within canvas_rect
        self.mock_editor.brush_size = 1
        self.mock_editor.eraser_mode = False
        self.mock_editor.editor_zoom = 1.0
        self.mock_editor.view_offset_x = 0
        self.mock_editor.view_offset_y = 0
        
        self.draw_tool._draw_on_background(self.mock_editor, self.mock_editor.current_background, screen_pos)
        
        # Expected original coordinates
        expected_orig_x = 150 - 100 # screen_pos.x - canvas_rect.x
        expected_orig_y = 150 - 100 # screen_pos.y - canvas_rect.y
        expected_radius = 1 # brush_size 1 -> radius 0.5 -> scaled_radius 1
        expected_color = self.mock_editor.current_color[:3] # RGB
        
        mock_draw_circle.assert_called_once_with(self.mock_editor.current_background, 
                                               expected_color, 
                                               (expected_orig_x, expected_orig_y), 
                                               expected_radius)

    @patch('pygame.draw.circle')
    def test_erase_on_background_zoomed_panned(self, mock_draw_circle):
        """Test erasing on background with zoom and pan."""
        screen_pos = (110, 120) # Within canvas_rect
        self.mock_editor.brush_size = 5
        self.mock_editor.eraser_mode = True
        self.mock_editor.editor_zoom = 2.0
        self.mock_editor.view_offset_x = 20
        self.mock_editor.view_offset_y = 40
        
        self.draw_tool._draw_on_background(self.mock_editor, self.mock_editor.current_background, screen_pos)
        
        # Expected original coordinates: ( (screen_x_rel + offset_x) / zoom )
        expected_orig_x = int(((110 - 100) + 20) / 2.0) # ((10) + 20) / 2 = 15
        expected_orig_y = int(((120 - 100) + 40) / 2.0) # ((20) + 40) / 2 = 30
        # Expected radius: max(1, int((brush_size / 2) / zoom)) = max(1, int(2.5 / 2.0)) = max(1, 1) = 1
        expected_radius = 1 
        expected_color = config.WHITE # Eraser color for background
        
        mock_draw_circle.assert_called_once_with(self.mock_editor.current_background, 
                                               expected_color, 
                                               (expected_orig_x, expected_orig_y), 
                                               expected_radius)

    # --- Tests for handle_click ---
    @patch.object(DrawTool, '_draw_on_sprite')
    def test_handle_click_delegates_to_sprite(self, mock_draw_on_sprite):
        """Test handle_click calls _draw_on_sprite correctly."""
        self.mock_editor.edit_mode = 'monster'
        click_pos = (60, 60)
        grid_pos = (10, 10)
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = grid_pos
        
        self.draw_tool.handle_click(self.mock_editor, click_pos)
        
        mock_draw_on_sprite.assert_called_once_with(self.mock_editor, self.mock_sprite_editor, grid_pos)

    @patch.object(DrawTool, '_draw_on_background')
    def test_handle_click_delegates_to_background(self, mock_draw_on_background):
        """Test handle_click calls _draw_on_background correctly."""
        self.mock_editor.edit_mode = 'background'
        click_pos = (150, 150)
        self.mock_editor.canvas_rect.collidepoint = MagicMock(return_value=True)
        
        self.draw_tool.handle_click(self.mock_editor, click_pos)
        
        mock_draw_on_background.assert_called_once_with(self.mock_editor, self.mock_editor.current_background, click_pos)


# --- Tests for FillTool ---
class TestFillTool(unittest.TestCase):

    def setUp(self):
        self.fill_tool = FillTool()
        self.mock_editor = MagicMock()
        # Common editor attributes needed by FillTool
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor.current_color = (0, 255, 0, 255) # Green (fill color)
        # Mock SpriteEditor related things
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = (5, 5) # Mock start grid pos
        
        # Mock pixel access - Need a way to simulate the changing colors during fill
        # Let's use a dictionary to represent a small grid state
        self.mock_grid_state = {
            (5, 5): (255, 0, 0, 255), # Target color (Red)
            (5, 6): (255, 0, 0, 255), # Target color
            (6, 5): (255, 0, 0, 255), # Target color
            (6, 6): (0, 0, 255, 255), # Different color (Blue)
        }
        DEFAULT_COLOR = (0,0,0,0) # Transparent black for other pixels

        def mock_get_pixel(pos):
            return self.mock_grid_state.get(pos, DEFAULT_COLOR)

        def mock_draw_pixel(pos, color):
            # Update the mock grid state when drawing
            if pos in self.mock_grid_state: # Only update tracked pixels for simplicity
                self.mock_grid_state[pos] = color
            # Print for debugging test state if needed:
            # print(f"Mock draw_pixel at {pos} with {color}")
            # print(f" Grid state: {self.mock_grid_state}")

        self.mock_sprite_editor.get_pixel_color.side_effect = mock_get_pixel
        self.mock_sprite_editor.draw_pixel.side_effect = mock_draw_pixel

        # Mock Background related things (less critical as fill is TODO)
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.canvas_rect.collidepoint.return_value = True # Assume hit for bg test
        self.mock_editor.current_background = MagicMock(spec=pygame.Surface)

    @patch.object(FillTool, '_flood_fill_sprite')
    def test_handle_click_calls_flood_fill_sprite(self, mock_flood_fill_sprite):
        """Test handle_click calls _flood_fill_sprite in monster mode."""
        self.mock_editor.edit_mode = 'monster'
        click_pos = (100, 100) # Example screen pos
        start_grid_pos = (5, 5)
        self.mock_sprite_editor.get_grid_position.return_value = start_grid_pos
        
        self.fill_tool.handle_click(self.mock_editor, click_pos)
        
        mock_flood_fill_sprite.assert_called_once_with(self.mock_sprite_editor, 
                                                      start_grid_pos, 
                                                      self.mock_editor.current_color)

    @patch.object(FillTool, '_flood_fill_background')
    def test_handle_click_calls_flood_fill_background(self, mock_flood_fill_background):
        """Test handle_click calls _flood_fill_background in background mode."""
        self.mock_editor.edit_mode = 'background'
        click_pos = (150, 150) # Example screen pos within mock canvas
        
        self.fill_tool.handle_click(self.mock_editor, click_pos)
        
        expected_bg_color = self.mock_editor.current_color[:3] # RGB for background
        mock_flood_fill_background.assert_called_once_with(self.mock_editor,
                                                         self.mock_editor.current_background, 
                                                         click_pos, 
                                                         expected_bg_color)

    def test_flood_fill_sprite_area(self):
        """Test _flood_fill_sprite actually fills contiguous area."""
        start_pos = (5, 5)
        fill_color = self.mock_editor.current_color # Green
        target_color = (255, 0, 0, 255) # Red
        other_color = (0, 0, 255, 255) # Blue

        # Ensure initial state
        self.assertEqual(self.mock_sprite_editor.get_pixel_color(start_pos), target_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((5, 6)), target_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 5)), target_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 6)), other_color)

        # Perform the fill
        self.fill_tool._flood_fill_sprite(self.mock_sprite_editor, start_pos, fill_color)

        # Check final state - Red pixels should now be Green
        self.assertEqual(self.mock_sprite_editor.get_pixel_color(start_pos), fill_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((5, 6)), fill_color)
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 5)), fill_color)
        # Blue pixel should remain unchanged
        self.assertEqual(self.mock_sprite_editor.get_pixel_color((6, 6)), other_color)

    def test_flood_fill_sprite_no_change_needed(self):
        """Test _flood_fill_sprite when start pixel is already fill color."""
        start_pos = (5, 5)
        fill_color = (255, 0, 0, 255) # Red (same as initial target)
        self.mock_editor.current_color = fill_color # Make editor color same
        self.mock_grid_state[start_pos] = fill_color # Set start pixel to fill color
        
        initial_state = self.mock_grid_state.copy()

        self.fill_tool._flood_fill_sprite(self.mock_sprite_editor, start_pos, fill_color)
        
        # Assert draw_pixel was never called
        self.mock_sprite_editor.draw_pixel.assert_not_called()
        # Assert grid state is unchanged
        self.assertEqual(self.mock_grid_state, initial_state)

    def test_handle_drag_does_nothing(self):
        """Verify handle_drag for FillTool does nothing."""
        # Just call it and ensure no errors and no relevant mocks were called
        try:
            self.fill_tool.handle_drag(self.mock_editor, (1,1))
        except Exception as e:
            self.fail(f"FillTool.handle_drag raised exception: {e}")
        # Ensure no drawing methods were called
        self.mock_sprite_editor.draw_pixel.assert_not_called()


# --- Tests for PasteTool ---
class TestPasteTool(unittest.TestCase):

    def setUp(self):
        self.paste_tool = PasteTool()
        self.mock_editor = MagicMock()
        # Attributes needed by PasteTool
        self.mock_editor.edit_mode = 'monster'
        self.mock_editor.copy_buffer = {
            (0, 0): (1, 1, 1, 255), # Pixel 1
            (1, 0): (2, 2, 2, 255), # Pixel 2
            (0, 1): (0, 0, 0, 0),   # Pixel 3 (transparent)
        }
        self.mock_editor.tool_manager = MagicMock(spec=ToolManager) # Needed for auto-switch on empty buffer
        # Mock SpriteEditor related things
        self.mock_sprite_editor = MagicMock(spec=SpriteEditor)
        self.mock_editor._get_sprite_editor_at_pos.return_value = self.mock_sprite_editor
        self.mock_sprite_editor.get_grid_position.return_value = (10, 10) # Mock paste target pos

        # Mock Background related things (less critical as paste is TODO)
        self.mock_editor.canvas_rect = MagicMock(spec=pygame.Rect)
        self.mock_editor.canvas_rect.collidepoint.return_value = True
        self.mock_editor.current_background = MagicMock(spec=pygame.Surface)

    @patch.object(PasteTool, '_apply_paste_sprite')
    def test_handle_click_calls_apply_paste_sprite(self, mock_apply_paste_sprite):
        """Test handle_click calls _apply_paste_sprite in monster mode."""
        self.mock_editor.edit_mode = 'monster'
        click_pos = (100, 100)
        paste_grid_pos = (10, 10)
        self.mock_sprite_editor.get_grid_position.return_value = paste_grid_pos
        
        self.paste_tool.handle_click(self.mock_editor, click_pos)
        
        mock_apply_paste_sprite.assert_called_once_with(self.mock_editor, 
                                                      self.mock_sprite_editor, 
                                                      paste_grid_pos)

    @patch.object(PasteTool, '_apply_paste_background')
    def test_handle_click_calls_apply_paste_background(self, mock_apply_paste_background):
        """Test handle_click calls _apply_paste_background in background mode."""
        self.mock_editor.edit_mode = 'background'
        click_pos = (150, 150)
        
        self.paste_tool.handle_click(self.mock_editor, click_pos)
        
        mock_apply_paste_background.assert_called_once_with(self.mock_editor,
                                                          self.mock_editor.current_background, 
                                                          click_pos)

    def test_handle_click_empty_buffer_switches_tool(self):
        """Test handle_click switches to draw tool if copy_buffer is empty."""
        self.mock_editor.copy_buffer = None # Empty buffer
        click_pos = (100, 100)

        self.paste_tool.handle_click(self.mock_editor, click_pos)

        # Assert tool manager was called to switch tool
        self.mock_editor.tool_manager.set_active_tool.assert_called_once_with('draw')
        # Assert draw_pixel wasn't called
        self.mock_sprite_editor.draw_pixel.assert_not_called()

    def test_apply_paste_sprite_logic(self):
        """Test the logic of _apply_paste_sprite."""
        paste_grid_pos = (10, 10)
        
        self.paste_tool._apply_paste_sprite(self.mock_editor, self.mock_sprite_editor, paste_grid_pos)

        # Expect draw_pixel to be called for non-transparent pixels in buffer
        expected_calls = [
            unittest.mock.call((10, 10), (1, 1, 1, 255)), # Pastes (0,0) from buffer at (10,10)
            unittest.mock.call((11, 10), (2, 2, 2, 255)), # Pastes (1,0) from buffer at (11,10)
            # Pixel at (0,1) is transparent, so no call for (10, 11)
        ]
        self.mock_sprite_editor.draw_pixel.assert_has_calls(expected_calls, any_order=True)
        # Ensure exactly 2 calls (only non-transparent pixels)
        self.assertEqual(self.mock_sprite_editor.draw_pixel.call_count, 2)

    def test_apply_paste_sprite_empty_buffer(self):
        """Test _apply_paste_sprite does nothing with empty buffer."""
        self.mock_editor.copy_buffer = None
        paste_grid_pos = (10, 10)

        self.paste_tool._apply_paste_sprite(self.mock_editor, self.mock_sprite_editor, paste_grid_pos)

        self.mock_sprite_editor.draw_pixel.assert_not_called()

    def test_handle_drag_does_nothing(self):
        """Verify handle_drag for PasteTool does nothing."""
        try:
            self.paste_tool.handle_drag(self.mock_editor, (1,1))
        except Exception as e:
            self.fail(f"PasteTool.handle_drag raised exception: {e}")
        self.mock_sprite_editor.draw_pixel.assert_not_called()


# --- Tests for ToolManager ---
class TestToolManager(unittest.TestCase):

    def setUp(self):
        self.mock_editor = MagicMock()
        
        # Mock the actual tool instances
        self.mock_draw_tool = MagicMock(spec=DrawTool)
        self.mock_fill_tool = MagicMock(spec=FillTool)
        self.mock_paste_tool = MagicMock(spec=PasteTool)
        # self.mock_select_tool = MagicMock(spec=SelectionTool) # Select not part of manager yet
        
        # Initialize ToolManager - it will create real tools temporarily
        self.manager = ToolManager(self.mock_editor)
        
        # NOW, replace the instance's tools dict with our mocks
        self.manager.tools = {
            'draw': self.mock_draw_tool,
            'fill': self.mock_fill_tool,
            'paste': self.mock_paste_tool,
            # 'select': self.mock_select_tool
        }
        # Set the active tool to the mock draw tool (matching the default)
        self.manager.active_tool = self.mock_draw_tool
        self.manager.active_tool_name = 'draw'

        # Reset the mocks used in initialization by the real tools
        # (Mainly activate call on the real draw tool)
        # It's cleaner to just verify calls within each test.

    def test_init_default_tool(self):
        """Test ToolManager initializes with the default tool active."""
        # For init test, create a separate instance to check initial state
        temp_manager = ToolManager(self.mock_editor)
        self.assertEqual(temp_manager.active_tool_name, 'draw')
        # Check that the *type* of the active tool is DrawTool
        self.assertIsInstance(temp_manager.active_tool, DrawTool)

    def test_set_active_tool(self):
        """Test switching the active tool calls activate/deactivate."""
        # Reset mocks before test, as setUp involves activate call on real tool
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()
        initial_tool_mock = self.manager.active_tool # Should be mock_draw_tool

        self.manager.set_active_tool('fill')

        self.assertEqual(self.manager.active_tool_name, 'fill')
        self.assertEqual(self.manager.active_tool, self.mock_fill_tool)
        # Check deactivate was called on the mock draw tool
        initial_tool_mock.deactivate.assert_called_once_with(self.mock_editor)
        # Check activate was called on the mock fill tool
        self.mock_fill_tool.activate.assert_called_once_with(self.mock_editor)

    def test_set_invalid_tool(self):
        """Test setting an invalid tool name does not change the active tool."""
        initial_tool_mock = self.manager.active_tool
        initial_name = self.manager.active_tool_name
        # Reset mocks that might have been called during setup/previous tests
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()
        self.mock_paste_tool.reset_mock()

        self.manager.set_active_tool('invalid_tool_name')

        # Assert tool and name remain unchanged
        self.assertEqual(self.manager.active_tool, initial_tool_mock)
        self.assertEqual(self.manager.active_tool_name, initial_name)
        # Ensure no activate/deactivate calls happened on our mocks
        self.mock_draw_tool.deactivate.assert_not_called()
        self.mock_fill_tool.activate.assert_not_called()
        self.mock_paste_tool.activate.assert_not_called()
        self.mock_paste_tool.deactivate.assert_not_called()

    def test_handle_click_delegation(self):
        """Test handle_click delegates to the active tool."""
        click_pos = (50, 60)
        # Set active tool to fill using the method
        self.manager.set_active_tool('fill')
        # Reset mocks called during set_active_tool
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()

        self.manager.handle_click(click_pos)

        # Check fill tool's handle_click was called
        self.mock_fill_tool.handle_click.assert_called_once_with(self.mock_editor, click_pos)
        # Ensure other tools weren't called
        self.mock_draw_tool.handle_click.assert_not_called()
        self.mock_paste_tool.handle_click.assert_not_called()

    def test_handle_drag_delegation(self):
        """Test handle_drag delegates to the active tool."""
        drag_pos = (70, 80)
        # Active tool is 'draw' after setUp
        # Reset mocks before test
        self.mock_draw_tool.reset_mock()
        self.mock_fill_tool.reset_mock()
        self.mock_paste_tool.reset_mock()

        self.manager.handle_drag(drag_pos)

        # Check draw tool's handle_drag was called
        self.mock_draw_tool.handle_drag.assert_called_once_with(self.mock_editor, drag_pos)
        # Ensure other tools weren't called
        self.mock_fill_tool.handle_drag.assert_not_called()
        self.mock_paste_tool.handle_drag.assert_not_called()

# Run tests if this file is executed directly
if __name__ == '__main__':
    unittest.main() 


================================================
File: tests/.DS_Store
================================================
[Non-text file]





